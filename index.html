<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modellatore 3D con Estrusione</title>
    <!-- Carica Tailwind CSS per uno stile rapido e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Carica Three.js (versione 0.132.2) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- Carica OrbitControls per il controllo della telecamera (versione 0.132.2) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.min.js"></script>
    <!-- Carica GLTFLoader, OBJLoader e MTLLoader per l'importazione di modelli -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/MTLLoader.min.js"></script>
    <!-- jsPDF non √® pi√π caricato qui, ma dinamicamente -->
    <style>
        /* Variabili CSS da index (12).html */
        :root {
            --primary: #6a11cb;
            --secondary: #2575fc;
            --accent: #00c853;
            --warning: #ffab00;
            --danger: #ff1744;
            --dark: #1a1a2e;
            --light: #f0f5ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--dark), #0f1b31); /* Sfondo da index (12).html */
            color: var(--light); /* Colore testo da index (12).html */
            font-family: 'Inter', sans-serif; /* Mantenuto Inter, ma puoi cambiarlo a 'Segoe UI' se preferisci */
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px; /* Padding da index (12).html */
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            flex: 1; /* Permette al contenitore di espandersi */
            display: flex;
            flex-direction: column;
        }
        
        header {
            text-align: center;
            padding: 0; /* Rimosso padding */
            margin-bottom: 0; /* Rimosso margin */
        }
        
        /* Rimosso h1 e subtitle styles */

        /* Stile del pannello "Glass" da index (12).html */
        .glass-panel {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
            transition: all 0.3s ease;
        }

        /* Stili specifici per il layout del modellatore, adattati */
        #app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 0; /* Rimuovi padding duplicato dal container */
        }
        #canvas-container {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.3); /* Sfondo pi√π scuro per il canvas */
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            width: 100% !important; /* Forza la larghezza al 100% del contenitore */
            height: 100% !important; /* Forza l'altezza al 100% del contenitore */
        }
        .control-panel {
            background-color: rgba(255, 255, 255, 0.08); /* Usa glass-panel background */
            border-radius: 20px; /* Usa glass-panel border-radius */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36); /* Usa glass-panel shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Usa glass-panel border */
            padding: 25px; /* Usa glass-panel padding */
            width: 350px; /* Larghezza fissa per il pannello di controllo */
            flex-shrink: 0; /* Impedisce al pannello di restringersi */
            overflow-y: auto; /* Scroll verticale se i contenuti superano l'altezza */
            margin-right: 20px;
            color: var(--light); /* Assicura che il testo sia chiaro */
        }
        @media (max-width: 1024px) {
            #app-container {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #FFFFFF; /* Colore pi√π contrastato */
        }
        .input-group input[type="number"],
        .input-group input[type="color"],
        .input-group select,
        .input-group input[type="text"] {
            width: 100%;
            background: rgba(255, 255, 255, 0.15); /* Sfondo input pi√π chiaro */
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .input-group input[type="color"] {
            height: 40px;
            padding: 0;
        }
        .btn {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background: linear-gradient(90deg, var(--primary), var(--secondary)); /* Gradiente da index (12).html */
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(106, 17, 203, 0.3); /* Ombra da index (12).html */
        }
        .btn-primary:hover {
            transform: translateY(-3px); /* Effetto hover da index (12).html */
            box-shadow: 0 8px 25px rgba(106, 17, 203, 0.5); /* Ombra hover da index (12).html */
            background-color: var(--secondary); /* Fallback */
        }
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo pi√π contrastato */
            color: var(--light);
            border: none;
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover pi√π contrastato */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .btn-success {
            background-color: var(--accent);
            color: white;
        }
        .btn-success:hover {
            background-color: #16a34a;
            transform: translateY(-1px);
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .tool-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo pi√π contrastato */
            color: var(--light); /* Testo chiaro */
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
            cursor: pointer;
            flex: 1;
            min-width: 70px;
        }
        .tool-button:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover pi√π contrastato */
            transform: translateY(-1px);
        }
        .tool-button.active {
            background: linear-gradient(90deg, var(--primary), var(--secondary)); /* Gradiente attivo da index (12).html */
            color: white;
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.5); /* Ombra attiva da index (12).html */
        }
        .tool-button svg {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
            fill: currentColor;
        }
        .code-output {
            background-color: rgba(255, 255, 255, 0.15); /* Sfondo input pi√π chiaro */
            color: #a7f3d0;
            padding: 15px;
            border-radius: 12px; /* Border-radius pi√π arrotondato */
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 0.875rem;
            overflow-x: auto;
            max-height: 200px;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1); /* Bordo da index (12).html */
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.25); /* Sfondo pi√π chiaro */
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: rgba(255, 255, 255, 0.35);
        }

        /* Stili per il modale */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 600px; /* Aumentato per contenere pi√π testo */
            width: 90%;
            color: #333; /* Colore testo per il modale */
        }
        .modal-content h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #333;
        }
        .modal-content p {
            font-size: 16px; /* Ridotto leggermente per leggibilit√† */
            color: #555;
            margin-bottom: 15px; /* Ridotto leggermente */
        }
        .modal-content ul {
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            padding: 0; /* Rimosso padding */
            margin-top: 0; /* Rimosso margin */
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
        }

        /* Nuovi stili per la toolbar */
        .toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.08); /* glass-panel background */
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
            position: relative; /* Aggiunto per stacking context */
            z-index: 101; /* Aggiunto per essere sopra il canvas */
        }
        .toolbar button {
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo pi√π contrastato */
            color: var(--light);
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 80px; /* Larghezza minima per i pulsanti */
        }
        .toolbar button:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover pi√π contrastato */
            transform: translateY(-2px);
        }
        .toolbar button.active {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.5);
        }
        .toolbar button span {
            font-size: 0.8rem; /* Testo pi√π piccolo sotto l'icona */
            display: block;
            margin-top: 4px;
        }

        /* Dropdown styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.5); /* Aumentata opacit√† per leggibilit√† */
            backdrop-filter: blur(8px); /* Leggermente meno blur */
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 100; /* Aumentato z-index per essere sopra il canvas e il pannello */
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
            top: 100%; /* Posiziona sotto il pulsante */
            left: 50%;
            transform: translateX(-50%); /* Centra il dropdown */
            margin-top: 10px; /* Spazio dal pulsante */
        }

        .dropdown-content button {
            color: var(--light);
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            background-color: transparent; /* Rimuove sfondo predefinito */
            width: 100%;
            text-align: left;
            font-size: 0.9rem;
            border-radius: 8px; /* Arrotonda i pulsanti interni */
        }

        .dropdown-content button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        /* New CSS for #importBtn */
        #importBtn {
            background: #4CAF50;
            border: none;
            border-radius: 10px; /* Changed to match other buttons */
            padding: 10px 15px; /* Changed to match other buttons */
            font-size: 1.2rem; /* Changed to match other buttons */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s; /* Combined transitions */
            display: flex; /* Added flex for icon and text */
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 80px;
        }
        #importBtn:hover {
            transform: translateY(-2px); /* Consistent hover effect */
            background: #66BB6A;
        }
        #importBtn svg {
            fill: white;
            vertical-align: middle;
        }

        /* Stili per il pulsante PDF con spinner */
        .btn-spinner {
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Stili per il messaggio di stato fluttuante */
        #export-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1001; /* Assicura che sia sopra il modale */
        }
    </style>
</head>
<body class="flex flex-col">

    <div class="container">
        <!-- Header dell'applicazione - Rimosso testo -->
        <header></header>
        
        <!-- Nuova Barra degli Strumenti -->
        <div class="toolbar">
            <button id="setupBaseBtn" title="Inizializza motore 3D">üõ†Ô∏è<span>Setup Base</span></button>
            
            <div class="dropdown">
                <button id="geometriesDropdownBtn" title="Aggiungi forme base">üßä<span>Geometrie</span></button>
                <div class="dropdown-content">
                    <button id="lineToolBtnToolbar">Linea</button>
                    <button id="polylineToolBtnToolbar">Polilinea</button>
                    <button id="circleToolBtnToolbar">Cerchio</button>
                    <button id="arcToolBtnToolbar">Arco</button>
                    <button id="triangleToolBtnToolbar">Triangolo</button>
                    <button id="rectangleToolBtnToolbar">Rettangolo</button>
                    <hr class="my-2 border-gray-600">
                    <button id="addCubeBtnToolbar">Cubo</button>
                    <button id="addSphereBtnToolbar">Sfera</button>
                    <button id="addCylinderBtnToolbar">Cilindro</button>
                </div>
            </div>

            <button id="materialsBtn" title="Modifica superfici">üé®<span>Materiali</span></button>
            <button id="paintBucketBtn" title="Applica Materiale">üñåÔ∏è<span>Applica</span></button>
            <button id="lightsBtn" title="Aggiungi illuminazione">üí°<span>Luci</span></button>
            <button id="importBtn" title="Carica modelli 3D">üì¶<span>Importa</span></button>
            <!-- Hidden file inputs for OBJ/MTL/Texture loading -->
            <input type="file" id="objInputHidden" accept=".obj" hidden>
            <input type="file" id="mtlInputHidden" accept=".mtl" hidden>
            <input type="file" id="textureInputHidden" accept="image/*" multiple hidden>
            
            <div class="dropdown">
                <button id="templatesDropdownBtn" title="Template">ü™ë<span>Template</span></button>
                <div class="dropdown-content">
                    <button id="applyWoodMaterialBtn">ü™µ Legno</button>
                    <button id="applyMarbleMaterialBtn">üèÅ Marmo</button>
                    <button id="applyMetalMaterialBtn">üî© Metallo</button>
                    <hr class="my-2 border-gray-600">
                    <button id="addChairBtnToolbar">ü™ë Sedia</button>
                    <button id="addTableBtnToolbar">üõãÔ∏è Tavolo</button>
                    <button id="addEmptyRoomBtnToolbar">Stanza Vuota</button>
                </div>
            </div>

            <button id="controlsBtn" title="Naviga nella scena">‚úã<span>Controlli</span></button>
            <button id="performanceBtn" title="Ottimizza rendering">‚ö°<span>Performance</span></button>
            <button id="infoBtn" title="Informazioni sull'uso">‚ÑπÔ∏è<span>Info</span></button>
        </div>
        
        <!-- Contenitore principale dell'app -->
        <main id="app-container" class="p-4 sm:p-6 lg:p-8">
            <!-- Pannello di controllo -->
            <aside class="control-panel glass-panel">
                <h2 class="text-2xl font-bold text-white mb-4">Controlli</h2>

                <!-- Modalit√† di Lavoro -->
                <div class="input-group">
                    <label>Modalit√†:</label>
                    <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                        <button id="viewModeBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Vista
                        </button>
                        <button id="drawModeBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Disegno
                        </button>
                    </div>
                </div>

                <!-- Controlli Vista -->
                <div id="viewControlsPanel" class="mt-6 border-t border-gray-200 pt-6">
                    <h3 class="text-xl font-semibold text-white mb-4">Controlli Vista</h3>
                    <div class="btn-group mb-4">
                        <button id="viewTopBtn" class="btn btn-secondary flex-1">Top</button>
                        <button id="viewFrontBtn" class="btn btn-secondary flex-1">Front</button>
                        <button id="viewRightBtn" class="btn btn-secondary flex-1">Right</button>
                        <button id="viewIsoBtn" class="btn btn-secondary flex-1">Isometrica</button>
                    </div>
                    <div class="btn-group mb-4">
                        <button id="perspectiveViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Prospettica
                        </button>
                        <button id="orthographicViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Ortogonale
                        </button>
                    </div>
                    <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                        <button id="solidViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Solido
                        </button>
                        <button id="wireframeViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Wireframe
                        </button>
                    </div>
                </div>

                <!-- Controlli Disegno (mostrati solo in modalit√† Disegno) -->
                <div id="drawingControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Opzioni Disegno 2D</h3>
                    <!-- Input for Drawing Plane Y-position -->
                    <div class="input-group">
                        <label for="drawingPlaneYInput">Altezza Piano Disegno (cm):</label>
                        <input type="number" id="drawingPlaneYInput" value="0" step="0.1">
                    </div>

                    <!-- Snap to Grid Toggle -->
                    <div class="input-group">
                        <label>Snap alla Griglia:</label>
                        <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                            <button id="snapGridOnBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                                Attiva
                            </button>
                            <button id="snapGridOffBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                                Disattiva
                            </button>
                        </div>
                    </div>

                    <!-- Grid Snap Resolution Input -->
                    <div class="input-group">
                        <label for="gridSnapResolutionInput">Risoluzione Snap Griglia (cm):</label>
                        <input type="number" id="gridSnapResolutionInput" value="10" step="1">
                    </div>


                    <!-- Options for Line/Polyline -->
                    <div id="lineDrawingOptions" class="input-group">
                        <label>Punti Disegnati:</label>
                        <span id="drawnPointsCount" class="font-bold text-white">0</span>
                        <div class="flex gap-2 mt-2">
                            <input type="number" id="lineLengthInput" placeholder="Lunghezza (cm)" step="0.1" class="flex-1">
                        </div>
                    </div>

                    <!-- Options for Circle -->
                    <div id="circleDrawingOptions" class="input-group hidden">
                        <label for="circleRadiusInput">Raggio Cerchio (cm):</label>
                        <input type="number" id="circleRadiusInput" value="1" step="0.1">
                    </div>

                    <!-- Options for Arc -->
                    <div id="arcDrawingOptions" class="input-group hidden">
                        <label for="arcRadiusInput">Raggio Arco (cm):</label>
                        <input type="number" id="arcRadiusInput" value="1" step="0.1">
                        <label for="arcStartAngleInput">Angolo Iniziale (Gradi):</label>
                        <input type="number" id="arcStartAngleInput" value="0" step="1">
                        <label for="arcEndAngleInput">Angolo Finale (Gradi):</label>
                        <input type="number" id="arcEndAngleInput" value="90" step="1">
                        <label for="arcClockwiseInput">Senso Orario:</label>
                        <input type="checkbox" id="arcClockwiseInput">
                    </div>

                    <!-- Options for Rectangle -->
                    <div id="rectangleDrawingOptions" class="input-group hidden">
                        <label for="rectWidthInput">Larghezza Rettangolo (cm):</label>
                        <input type="number" id="rectWidthInput" value="2" step="0.1">
                        <label for="rectHeightInput">Altezza Rettangolo (cm):</label>
                        <input type="number" id="rectHeightInput" value="2" step="0.1">
                    </div>

                    <!-- Options for Triangle -->
                    <div id="triangleDrawingOptions" class="input-group hidden">
                        <label for="triBaseInput">Base Triangolo (cm):</label>
                        <input type="number" id="triBaseInput" value="2" step="0.1">
                        <label for="triHeightInput">Altezza Triangolo (cm):</label>
                        <input type="number" id="triHeightInput" value="2" step="0.1">
                    </div>

                    <!-- Grid Visibility Toggle -->
                    <div class="input-group">
                        <label>Griglia Visibile:</label>
                        <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                            <button id="showGridBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                                Mostra
                            </button>
                            <button id="hideGridBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                                Nascondi
                            </button>
                        </div>
                    </div>

                    <button id="closePathBtn" class="btn btn-success w-full mb-3">Concludi Percorso</button>
                    <button id="undoDrawingBtn" class="btn btn-secondary w-full">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M12 19V5M5 12L12 5L19 12"></path></svg>
                        Annulla (Ctrl+Z)
                    </button>
                </div>

                <!-- Controlli Forme 3D Base -->
                <div id="basic3DShapeControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Opzioni Forma 3D Base</h3>
                    <div id="cubeOptions" class="input-group hidden">
                        <label for="cubeSideInput">Lato Cubo (cm):</label>
                        <input type="number" id="cubeSideInput" value="2" step="0.1">
                    </div>
                    <div id="sphereOptions" class="input-group hidden">
                        <label for="sphereRadiusInput">Raggio Sfera (cm):</label>
                        <input type="number" id="sphereRadiusInput" value="1" step="0.1">
                    </div>
                    <div id="cylinderOptions" class="input-group hidden">
                        <label for="cylinderRadiusInput">Raggio Cilindro (cm):</label>
                        <input type="number" id="cylinderRadiusInput" value="1" step="0.1">
                        <label for="cylinderHeightInput">Altezza Cilindro (cm):</label>
                        <input type="number" id="cylinderHeightInput" value="2" step="0.1">
                    </div>
                    <button id="addBasicShapeBtn" class="btn btn-primary w-full hidden">Aggiungi Forma 3D</button>
                </div>

                <!-- Controlli Estrusione (mostrati solo dopo aver concluso un percorso) -->
                <div id="extrusionControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Estrusione</h3>
                    <div class="input-group">
                        <label for="extrusionDepth">Altezza Estrusione (cm):</label>
                        <input type="number" id="extrusionDepth" value="2" step="0.1">
                    </div>
                    <button id="extrudeBtn" class="btn btn-primary w-full">Estrudi</button>
                </div>

                <!-- Selezione Oggetto -->
                <div class="input-group mt-6 border-t border-gray-200 pt-6">
                    <label for="selectedObject">Oggetto Selezionato:</label>
                    <select id="selectedObject" class="mb-2"></select>
                    <button id="removeObjectBtn" class="btn btn-danger w-full">Rimuovi Selezionato</button>
                </div>

                <!-- Propriet√† Oggetto Selezionato -->
                <div id="objectProperties" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Propriet√† Oggetto</h3>

                    <div class="input-group">
                        <label for="objectColor">Colore:</label>
                        <input type="color" id="objectColor" value="#3b82f6">
                    </div>

                    <div class="input-group">
                        <label>Posizione (cm):</label>
                        <div class="flex gap-2">
                            <input type="number" id="posX" placeholder="X" step="0.1" class="flex-1">
                            <input type="number" id="posY" placeholder="Y" step="0.1" class="flex-1">
                            <input type="number" id="posZ" placeholder="Z" step="0.1" class="flex-1">
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Rotazione (Gradi):</label>
                        <div class="flex gap-2">
                            <input type="number" id="rotX" placeholder="X" step="1" class="flex-1">
                            <input type="number" id="rotY" placeholder="Y" step="1" class="flex-1">
                            <input type="number" id="rotZ" placeholder="Z" step="1" class="flex-1">
                        </div>
                    </div>
                </div>

                <div class="btn-group mt-6 border-t border-gray-200 pt-6">
                    <button id="resetSceneBtnSide" class="btn btn-secondary flex-1">Reset Scena</button>
                    <button id="generateCodeBtn" class="btn btn-primary flex-1">Genera Codice Three.js</button>
                    <button id="printBtn" class="btn btn-secondary flex-1">Stampa Disegno</button>
                    <button id="exportDXFBtn" class="btn btn-secondary flex-1">Esporta DXF</button> <!-- Nuovo pulsante DXF -->
                    <button id="exportPDFBtn" class="btn btn-secondary flex-1">
                        <span class="btn-icon">üìÑ</span>
                        <span class="btn-text">Esporta PDF</span>
                        <span class="btn-spinner" hidden>‚åõ</span>
                    </button>
                </div>
            </aside>

            <!-- Contenitore Canvas 3D -->
            <main id="canvas-container" class="flex-1">
                <!-- Il canvas verr√† aggiunto qui dal JavaScript -->
            </main>
        </main>

        <!-- Sezione Output Codice -->
        <section class="p-4 sm:p-6 lg:p-8 glass-panel">
            <h2 class="text-2xl font-bold text-white mb-4">Codice Three.js Generato</h2>
            <div class="code-output-wrapper relative">
                <button id="copyCodeBtn" class="copy-button">Copia Codice</button>
                <pre id="generatedCode" class="code-output">
// Il codice Three.js della tua scena apparir√† qui.
// Puoi copiarlo e usarlo in un progetto Three.js!
                </pre>
            </div>
        </section>
    </div>

    <!-- Footer - Rimosso testo -->
    <footer></footer>

    <!-- Messaggio di stato fluttuante -->
    <div id="export-status"></div>

    <script>
        // Global error listener for unhandled errors
        window.addEventListener('error', (e) => {
            console.error("Unhandled global error:", e);
            UIManager.showModalMessage("Unexpected Error", `An unexpected error occurred: ${e.message || 'Details in console.'}`);
        });

        // Helper function to dispose of Three.js object resources
        function disposeObject(obj) {
            if (obj.geometry) {
                obj.geometry.dispose();
            }
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(material => material.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            if (obj.children) {
                obj.children.forEach(child => disposeObject(child)); // Recursively dispose children
            }
        }

        // Helper function to read a file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (error) => {
                    console.error(`Error reading file: ${file.name}`, error);
                    reject(error);
                };
                reader.readAsText(file);
            });
        }

        // Helper function to load a single texture from a File
        function loadTexture(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        resolve({ name: file.name, texture: texture });
                    };
                    img.onerror = (error) => {
                        console.error(`Error loading texture image ${file.name}:`, error);
                        reject(new Error(`Failed to load texture image: ${file.name}.`));
                    };
                    img.src = e.target.result;
                };
                reader.onerror = (error) => {
                    console.error(`Error reading texture file ${file.name}:`, error);
                    reject(new Error(`Failed to read texture file: ${file.name}.`));
                };
                reader.readAsDataURL(file);
            });
        }

        // === SceneManager Class ===
        class SceneManager {
            constructor(container) {
                this.container = container;
                this.scene = new THREE.Scene();
                this.perspectiveCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                // Initialize orthographic camera with a default frustum size
                this.orthographicCamera = new THREE.OrthographicCamera(
                    container.clientWidth / - 2, container.clientWidth / 2,
                    container.clientHeight / 2, container.clientHeight / - 2,
                    0.1, 1000
                );
                this.activeCamera = this.perspectiveCamera; // Start with perspective camera

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.controls = new THREE.OrbitControls(this.activeCamera, this.renderer.domElement);
                this.gridHelper = new THREE.GridHelper(100, 100); // 100 units by 100 divisions
                this.axesHelper = new THREE.AxesHelper(5); // Axes helper, 5 units long
                this.isWireframe = false;
                this.isGridVisible = true;
                this.cameraType = 'perspective'; // 'perspective' or 'orthographic'

                this.init();
            }

            init() {
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setClearColor(0x222222); // Dark background for the scene
                this.container.appendChild(this.renderer.domElement);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1).normalize();
                this.scene.add(directionalLight);

                this.perspectiveCamera.position.set(5, 5, 5); // Initial perspective camera position
                this.orthographicCamera.position.set(5, 5, 5); // Initial orthographic camera position
                this.orthographicCamera.zoom = 100; // Adjust zoom for orthographic view
                this.orthographicCamera.updateProjectionMatrix();


                this.scene.add(this.axesHelper); // Add axes helper to the scene

                this.controls.update();

                // Add grid helper
                this.gridHelper.material.opacity = 0.5;
                this.gridHelper.material.transparent = true;
                this.scene.add(this.gridHelper);

                window.addEventListener('resize', this.onWindowResize.bind(this), false);
            }

            onWindowResize() {
                const aspect = this.container.clientWidth / this.container.clientHeight;

                // Update perspective camera
                this.perspectiveCamera.aspect = aspect;
                this.perspectiveCamera.updateProjectionMatrix();

                // Update orthographic camera frustum
                const frustumSize = 10; // This value might need adjustment based on desired scale
                this.orthographicCamera.left = - frustumSize * aspect / 2;
                this.orthographicCamera.right = frustumSize * aspect / 2;
                this.orthographicCamera.top = frustumSize / 2;
                this.orthographicCamera.bottom = - frustumSize / 2;
                this.orthographicCamera.updateProjectionMatrix();

                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.controls.update();
                this.renderer.render(this.scene, this.activeCamera); // Render with active camera
            }

            resetScene() {
                // Remove all objects except lights, cameras, grid, and axes helper
                const objectsToRemove = [];
                this.scene.children.forEach(obj => {
                    if (obj !== this.perspectiveCamera && obj !== this.orthographicCamera &&
                        obj !== this.gridHelper && obj !== this.axesHelper && !(obj instanceof THREE.Light)) {
                        objectsToRemove.push(obj);
                    }
                });
                objectsToRemove.forEach(obj => {
                    disposeObject(obj);
                    this.scene.remove(obj);
                });
                
                // Reset camera positions and controls target
                this.perspectiveCamera.position.set(5, 5, 5);
                this.orthographicCamera.position.set(5, 5, 5);
                this.controls.target.set(0, 0, 0); // Reset controls target to origin
                this.controls.update();

                // Clear any selected object and drawing
                if (objectManager) objectManager.clearObjects();
                if (drawingManager) drawingManager.clearDrawing(false); // Do not save state on full reset
                if (uiManager) uiManager.updateUI();
                UIManager.showModalMessage("Scene Reset", "All objects and drawings have been cleared.");
            }


            setPresetView(view) {
                const distance = this.activeCamera.position.length(); // Keep current distance from origin
                switch (view) {
                    case 'top':
                        this.activeCamera.position.set(0, distance, 0);
                        break;
                    case 'front':
                        this.activeCamera.position.set(0, 0, distance);
                        break;
                    case 'right':
                        this.activeCamera.position.set(distance, 0, 0);
                        break;
                    case 'iso':
                        this.activeCamera.position.set(distance, distance, distance);
                        break;
                }
                this.activeCamera.lookAt(this.scene.position);
                this.controls.update();
            }

            setWireframeMode(isWireframe) {
                this.isWireframe = isWireframe;
                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => {
                                material.wireframe = isWireframe;
                                material.needsUpdate = true;
                            });
                        } else {
                            object.material.wireframe = isWireframe;
                            object.material.needsUpdate = true;
                        }
                    }
                });
            }

            setGridVisibility(visible) {
                this.isGridVisible = visible;
                this.gridHelper.visible = visible;
            }

            setCameraType(type) {
                if (this.cameraType === type) return; // No change needed

                this.cameraType = type;
                const currentPosition = this.activeCamera.position.clone();
                const currentTarget = this.controls.target.clone();

                if (type === 'perspective') {
                    this.activeCamera = this.perspectiveCamera;
                } else if (type === 'orthographic') {
                    this.activeCamera = this.orthographicCamera;
                }

                // Restore position and target
                this.activeCamera.position.copy(currentPosition);
                this.controls.target.copy(currentTarget);

                // Update controls to use the new active camera
                this.controls.object = this.activeCamera;
                this.onWindowResize(); // Update projection matrix for new camera
                this.controls.update();
                UIManager.showStatus(`Camera set to ${type}.`);
            }
        }

        // === ObjectManager Class ===
        class ObjectManager {
            constructor(sceneManager, uiManager, drawingManager) {
                this.sceneManager = sceneManager;
                this.uiManager = uiManager; // Will be set after UIManager is initialized
                this.drawingManager = drawingManager; // Will be set after DrawingManager is initialized
                this.objects = []; // Array to store all managed Three.js objects
                this.selectedObject = null;
                this.paintBucketMode = false;
                this.currentBasic3DShapeTool = 'none'; // Added to track selected basic 3D shape tool

                this.setupMaterials();

                // Event listener for object selection via raycasting
                this.sceneManager.renderer.domElement.addEventListener('click', this.onCanvasClick.bind(this), false);
            }

            setupMaterials() {
                // Basic materials for templates
                this.woodMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // SaddleBrown
                this.marbleMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC }); // Beige
                this.metalMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, specular: 0x808080, shininess: 30 }); // Grayish metal
            }

            addObject(object, name = 'Object') {
                this.sceneManager.scene.add(object);
                this.objects.push(object);
                this.selectObject(object); // Select the newly added object
                // The uiManager.updateSelectedObjectOptions will be called by selectObject
            }

            removeObject(object) {
                if (!object) return;
                this.sceneManager.scene.remove(object);
                disposeObject(object);
                this.objects = this.objects.filter(obj => obj.uuid !== object.uuid);
                if (this.selectedObject && this.selectedObject.uuid === object.uuid) {
                    this.selectedObject = null;
                }
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updateUI(); // Update UI to hide properties panel if no object selected
            }

            removeSelectedObject() {
                if (this.selectedObject) {
                    this.removeObject(this.selectedObject);
                    UIManager.showModalMessage("Object Removed", "Selected object has been removed.");
                } else {
                    UIManager.showModalMessage("No Object Selected", "Please select an object to remove.");
                }
            }

            selectObject(object) {
                // Remove highlight from previously selected object
                if (this.selectedObject) {
                    if (Array.isArray(this.selectedObject.material)) {
                        this.selectedObject.material.forEach(m => {
                            if (m.emissive && m._previousEmissive) { // Check if emissive exists
                                m.emissive.set(m._previousEmissive);
                                delete m._previousEmissive;
                            } else if (m.color && m._previousColor) { // Revert color if it was used for highlight
                                m.color.set(m._previousColor);
                                delete m._previousColor;
                            }
                        });
                    } else {
                        if (this.selectedObject.material && this.selectedObject.material.emissive && this.selectedObject.material._previousEmissive) { // Check if emissive exists
                            this.selectedObject.material.emissive.set(this.selectedObject.material._previousEmissive);
                            delete this.selectedObject.material._previousEmissive;
                        } else if (this.selectedObject.material && this.selectedObject.material.color && this.selectedObject.material._previousColor) { // Revert color if it was used for highlight
                            this.selectedObject.material.color.set(this.selectedObject.material._previousColor);
                            delete this.selectedObject.material._previousColor;
                        }
                    }
                }

                this.selectedObject = object;

                // Add highlight to new selected object
                if (this.selectedObject) {
                    if (Array.isArray(this.selectedObject.material)) {
                        this.selectedObject.material.forEach(m => {
                            if (m.emissive) { // Check if emissive exists before trying to clone
                                m._previousEmissive = m.emissive.clone();
                                m.emissive.setHex(0x00ff00); // Green highlight
                            } else if (m.color) { // Fallback for materials without emissive (e.g., LineBasicMaterial)
                                m._previousColor = m.color.clone();
                                m.color.setHex(0x00ff00); // Change color for highlight
                            }
                        });
                    } else {
                        if (this.selectedObject.material && this.selectedObject.material.emissive) { // Check if emissive exists before trying to clone
                            this.selectedObject.material._previousEmissive = this.selectedObject.material.emissive.clone();
                            this.selectedObject.material.emissive.setHex(0x00ff00); // Green highlight
                        } else if (this.selectedObject.material && this.selectedObject.material.color) { // Fallback for materials without emissive
                            this.selectedObject.material._previousColor = this.selectedObject.material.color.clone();
                            this.selectedObject.material.color.setHex(0x00ff00); // Change color for highlight
                        }
                    }
                    this.uiManager.updateObjectProperties(this.selectedObject);
                } else {
                    this.uiManager.updateObjectProperties(null); // Clear properties panel
                }
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updateUI(); // Update UI to show/hide properties panel
            }

            updateSelectedObjectColor(hexColor) {
                if (this.selectedObject && this.selectedObject.material) {
                    const newColor = new THREE.Color(hexColor);
                    if (Array.isArray(this.selectedObject.material)) {
                        this.selectedObject.material.forEach(m => m.color.set(newColor));
                    } else {
                        this.selectedObject.material.color.set(newColor);
                    }
                }
            }

            updateSelectedObjectPosition(axis, value) {
                if (this.selectedObject) {
                    this.selectedObject.position[axis] = value;
                }
            }

            updateSelectedObjectRotation(axis, value) {
                if (this.selectedObject) {
                    this.selectedObject.rotation[axis] = THREE.MathUtils.degToRad(value);
                }
            }

            onCanvasClick(event) {
                if (this.drawingManager.drawingMode) return; // Do not select objects in drawing mode

                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / this.sceneManager.renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / this.sceneManager.renderer.domElement.clientHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.sceneManager.activeCamera); // Use active camera for raycasting

                const intersects = raycaster.intersectObjects(this.objects, true);

                if (this.paintBucketMode) {
                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        const currentColor = this.uiManager.elements.objectColorInput.value;
                        this.applyMaterial(new THREE.MeshPhongMaterial({ color: new THREE.Color(currentColor) }), 'Custom Color', intersectedObject);
                        UIManager.showStatus(`Applied color ${currentColor} to object.`);
                    } else {
                        UIManager.showStatus("No object found to apply color.", true);
                    }
                    this.togglePaintBucketMode(); // Deactivate paint bucket after one use
                } else {
                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        this.selectObject(intersectedObject);
                    } else {
                        this.selectObject(null); // Deselect if clicked on empty space
                    }
                }
            }

            togglePaintBucketMode() {
                this.paintBucketMode = !this.paintBucketMode;
                this.uiManager.updateUI(); // Update button active state
            }

            // Method to set the currently active basic 3D shape tool
            setCurrentBasic3DShapeTool(tool) {
                this.currentBasic3DShapeTool = tool;
                this.uiManager.updateUI(); // Update UI to show/hide relevant options
                UIManager.showStatus(`Basic 3D shape tool set to: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
            }

            applyMaterial(material, name, targetObject = null) {
                const objectToApply = targetObject || this.selectedObject;
                if (objectToApply && objectToApply.isMesh) {
                    // Dispose old material if it's not shared
                    if (objectToApply.material && objectToApply.material.dispose) {
                        objectToApply.material.dispose();
                    }
                    objectToApply.material = material;
                    objectToApply.material.needsUpdate = true;
                    UIManager.showStatus(`Applied ${name} material.`);
                } else {
                    UIManager.showStatus("Please select an object to apply material.", true);
                }
            }

            addBasic3DShape(shapeType) {
                let geometry;
                let material = new THREE.MeshPhongMaterial({ color: 0x3b82f6 }); // Default blue

                if (this.uiManager.elements.objectColorInput) {
                    material.color.set(this.uiManager.elements.objectColorInput.value);
                }

                switch (shapeType) {
                    case 'cube':
                        // Ensure input element exists before trying to access its value
                        const cubeSideInput = this.uiManager.elements.cubeSideInput;
                        const cubeSide = cubeSideInput ? parseFloat(cubeSideInput.value) / 100 : 1; // Default to 1m if not found
                        geometry = new THREE.BoxGeometry(cubeSide, cubeSide, cubeSide);
                        break;
                    case 'sphere':
                        const sphereRadiusInput = this.uiManager.elements.sphereRadiusInput;
                        const sphereRadius = sphereRadiusInput ? parseFloat(sphereRadiusInput.value) / 100 : 0.5; // Default to 0.5m
                        geometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
                        break;
                    case 'cylinder':
                        const cylinderRadiusInput = this.uiManager.elements.cylinderRadiusInput;
                        const cylinderHeightInput = this.uiManager.elements.cylinderHeightInput;
                        const cylinderRadius = cylinderRadiusInput ? parseFloat(cylinderRadiusInput.value) / 100 : 0.5;
                        const cylinderHeight = cylinderHeightInput ? parseFloat(cylinderHeightInput.value) / 100 : 1;
                        geometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32);
                        break;
                    default:
                        console.warn("Unknown shape type:", shapeType);
                        return;
                }
                const mesh = new THREE.Mesh(geometry, material);
                this.addObject(mesh, shapeType.charAt(0).toUpperCase() + shapeType.slice(1));
                UIManager.showModalMessage("Shape Added", `${shapeType.charAt(0).toUpperCase() + shapeType.slice(1)} added to scene.`);
            }

            // Method to add a chair (example complex object)
            addChair() {
                // This is a placeholder. A real chair would involve multiple geometries
                // or loading a model. For simplicity, let's create a basic chair shape.
                const chairGroup = new THREE.Group();

                // Seat
                const seatGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.5);
                const seatMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Wood color
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(0, 0.25, 0);
                chairGroup.add(seat);

                // Legs
                const legGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
                const legMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const leg1 = new THREE.Mesh(legGeometry, legMaterial);
                leg1.position.set(0.2, 0, 0.2);
                chairGroup.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, legMaterial);
                leg2.position.set(-0.2, 0, 0.2);
                chairGroup.add(leg2);
                const leg3 = new THREE.Mesh(legGeometry, legMaterial);
                leg3.position.set(0.2, 0, -0.2);
                chairGroup.add(leg3);
                const leg4 = new THREE.Mesh(legGeometry, legMaterial);
                leg4.position.set(-0.2, 0, -0.2);
                chairGroup.add(leg4);

                // Backrest
                const backrestGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.05);
                const backrest = new THREE.Mesh(backrestGeometry, legMaterial);
                backrest.position.set(0, 0.5, -0.225);
                chairGroup.add(backrest);

                this.addObject(chairGroup, 'Chair');
                UIManager.showModalMessage("Object Added", "Chair added to scene.");
            }

            // Method to add a table (example complex object)
            addTable() {
                const tableGroup = new THREE.Group();

                // Tabletop
                const tabletopGeometry = new THREE.BoxGeometry(1.2, 0.05, 0.8);
                const tabletopMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Wood color
                const tabletop = new THREE.Mesh(tabletopGeometry, tabletopMaterial);
                tabletop.position.set(0, 0.75, 0);
                tableGroup.add(tabletop);

                // Legs
                const legGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
                const legMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const leg1 = new THREE.Mesh(legGeometry, legMaterial);
                leg1.position.set(0.5, 0.35, 0.3);
                tableGroup.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, legMaterial);
                leg2.position.set(-0.5, 0.35, 0.3);
                tableGroup.add(leg2);
                const leg3 = new THREE.Mesh(legGeometry, legMaterial);
                leg3.position.set(0.5, 0.35, -0.3);
                tableGroup.add(leg3);
                const leg4 = new THREE.Mesh(legGeometry, legMaterial);
                leg4.position.set(-0.5, 0.35, -0.3);
                tableGroup.add(leg4);

                this.addObject(tableGroup, 'Table');
                UIManager.showModalMessage("Object Added", "Table added to scene.");
            }

            addEmptyRoom() {
                const roomGroup = new THREE.Group();
                const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, side: THREE.BackSide }); // Grey walls, visible from inside
                const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 }); // Darker grey floor

                const roomSize = 10; // 10x10x10 meters

                // Floor
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -roomSize / 2; // Place floor at the bottom
                roomGroup.add(floor);

                // Walls (using BoxGeometry for simplicity, could be planes)
                const wallThickness = 0.1;

                // Back Wall
                const backWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, roomSize, wallThickness), wallMaterial);
                backWall.position.set(0, 0, -roomSize / 2);
                roomGroup.add(backWall);

                // Front Wall (with opening for camera, or just omitted)
                // For simplicity, let's omit the front wall to allow viewing inside
                // const frontWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, roomSize, wallThickness), wallMaterial);
                // frontWall.position.set(0, 0, roomSize / 2);
                // roomGroup.add(frontWall);

                // Left Wall
                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomSize, roomSize), wallMaterial);
                leftWall.position.set(-roomSize / 2, 0, 0);
                roomGroup.add(leftWall);

                // Right Wall
                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomSize, roomSize), wallMaterial);
                rightWall.position.set(roomSize / 2, 0, 0);
                roomGroup.add(rightWall);

                // Ceiling
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), wallMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.y = roomSize / 2;
                roomGroup.add(ceiling);

                this.addObject(roomGroup, 'Empty Room');
                UIManager.showModalMessage("Object Added", "Empty room added to scene.");

                // Adjust camera to be inside the room
                this.sceneManager.activeCamera.position.set(0, 0, roomSize / 2 - 1); // Just inside the front opening
                this.sceneManager.controls.target.set(0, 0, 0);
                this.sceneManager.controls.update();
            }

            startImportSequence() {
                // Trigger OBJ file input
                this.uiManager.elements.objInputHidden.click();
            }

            async handleObjFileSelection(objFile) {
                if (!objFile) return;

                UIManager.showStatus(`Loading OBJ file: ${objFile.name}...`);
                const objText = await readFileAsText(objFile);

                // Ask for MTL file
                const mtlFile = await new Promise(resolve => {
                    UIManager.showModalMessage("Import OBJ", "Do you have an MTL file for this OBJ model? If yes, select it. Otherwise, click Close.",
                        `<button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove(); document.getElementById('mtlInputHidden').click();">Select MTL</button>
                         <button class="modal-button bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md ml-2" onclick="document.getElementById('customModal').remove();">Close</button>`
                    );
                    document.getElementById('mtlInputHidden').onchange = (e) => {
                        resolve(e.target.files[0]);
                    };
                });

                let mtlText = null;
                if (mtlFile) {
                    UIManager.showStatus(`Loading MTL file: ${mtlFile.name}...`);
                    mtlText = await readFileAsText(mtlFile);
                }

                // Ask for textures
                const textureFiles = await new Promise(resolve => {
                    UIManager.showModalMessage("Import OBJ", "Do you have texture images for this model? Select all relevant images. Otherwise, click Close.",
                        `<button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove(); document.getElementById('textureInputHidden').click();">Select Textures</button>
                         <button class="modal-button bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md ml-2" onclick="document.getElementById('customModal').remove();">Close</button>`
                    );
                    document.getElementById('textureInputHidden').onchange = (e) => {
                        resolve(Array.from(e.target.files));
                    };
                });

                const loadedTextures = {};
                if (textureFiles && textureFiles.length > 0) {
                    UIManager.showStatus(`Loading ${textureFiles.length} textures...`);
                    const texturePromises = textureFiles.map(file => loadTexture(file));
                    const results = await Promise.allSettled(texturePromises);
                    results.forEach(result => {
                        if (result.status === 'fulfilled') {
                            loadedTextures[result.value.name] = result.value.texture;
                        } else {
                            console.error("Failed to load a texture:", result.reason);
                            UIManager.showStatus(`Failed to load a texture: ${result.reason.message}`, true);
                        }
                    });
                }

                this.loadObjModel(objText, mtlText, loadedTextures, objFile.name);
            }

            loadObjModel(objText, mtlText = null, textures = {}, modelName = 'Imported Model') {
                const objLoader = new THREE.OBJLoader();
                const mtlLoader = new THREE.MTLLoader();

                if (mtlText) {
                    const materials = mtlLoader.parse(mtlText);
                    materials.preload();

                    // Assign loaded textures to materials
                    for (const materialName in materials.materials) {
                        const material = materials.materials[materialName];
                        // Assuming texture names in MTL match file names (e.g., map_Kd diffuse.jpg)
                        for (const textureKey in textures) {
                            // Check if the texture name is part of the material's texture map (e.g., map_Kd)
                            // This is a simplified check. A robust solution would parse MTL more deeply.
                            if (material.map && material.map.name === textureKey) {
                                material.map = textures[textureKey];
                            }
                            // Add more checks for other map types (normalMap, specularMap, etc.) if needed
                        }
                    }
                    objLoader.setMaterials(materials);
                }

                try {
                    const object = objLoader.parse(objText);
                    this.addObject(object, modelName);
                    UIManager.showStatus(`Model "${modelName}" loaded successfully.`);
                } catch (error) {
                    console.error("Error loading OBJ model:", error);
                    UIManager.showModalMessage("Error Loading Model", `Failed to load OBJ model: ${error.message}. Check console for details.`);
                }
            }

            clearObjects() {
                // Remove all objects except camera, lights, and grid helper
                const objectsToRemove = this.objects.filter(obj =>
                    obj !== this.sceneManager.activeCamera && // Check against active camera
                    obj !== this.sceneManager.gridHelper &&
                    obj !== this.sceneManager.axesHelper && // Also check against axes helper
                    !(obj instanceof THREE.Light)
                );

                objectsToRemove.forEach(obj => this.removeObject(obj));
                this.objects = []; // Ensure the array is empty
                this.selectedObject = null;
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updateUI();
            }
        }

        // === DrawingManager Class ===
        class DrawingManager {
            constructor(sceneManager, uiManager, objectManager) {
                this.sceneManager = sceneManager;
                this.uiManager = uiManager; // Will be set after UIManager is initialized
                this.objectManager = objectManager; // Already set via circular dependency
                this.drawingMode = false;
                this.currentDrawingTool = 'none'; // 'line', 'polyline', 'circle', 'arc', 'triangle', 'rectangle'
                this.drawnPoints = []; // Stores THREE.Vector3 points for current drawing
                this.drawingLine = null; // THREE.Line object for current drawing feedback
                this.drawingPreviewMesh = null; // For shapes like circle, rect, triangle
                
                // Drawing plane for raycasting
                this.drawingPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Y=0 plane initially
                // Visual representation of the drawing plane
                const planeGeometry = new THREE.PlaneGeometry(100, 100); // Large plane
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x8888ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                this.drawingPlaneMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                this.drawingPlaneMesh.rotation.x = -Math.PI / 2; // Orient flat on XZ plane
                this.drawingPlaneMesh.position.y = 0; // Initial position
                this.drawingPlaneMesh.visible = false; // Hidden by default
                this.sceneManager.scene.add(this.drawingPlaneMesh);

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.intersectionPoint = new THREE.Vector3();

                this.undoStack = []; // Stores states for undo
                this.redoStack = []; // Stores states for redo

                // New: Intersection indicator (red sphere)
                const indicatorGeometry = new THREE.SphereGeometry(0.05, 16, 16); // 5cm radius
                const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color
                this.currentIntersectionIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                this.currentIntersectionIndicator.visible = false; // Hidden by default
                this.sceneManager.scene.add(this.currentIntersectionIndicator);

                this.snapToGrid = true; // Default to true
                this.gridSnapResolution = 0.1; // Default snap to 10cm (0.1 meters)

                this.sceneManager.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this), false);
                this.sceneManager.renderer.domElement.addEventListener('click', this.onCanvasClick.bind(this), false);

                // Event listeners for drawing tool buttons (assuming they are in UIManager)
                // These will be wired up in UIManager's addEventListeners
            }

            setDrawingMode(mode) {
                this.drawingMode = mode;
                if (mode) {
                    this.sceneManager.controls.enabled = false; // Disable orbit controls in drawing mode
                    this.sceneManager.setGridVisibility(true); // Ensure grid is visible for drawing
                    this.drawingPlaneMesh.visible = true; // Show drawing plane
                    this.currentIntersectionIndicator.visible = true; // Show intersection indicator
                    this.clearDrawing(true); // Clear any previous drawing and save state
                } else {
                    this.sceneManager.controls.enabled = true; // Re-enable orbit controls
                    this.drawingPlaneMesh.visible = false; // Hide drawing plane
                    this.currentIntersectionIndicator.visible = false; // Hide intersection indicator
                    this.clearDrawing(false); // Clear current drawing without saving to undo
                }
                this.uiManager.updateUI();
            }

            setDrawingPlaneY(yPositionCm) {
                const yMeters = yPositionCm / 100; // Convert cm to meters
                this.drawingPlane.constant = -yMeters; // Plane constant is distance from origin along normal
                this.drawingPlaneMesh.position.y = yMeters;
                UIManager.showStatus(`Drawing plane set to Y: ${yPositionCm} cm`);
            }

            setSnapToGrid(enabled) {
                this.snapToGrid = enabled;
                UIManager.showStatus(`Snap alla Griglia: ${enabled ? 'Attivo' : 'Disattivo'}`);
            }

            setGridSnapResolution(resolutionCm) {
                this.gridSnapResolution = resolutionCm / 100; // Convert cm to meters
                UIManager.showStatus(`Risoluzione Snap Griglia: ${resolutionCm} cm`);
            }

            setCurrentDrawingTool(tool) {
                this.currentDrawingTool = tool;
                this.clearDrawing(true); // Clear previous drawing and save state for undo
                this.uiManager.updateUI(); // Update UI to show/hide relevant options
                UIManager.showStatus(`Drawing tool set to: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
            }

            onMouseMove(event) {
                if (!this.drawingMode) return;

                this.mouse.x = (event.clientX / this.sceneManager.renderer.domElement.clientWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / this.sceneManager.renderer.domElement.clientHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.sceneManager.activeCamera); // Use active camera for raycasting
                const intersects = this.raycaster.ray.intersectPlane(this.drawingPlane, this.intersectionPoint);

                if (intersects) {
                    // Apply snapping if enabled
                    if (this.snapToGrid) {
                        this.intersectionPoint.x = Math.round(this.intersectionPoint.x / this.gridSnapResolution) * this.gridSnapResolution;
                        // For XZ plane, Y is fixed by drawingPlane, no need to snap Y
                        this.intersectionPoint.z = Math.round(this.intersectionPoint.z / this.gridSnapResolution) * this.gridSnapResolution;
                    }
                    this.currentIntersectionIndicator.position.copy(this.intersectionPoint);
                    this.currentIntersectionIndicator.visible = true; // Ensure indicator is visible when over plane

                    // Update drawing feedback based on tool
                    if (this.currentDrawingTool === 'line' || this.currentDrawingTool === 'polyline') {
                        if (this.drawnPoints.length > 0) {
                            this.updateDrawingLine(this.intersectionPoint);
                        }
                    } else if (this.currentDrawingTool === 'circle') {
                        if (this.drawnPoints.length === 1) { // Center point is set
                            this.updateCirclePreview(this.intersectionPoint);
                        }
                    } else if (this.currentDrawingTool === 'rectangle') {
                        if (this.drawnPoints.length === 1) { // First corner is set
                            this.updateRectanglePreview(this.intersectionPoint);
                        }
                    } else if (this.currentDrawingTool === 'triangle') {
                        if (this.drawnPoints.length === 1) { // First point (base start)
                            this.updateTrianglePreview(this.intersectionPoint);
                        }
                    }
                } else {
                    this.currentIntersectionIndicator.visible = false; // Hide indicator if not over plane
                }
            }

            onCanvasClick(event) {
                if (!this.drawingMode) return;

                this.raycaster.setFromCamera(this.mouse, this.sceneManager.activeCamera); // Use active camera for raycasting
                const intersects = this.raycaster.ray.intersectPlane(this.drawingPlane, this.intersectionPoint);

                if (intersects) {
                    // Use the snapped intersection point for adding the point
                    const clickPoint = this.intersectionPoint.clone();
                    this.addPoint(clickPoint);
                }
            }

            addPoint(point) {
                this.saveDrawingState(); // Save state before modifying

                this.drawnPoints.push(point);
                this.uiManager.updateUI(); // Update drawn points count

                if (this.currentDrawingTool === 'line') {
                    if (this.drawnPoints.length === 2) {
                        this.createLineSegment(this.drawnPoints[0], this.drawnPoints[1]);
                        this.finalizeShape();
                    } else {
                        // Reset for next line segment if needed, or clear for new line
                        this.clearDrawing(false); // Clear current line preview
                        this.drawnPoints.push(point); // Add the first point back
                    }
                } else if (this.currentDrawingTool === 'polyline') {
                    if (this.drawnPoints.length >= 2) {
                        this.updateDrawingLine(); // Update continuous polyline
                    }
                } else if (this.currentDrawingTool === 'circle') {
                    if (this.drawnPoints.length === 1) { // Center point is clicked
                        UIManager.showStatus("Click again to define circle radius.");
                    } else if (this.drawnPoints.length === 2) { // Radius point is clicked
                        const center = this.drawnPoints[0];
                        const radius = center.distanceTo(this.drawnPoints[1]);
                        this.createCircle(center, radius);
                        this.finalizeShape();
                    }
                } else if (this.currentDrawingTool === 'arc') {
                    if (this.drawnPoints.length === 1) {
                        UIManager.showStatus("Click again for second point of arc.");
                    } else if (this.drawnPoints.length === 2) {
                        UIManager.showStatus("Click again for third point of arc.");
                    } else if (this.drawnPoints.length === 3) {
                        this.createArc(this.drawnPoints[0], this.drawnPoints[1], this.drawnPoints[2]);
                        this.finalizeShape();
                    }
                } else if (this.currentDrawingTool === 'rectangle') {
                    if (this.drawnPoints.length === 1) {
                        UIManager.showStatus("Click again to define opposite corner of rectangle.");
                    } else if (this.drawnPoints.length === 2) {
                        this.createRectangle(this.drawnPoints[0], this.drawnPoints[1]);
                        this.finalizeShape();
                    }
                } else if (this.currentDrawingTool === 'triangle') {
                    if (this.drawnPoints.length === 1) {
                        UIManager.showStatus("Click again for second point of triangle.");
                    } else if (this.drawnPoints.length === 2) {
                        UIManager.showStatus("Click again for third point of triangle.");
                    } else if (this.drawnPoints.length === 3) {
                        this.createTriangle(this.drawnPoints[0], this.drawnPoints[1], this.drawnPoints[2]);
                        this.finalizeShape();
                    }
                }
            }

            updateDrawingLine(currentPoint) {
                if (this.drawingLine) {
                    this.sceneManager.scene.remove(this.drawingLine);
                    disposeObject(this.drawingLine);
                }

                if (this.drawnPoints.length > 0) {
                    const points = [...this.drawnPoints.map(p => p.clone())];
                    if (currentPoint) {
                        points.push(currentPoint);
                    }

                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    this.drawingLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffff00 })); // Yellow preview line
                    this.sceneManager.scene.add(this.drawingLine);
                }
            }

            updateCirclePreview(currentPoint) {
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                }
                const center = this.drawnPoints[0];
                const radius = center.distanceTo(currentPoint);
                const geometry = new THREE.CircleGeometry(radius, 32);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.drawingPreviewMesh = new THREE.Mesh(geometry, material);
                this.drawingPreviewMesh.position.copy(center);
                this.drawingPreviewMesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.sceneManager.scene.add(this.drawingPreviewMesh);
            }

            updateRectanglePreview(currentPoint) {
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                }
                const p1 = this.drawnPoints[0];
                const p2 = currentPoint;
                const width = Math.abs(p2.x - p1.x);
                const height = Math.abs(p2.z - p1.z); // Assuming drawing on XZ plane
                const centerX = (p1.x + p2.x) / 2;
                const centerZ = (p1.z + p2.z) / 2;
                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.drawingPreviewMesh = new THREE.Mesh(geometry, material);
                this.drawingPreviewMesh.position.set(centerX, p1.y, centerZ);
                this.drawingPreviewMesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.sceneManager.scene.add(this.drawingPreviewMesh);
            }

            updateTrianglePreview(currentPoint) {
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                }

                const p1 = this.drawnPoints[0];
                const p2 = currentPoint; // This will be the second point for the base

                // Create a temporary geometry for preview
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    p1.x, p1.y, p1.z,
                    p2.x, p2.y, p2.z,
                    p1.x, p1.y, p1.z // Just a line for now, until 3rd point
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.drawingPreviewMesh = new THREE.Line(geometry, material);
                this.sceneManager.scene.add(this.drawingPreviewMesh);
            }

            createLineSegment(p1, p2) {
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue line
                const points = [p1, p2];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                this.objectManager.addObject(line, 'Line');
            }

            createPolyline(points) {
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue polyline
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const polyline = new THREE.Line(geometry, material);
                this.objectManager.addObject(polyline, 'Polyline');
            }

            createCircle(center, radius) {
                const curve = new THREE.EllipseCurve(
                    center.x, center.z, // Center x, y (using Z for 2D plane)
                    radius, radius,     // xRadius, yRadius
                    0, 2 * Math.PI,     // startAngle, endAngle
                    false,              // clockwise
                    0                   // rotation
                );
                const points = curve.getPoints(50); // 50 segments
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const circle = new THREE.Line(geometry, material);
                circle.rotation.x = Math.PI / 2; // Orient correctly on XZ plane
                this.objectManager.addObject(circle, 'Circle');
            }

            createArc(p1, p2, p3) {
                // This is a simplified arc creation. For a true arc from 3 points,
                // more complex geometry calculations are needed.
                // For now, let's just draw lines between the three points.
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const points = [p1, p2, p3];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const arc = new THREE.Line(geometry, material);
                this.objectManager.addObject(arc, 'Arc (3 points)');
                UIManager.showStatus("Arc created from 3 points (simplified to lines).");
            }

            createRectangle(p1, p2) {
                // p1 and p2 are opposite corners
                const p3 = new THREE.Vector3(p1.x, p1.y, p2.z);
                const p4 = new THREE.Vector3(p2.x, p1.y, p1.z);

                const shape = new THREE.Shape();
                shape.moveTo(p1.x, p1.z);
                shape.lineTo(p4.x, p4.z);
                shape.lineTo(p2.x, p2.z);
                shape.lineTo(p3.x, p3.z);
                shape.lineTo(p1.x, p1.z); // Close the shape

                const geometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshPhongMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = p1.y; // Keep it on the drawing plane
                mesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.objectManager.addObject(mesh, 'Rectangle');
            }

            createTriangle(p1, p2, p3) {
                const shape = new THREE.Shape();
                shape.moveTo(p1.x, p1.z);
                shape.lineTo(p2.x, p2.z);
                shape.lineTo(p3.x, p3.z);
                shape.lineTo(p1.x, p1.z); // Close the shape

                const geometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshPhongMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = p1.y; // Keep it on the drawing plane
                mesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.objectManager.addObject(mesh, 'Triangle');
            }

            closePath() {
                if (this.currentDrawingTool === 'polyline' && this.drawnPoints.length >= 3) {
                    this.saveDrawingState(); // Save state before modifying
                    // Add the first point to close the loop
                    const closedPoints = [...this.drawnPoints, this.drawnPoints[0]];
                    this.createPolyline(closedPoints);
                    this.finalizeShape();
                    UIManager.showStatus("Polyline closed.");
                } else {
                    UIManager.showStatus("Cannot close path. Not a polyline or not enough points.", true);
                }
            }

            finalizeShape() {
                this.clearDrawing(false); // Clear preview, but don't save to undo as shape is finalized
                this.drawnPoints = []; // Reset points for next drawing
                this.uiManager.updateUI(); // Update UI to reflect reset
                // Show extrusion controls if a shape was just created that can be extruded
                if (this.objectManager.selectedObject && (this.objectManager.selectedObject.geometry instanceof THREE.ShapeGeometry)) {
                    this.uiManager.elements.extrusionControls.classList.remove('hidden');
                }
            }

            clearDrawing(saveState = true) {
                if (saveState) {
                    this.saveDrawingState();
                }
                if (this.drawingLine) {
                    this.sceneManager.scene.remove(this.drawingLine);
                    disposeObject(this.drawingLine);
                    this.drawingLine = null;
                }
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                    this.drawingPreviewMesh = null;
                }
                this.drawnPoints = [];
                this.uiManager.updateUI(); // Update drawn points count
                this.uiManager.elements.extrusionControls.classList.add('hidden'); // Hide extrusion controls
            }

            extrudeShape(depth) {
                if (!this.objectManager.selectedObject || !(this.objectManager.selectedObject.geometry instanceof THREE.ShapeGeometry)) {
                    UIManager.showModalMessage("Extrusion Error", "Please select a 2D shape (like a rectangle or triangle) to extrude.");
                    return;
                }

                this.saveDrawingState(); // Save state before modifying

                const shapeGeometry = this.objectManager.selectedObject.geometry;
                const shape = shapeGeometry.parameters.shapes[0]; // Get the original shape

                const extrudeSettings = {
                    steps: 1,
                    depth: depth / 100, // Convert cm to meters
                    bevelEnabled: false
                };

                const extrudedGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const material = this.objectManager.selectedObject.material.clone(); // Keep original material
                const extrudedMesh = new THREE.Mesh(extrudedGeometry, material);

                // Position the extruded mesh correctly
                extrudedMesh.position.copy(this.objectManager.selectedObject.position);
                extrudedMesh.rotation.copy(this.objectManager.selectedObject.rotation);

                // Remove the old 2D shape
                this.objectManager.removeObject(this.objectManager.selectedObject);

                // Add the new extruded 3D object
                this.objectManager.addObject(extrudedMesh, 'Extruded Shape');
                UIManager.showModalMessage("Extrusion Complete", `Shape extruded by ${depth} cm.`);

                this.uiManager.elements.extrusionControls.classList.add('hidden'); // Hide extrusion controls after use
            }

            saveDrawingState() {
                // Store a snapshot of the current drawing state (points, tool)
                const state = {
                    points: this.drawnPoints.map(p => p.toArray()), // Store as array for serialization
                    tool: this.currentDrawingTool,
                    drawingPlaneY: this.drawingPlaneMesh.position.y * 100, // Save in cm
                    objects: this.objectManager.objects.map(obj => ({
                        uuid: obj.uuid,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray(),
                        scale: obj.scale.toArray(),
                        // Add more properties if needed for full state restoration
                    }))
                };
                this.undoStack.push(state);
                this.redoStack = []; // Clear redo stack on new action
                console.log("Drawing state saved. Undo stack size:", this.undoStack.length);
            }

            undoDrawing() {
                if (this.undoStack.length > 1) { // Keep at least the initial empty state
                    const lastState = this.undoStack.pop();
                    this.redoStack.push(lastState); // Move to redo stack

                    const previousState = this.undoStack[this.undoStack.length - 1];
                    this.restoreDrawingState(previousState);
                    UIManager.showStatus("Undo successful.");
                } else {
                    UIManager.showStatus("Nothing to undo.", true);
                }
            }

            redoDrawing() {
                if (this.redoStack.length > 0) {
                    const nextState = this.redoStack.pop();
                    this.undoStack.push(nextState); // Move back to undo stack
                    this.restoreDrawingState(nextState);
                    UIManager.showStatus("Redo successful.");
                } else {
                    UIManager.showStatus("Nothing to redo.", true);
                }
            }

            restoreDrawingState(state) {
                // First, clear all current objects in the scene (except lights, camera, grid)
                // This is a simplified approach. A more robust undo would track object additions/removals.
                this.objectManager.clearObjects();

                // Recreate objects from the saved state
                state.objects.forEach(objData => {
                    // This part needs to be more sophisticated to recreate actual geometries/materials.
                    // For now, it's a placeholder. A real implementation would need to store
                    // geometry type, dimensions, material properties, etc.
                    // For simplicity, we'll just add a placeholder cube for each saved object.
                    const tempGeometry = new THREE.BoxGeometry(1, 1, 1);
                    const tempMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                    const tempMesh = new THREE.Mesh(tempGeometry, tempMaterial);
                    tempMesh.uuid = objData.uuid; // Restore UUID to match selection
                    tempMesh.position.fromArray(objData.position);
                    tempMesh.rotation.fromArray(objData.rotation);
                    tempMesh.scale.fromArray(objData.scale);
                    this.objectManager.addObject(tempMesh, 'Restored Object');
                });

                // Restore drawing points and tool
                this.drawnPoints = state.points.map(p => new THREE.Vector3().fromArray(p));
                this.currentDrawingTool = state.tool;
                this.setDrawingPlaneY(state.drawingPlaneY || 0); // Restore drawing plane Y position

                // Re-render drawing line/preview if applicable
                this.updateDrawingLine();
                if (this.currentDrawingTool === 'circle' && this.drawnPoints.length === 2) {
                    this.updateCirclePreview(this.drawnPoints[1]);
                } else if (this.currentDrawingTool === 'rectangle' && this.drawnPoints.length === 2) {
                    this.updateRectanglePreview(this.drawnPoints[1]);
                } else if (this.currentDrawingTool === 'triangle' && this.drawnPoints.length === 3) {
                    this.createTriangle(this.drawnPoints[0], this.drawnPoints[1], this.drawnPoints[2]);
                }

                this.uiManager.updateUI();
                this.objectManager.selectObject(null); // Deselect after undo/redo
                console.log("Drawing state restored. Undo stack size:", this.undoStack.length);
            }
        }

        // === ExportManager Class ===
        class ExportManager {
            constructor(sceneManager, objectManager, uiManager) {
                this.sceneManager = sceneManager;
                this.objectManager = objectManager;
                this.uiManager = uiManager; // Will be set after UIManager is initialized
            }

            generateThreeJsCode() {
                let code = `// Three.js Scene Export\n\n`;
                code += `const scene = new THREE.Scene();\n`;
                code += `const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n`;
                code += `const renderer = new THREE.WebGLRenderer({ antialias: true });\n`;
                code += `renderer.setSize(window.innerWidth, window.innerHeight);\n`;
                code += `document.body.appendChild(renderer.domElement);\n\n`;

                code += `// Lights\n`;
                code += `scene.add(new THREE.AmbientLight(0x404040));\n`;
                code += `const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n`;
                code += `directionalLight.position.set(1, 1, 1).normalize();\n`;
                code += `scene.add(directionalLight);\n\n`;

                code += `// Objects\n`;
                this.objectManager.objects.forEach(obj => {
                    const materialColor = obj.material.color ? `#${obj.material.color.getHexString()}` : '#cccccc';
                    const objName = obj.name || 'unnamedObject';

                    if (obj instanceof THREE.Mesh) {
                        // Handle different geometries
                        if (obj.geometry instanceof THREE.BoxGeometry) {
                            const { width, height, depth } = obj.geometry.parameters;
                            code += `const ${objName}Geometry = new THREE.BoxGeometry(${width}, ${height}, ${depth});\n`;
                        } else if (obj.geometry instanceof THREE.SphereGeometry) {
                            const { radius } = obj.geometry.parameters;
                            code += `const ${objName}Geometry = new THREE.SphereGeometry(${radius}, 32, 32);\n`;
                        } else if (obj.geometry instanceof THREE.CylinderGeometry) {
                            const { radiusTop, radiusBottom, height } = obj.geometry.parameters;
                            code += `const ${objName}Geometry = new THREE.CylinderGeometry(${radiusTop}, ${radiusBottom}, ${height}, 32);\n`;
                        } else if (obj.geometry instanceof THREE.ShapeGeometry) {
                            // For extruded shapes, we need to reconstruct the shape
                            // This is complex, so for now, we'll just note it or simplify
                            code += `// Note: Complex shape geometry for ${objName} is simplified in export.\n`;
                            code += `const ${objName}Geometry = new THREE.BoxGeometry(1, 1, 1); // Placeholder\n`;
                        } else {
                            code += `// Note: Unknown geometry type for ${objName} is simplified in export.\n`;
                            code += `const ${objName}Geometry = new THREE.BoxGeometry(1, 1, 1); // Placeholder\n`;
                        }

                        code += `const ${objName}Material = new THREE.MeshPhongMaterial({ color: 0x${materialColor.substring(1)} });\n`;
                        code += `const ${objName} = new THREE.Mesh(${objName}Geometry, ${objName}Material);\n`;
                        code += `${objName}.position.set(${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)});\n`;
                        code += `${objName}.rotation.set(${obj.rotation.x.toFixed(2)}, ${obj.rotation.y.toFixed(2)}, ${obj.rotation.z.toFixed(2)});\n`;
                        code += `scene.add(${objName});\n\n`;
                    } else if (obj instanceof THREE.Line) {
                        // Export line geometry (points)
                        const positions = obj.geometry.attributes.position.array;
                        const pointsArray = [];
                        for (let i = 0; i < positions.length; i += 3) {
                            pointsArray.push(`new THREE.Vector3(${positions[i].toFixed(2)}, ${positions[i+1].toFixed(2)}, ${positions[i+2].toFixed(2)})`);
                        }
                        code += `const ${objName}Points = [${pointsArray.join(', ')}];\n`;
                        code += `const ${objName}Geometry = new THREE.BufferGeometry().setFromPoints(${objName}Points);\n`;
                        code += `const ${objName}Material = new THREE.LineBasicMaterial({ color: 0x${materialColor.substring(1)} });\n`;
                        code += `const ${objName} = new THREE.Line(${objName}Geometry, ${objName}Material);\n`;
                        code += `scene.add(${objName});\n\n`;
                    }
                    // Add other object types if needed (e.g., Groups, Sprites)
                });

                code += `// Camera position\n`;
                code += `camera.position.set(${this.sceneManager.activeCamera.position.x.toFixed(2)}, ${this.sceneManager.activeCamera.position.y.toFixed(2)}, ${this.sceneManager.activeCamera.position.z.toFixed(2)});\n`;
                code += `camera.lookAt(scene.position);\n\n`;

                code += `// Animation loop\n`;
                code += `function animate() {\n`;
                code += `    requestAnimationFrame(animate);\n`;
                code += `    renderer.render(scene, camera);\n`;
                code += `}\n`;
                code += `animate();\n`;

                this.uiManager.elements.generatedCodePre.textContent = code;
                UIManager.showStatus("Three.js code generated!");
            }

            copyGeneratedCode() {
                const code = this.uiManager.elements.generatedCodePre.textContent;
                if (code) {
                    // Use execCommand for broader compatibility in iframes
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        UIManager.showStatus("Code copied to clipboard!");
                    } catch (err) {
                        console.error('Failed to copy code:', err);
                        UIManager.showStatus("Failed to copy code.", true);
                    }
                    document.body.removeChild(textArea);
                } else {
                    UIManager.showStatus("No code to copy.", true);
                }
            }

            exportDXF() {
                const objects = this.objectManager.objects;
                if (objects.length === 0) {
                    UIManager.showModalMessage("Export DXF", "No objects in the scene to export to DXF.");
                    return;
                }

                let dxfContent = `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n`;
                dxfContent += `0\nSECTION\n2\nTABLES\n0\nTABLE\n2\nLAYER\n70\n1\n`;
                dxfContent += `0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n`; // Default layer 0
                dxfContent += `0\nENDTAB\n0\nENDSEC\n`;
                dxfContent += `0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n`;
                dxfContent += `0\nSECTION\n2\nENTITIES\n`;

                // Conversion factor from Three.js units (meters) to DXF units (mm)
                const scaleFactor = 1000; // 1 Three.js unit = 1000 mm = 1 meter

                objects.forEach(obj => {
                    // Start of an entity
                    dxfContent += `0\nLWPOLYLINE\n`; // Use LWPOLYLINE for 2D polylines
                    dxfContent += `5\n${obj.uuid.substring(0, 8).toUpperCase()}\n`; // Handle
                    dxfContent += `100\nAcDbEntity\n`;
                    dxfContent += `8\n0\n`; // Layer name (0 for default)
                    dxfContent += `100\nAcDbPolyline\n`;
                    dxfContent += `90\n${obj.geometry.attributes.position.count}\n`; // Number of vertices
                    dxfContent += `70\n0\n`; // Polyline flag (0 = default)

                    const positions = obj.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i] * scaleFactor + obj.position.x * scaleFactor;
                        const y = positions[i+1] * scaleFactor + obj.position.y * scaleFactor;
                        const z = positions[i+2] * scaleFactor + obj.position.z * scaleFactor; // DXF is 2D, but Z can be stored

                        dxfContent += `10\n${x.toFixed(3)}\n`; // X coordinate
                        dxfContent += `20\n${y.toFixed(3)}\n`; // Y coordinate
                        dxfContent += `30\n${z.toFixed(3)}\n`; // Z coordinate
                    }
                });

                dxfContent += `0\nENDSEC\n0\nEOF\n`;

                const blob = new Blob([dxfContent], { type: 'application/dxf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'scene_export.dxf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                UIManager.showStatus("DXF file exported!");
            }

            async handleExport() {
                // Dynamically import jsPDF
                UIManager.showStatus("Loading PDF library...");
                this.uiManager.elements.exportPDFBtn.querySelector('.btn-spinner').hidden = false;

                try {
                    // Check if jsPDF is already loaded
                    if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                        await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
                        console.log('jsPDF loaded dynamically.');
                    } else {
                        console.log('jsPDF already loaded.');
                    }

                    // Check if html2canvas is already loaded
                    if (typeof window.html2canvas === 'undefined') {
                        await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
                        console.log('html2canvas loaded dynamically.');
                    } else {
                        console.log('html2canvas already loaded.');
                    }

                    // Ensure the jsPDF object is correctly referenced
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    UIManager.showStatus("Generating PDF...");

                    // Temporarily hide controls to get a clean canvas screenshot
                    const controlPanel = document.querySelector('.control-panel');
                    const toolbar = document.querySelector('.toolbar');
                    const codeSection = document.querySelector('section.glass-panel');
                    if (controlPanel) controlPanel.style.display = 'none';
                    if (toolbar) toolbar.style.display = 'none';
                    if (codeSection) codeSection.style.display = 'none';


                    // Get the canvas element
                    const canvas = this.sceneManager.renderer.domElement;

                    // Use html2canvas to capture the canvas content
                    const canvasImage = await html2canvas(canvas, {
                        backgroundColor: null, // Transparent background
                        useCORS: true, // Important for images loaded from other origins
                    });

                    // Re-show controls
                    if (controlPanel) controlPanel.style.display = 'block';
                    if (toolbar) toolbar.style.display = 'flex';
                    if (codeSection) codeSection.style.display = 'block';

                    const imgData = canvasImage.toDataURL('image/png');
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = (canvasImage.height * imgWidth) / canvasImage.width;
                    let heightLeft = imgHeight;
                    let position = 0;

                    doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        doc.addPage();
                        doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    doc.save('3d_model_snapshot.pdf');
                    UIManager.showStatus("PDF exported successfully!");

                } catch (error) {
                    console.error("Error exporting PDF:", error);
                    UIManager.showModalMessage("PDF Export Error", `Failed to export PDF: ${error.message}. Please check console for details.`);
                    UIManager.showStatus("PDF export failed.", true);
                } finally {
                    this.uiManager.elements.exportPDFBtn.querySelector('.btn-spinner').hidden = true;
                }
            }

            loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }
        }

        // === UIManager Class ===
        class UIManager {
            constructor(sceneManager, objectManager, drawingManager, exportManager) {
                this.sceneManager = sceneManager;
                this.objectManager = objectManager;
                this.drawingManager = drawingManager;
                this.exportManager = exportManager;

                this.elements = {}; // Store references to DOM elements
                this.initDOMElements();
                this.addEventListeners();
                this.updateUI(); // Initial UI update
            }

            initDOMElements() {
                this.elements.canvasContainer = document.getElementById('canvas-container');
                console.log('Element canvas-container:', this.elements.canvasContainer ? 'found' : 'NOT found');
                this.elements.viewModeBtn = document.getElementById('viewModeBtn');
                console.log('Element viewModeBtn:', this.elements.viewModeBtn ? 'found' : 'NOT found');
                this.elements.drawModeBtn = document.getElementById('drawModeBtn');
                console.log('Element drawModeBtn:', this.elements.drawModeBtn ? 'found' : 'NOT found');
                this.elements.viewControlsPanel = document.getElementById('viewControlsPanel');
                console.log('Element viewControlsPanel:', this.elements.viewControlsPanel ? 'found' : 'NOT found');
                this.elements.drawingControls = document.getElementById('drawingControls');
                console.log('Element drawingControls:', this.elements.drawingControls ? 'found' : 'NOT found');
                this.elements.basic3DShapeControls = document.getElementById('basic3DShapeControls');
                console.log('Element basic3DShapeControls:', this.elements.basic3DShapeControls ? 'found' : 'NOT found');
                this.elements.drawnPointsCount = document.getElementById('drawnPointsCount');
                console.log('Element drawnPointsCount:', this.elements.drawnPointsCount ? 'found' : 'NOT found');
                this.elements.closePathBtn = document.getElementById('closePathBtn');
                console.log('Element closePathBtn:', this.elements.closePathBtn ? 'found' : 'NOT found');
                this.elements.undoDrawingBtn = document.getElementById('undoDrawingBtn');
                console.log('Element undoDrawingBtn:', this.elements.undoDrawingBtn ? 'found' : 'NOT found');
                this.elements.extrusionControls = document.getElementById('extrusionControls');
                console.log('Element extrusionControls:', this.elements.extrusionControls ? 'found' : 'NOT found');
                this.elements.extrusionDepthInput = document.getElementById('extrusionDepth');
                console.log('Element extrusionDepthInput:', this.elements.extrusionDepthInput ? 'found' : 'NOT found');
                this.elements.extrudeBtn = document.getElementById('extrudeBtn');
                console.log('Element extrudeBtn:', this.elements.extrudeBtn ? 'found' : 'NOT found');
                this.elements.selectedObjectSelect = document.getElementById('selectedObject');
                console.log('Element selectedObjectSelect:', this.elements.selectedObjectSelect ? 'found' : 'NOT found');
                this.elements.removeObjectBtn = document.getElementById('removeObjectBtn');
                console.log('Element removeObjectBtn:', this.elements.removeObjectBtn ? 'found' : 'NOT found');
                this.elements.objectPropertiesPanel = document.getElementById('objectProperties');
                console.log('Element objectPropertiesPanel:', this.elements.objectPropertiesPanel ? 'found' : 'NOT found');
                this.elements.objectColorInput = document.getElementById('objectColor');
                console.log('Element objectColorInput:', this.elements.objectColorInput ? 'found' : 'NOT found');
                this.elements.posXInput = document.getElementById('posX');
                console.log('Element posXInput:', this.elements.posXInput ? 'found' : 'NOT found');
                this.elements.posYInput = document.getElementById('posY');
                console.log('Element posYInput:', this.elements.posYInput ? 'found' : 'NOT found');
                this.elements.posZInput = document.getElementById('posZ');
                console.log('Element posZInput:', this.elements.posZInput ? 'found' : 'NOT found');
                this.elements.rotXInput = document.getElementById('rotX');
                console.log('Element rotXInput:', this.elements.rotXInput ? 'found' : 'NOT found');
                this.elements.rotYInput = document.getElementById('rotY');
                console.log('Element rotYInput:', this.elements.rotYInput ? 'found' : 'NOT found');
                this.elements.rotZInput = document.getElementById('rotZ');
                console.log('Element rotZInput:', this.elements.rotZInput ? 'found' : 'NOT found');
                this.elements.resetSceneBtnSide = document.getElementById('resetSceneBtnSide');
                console.log('Element resetSceneBtnSide:', this.elements.resetSceneBtnSide ? 'found' : 'NOT found');
                this.elements.generateCodeBtn = document.getElementById('generateCodeBtn');
                console.log('Element generateCodeBtn:', this.elements.generateCodeBtn ? 'found' : 'NOT found');
                this.elements.printBtn = document.getElementById('printBtn');
                console.log('Element printBtn:', this.elements.printBtn ? 'found' : 'NOT found');
                this.elements.copyCodeBtn = document.getElementById('copyCodeBtn');
                console.log('Element copyCodeBtn:', this.elements.copyCodeBtn ? 'found' : 'NOT found');
                this.elements.exportDXFBtn = document.getElementById('exportDXFBtn');
                console.log('Element exportDXFBtn:', this.elements.exportDXFBtn ? 'found' : 'NOT found');
                this.elements.exportPDFBtn = document.getElementById('exportPDFBtn');
                console.log('Element exportPDFBtn:', this.elements.exportPDFBtn ? 'found' : 'NOT found');
                this.elements.generatedCodePre = document.getElementById('generatedCode');
                console.log('Element generatedCodePre:', this.elements.generatedCodePre ? 'found' : 'NOT found');
                this.elements.exportStatusDiv = document.getElementById('export-status');
                console.log('Element exportStatusDiv:', this.elements.exportStatusDiv ? 'found' : 'NOT found');

                // Toolbar buttons
                this.elements.setupBaseBtn = document.getElementById('setupBaseBtn');
                console.log('Element setupBaseBtn:', this.elements.setupBaseBtn ? 'found' : 'NOT found');
                this.elements.materialsBtn = document.getElementById('materialsBtn');
                console.log('Element materialsBtn:', this.elements.materialsBtn ? 'found' : 'NOT found');
                this.elements.paintBucketBtn = document.getElementById('paintBucketBtn');
                console.log('Element paintBucketBtn:', this.elements.paintBucketBtn ? 'found' : 'NOT found');
                this.elements.lightsBtn = document.getElementById('lightsBtn');
                console.log('Element lightsBtn:', this.elements.lightsBtn ? 'found' : 'NOT found');
                this.elements.importBtn = document.getElementById('importBtn');
                console.log('Element importBtn:', this.elements.importBtn ? 'found' : 'NOT found');
                this.elements.objInputHidden = document.getElementById('objInputHidden');
                console.log('Element objInputHidden:', this.elements.objInputHidden ? 'found' : 'NOT found');
                this.elements.mtlInputHidden = document.getElementById('mtlInputHidden');
                console.log('Element mtlInputHidden:', this.elements.mtlInputHidden ? 'found' : 'NOT found');
                this.elements.textureInputHidden = document.getElementById('textureInputHidden');
                console.log('Element textureInputHidden:', this.elements.textureInputHidden ? 'found' : 'NOT found');
                this.elements.controlsBtn = document.getElementById('controlsBtn');
                console.log('Element controlsBtn:', this.elements.controlsBtn ? 'found' : 'NOT found');
                this.elements.performanceBtn = document.getElementById('performanceBtn');
                console.log('Element performanceBtn:', this.elements.performanceBtn ? 'found' : 'NOT found');
                this.elements.infoBtn = document.getElementById('infoBtn');
                console.log('Element infoBtn:', this.elements.infoBtn ? 'found' : 'NOT found');
                this.elements.geometriesDropdownBtn = document.getElementById('geometriesDropdownBtn');
                console.log('Element geometriesDropdownBtn:', this.elements.geometriesDropdownBtn ? 'found' : 'NOT found');
                this.elements.templatesDropdownBtn = document.getElementById('templatesDropdownBtn');
                console.log('Element templatesDropdownBtn:', this.elements.templatesDropdownBtn ? 'found' : 'NOT found');

                // Toolbar Geometries Dropdown
                this.elements.lineToolBtnToolbar = document.getElementById('lineToolBtnToolbar');
                console.log('Element lineToolBtnToolbar:', this.elements.lineToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.polylineToolBtnToolbar = document.getElementById('polylineToolBtnToolbar');
                console.log('Element polylineToolBtnToolbar:', this.elements.polylineToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.circleToolBtnToolbar = document.getElementById('circleToolBtnToolbar');
                console.log('Element circleToolBtnToolbar:', this.elements.circleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.arcToolBtnToolbar = document.getElementById('arcToolBtnToolbar');
                console.log('Element arcToolBtnToolbar:', this.elements.arcToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.triangleToolBtnToolbar = document.getElementById('triangleToolBtnToolbar');
                console.log('Element triangleToolBtnToolbar:', this.elements.triangleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.rectangleToolBtnToolbar = document.getElementById('rectangleToolBtnToolbar');
                console.log('Element rectangleToolBtnToolbar:', this.elements.rectangleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.addCubeBtnToolbar = document.getElementById('addCubeBtnToolbar');
                console.log('Element addCubeBtnToolbar:', this.elements.addCubeBtnToolbar ? 'found' : 'NOT found');
                this.elements.addSphereBtnToolbar = document.getElementById('addSphereBtnToolbar');
                console.log('Element addSphereBtnToolbar:', this.elements.addSphereBtnToolbar ? 'found' : 'NOT found');
                this.elements.addCylinderBtnToolbar = document.getElementById('addCylinderBtnToolbar');
                console.log('Element addCylinderBtnToolbar:', this.elements.addCylinderBtnToolbar ? 'found' : 'NOT found');

                // Toolbar Templates Dropdown
                this.elements.applyWoodMaterialBtn = document.getElementById('applyWoodMaterialBtn');
                console.log('Element applyWoodMaterialBtn:', this.elements.applyWoodMaterialBtn ? 'found' : 'NOT found');
                this.elements.applyMarbleMaterialBtn = document.getElementById('applyMarbleMaterialBtn');
                console.log('Element applyMarbleMaterialBtn:', this.elements.applyMarbleMaterialBtn ? 'found' : 'NOT found');
                this.elements.applyMetalMaterialBtn = document.getElementById('applyMetalMaterialBtn');
                console.log('Element applyMetalMaterialBtn:', this.elements.applyMetalMaterialBtn ? 'found' : 'NOT found');
                this.elements.addChairBtnToolbar = document.getElementById('addChairBtnToolbar');
                console.log('Element addChairBtnToolbar:', this.elements.addChairBtnToolbar ? 'found' : 'NOT found');
                this.elements.addTableBtnToolbar = document.getElementById('addTableBtnToolbar');
                console.log('Element addTableBtnToolbar:', this.elements.addTableBtnToolbar ? 'found' : 'NOT found');
                this.elements.addEmptyRoomBtnToolbar = document.getElementById('addEmptyRoomBtnToolbar');
                console.log('Element addEmptyRoomBtnToolbar:', this.elements.addEmptyRoomBtnToolbar ? 'found' : 'NOT found');

                this.elements.showGridBtn = document.getElementById('showGridBtn');
                console.log('Element showGridBtn:', this.elements.showGridBtn ? 'found' : 'NOT found');
                this.elements.hideGridBtn = document.getElementById('hideGridBtn');
                console.log('Element hideGridBtn:', this.elements.hideGridBtn ? 'found' : 'NOT found');

                this.elements.lineDrawingOptions = document.getElementById('lineDrawingOptions');
                console.log('Element lineDrawingOptions:', this.elements.lineDrawingOptions ? 'found' : 'NOT found');
                this.elements.circleDrawingOptions = document.getElementById('circleDrawingOptions');
                console.log('Element circleDrawingOptions:', this.elements.circleDrawingOptions ? 'found' : 'NOT found');
                this.elements.arcDrawingOptions = document.getElementById('arcDrawingOptions');
                console.log('Element arcDrawingOptions:', this.elements.arcDrawingOptions ? 'found' : 'NOT found');
                this.elements.rectangleDrawingOptions = document.getElementById('rectangleDrawingOptions');
                console.log('Element rectangleDrawingOptions:', this.elements.rectangleDrawingOptions ? 'found' : 'NOT found');
                this.elements.triangleDrawingOptions = document.getElementById('triangleDrawingOptions');
                console.log('Element triangleDrawingOptions:', this.elements.triangleDrawingOptions ? 'found' : 'NOT found');

                this.elements.lineLengthInput = document.getElementById('lineLengthInput');
                console.log('Element lineLengthInput:', this.elements.lineLengthInput ? 'found' : 'NOT found');
                this.elements.circleRadiusInput = document.getElementById('circleRadiusInput');
                console.log('Element circleRadiusInput:', this.elements.circleRadiusInput ? 'found' : 'NOT found');
                this.elements.arcRadiusInput = document.getElementById('arcRadiusInput');
                console.log('Element arcRadiusInput:', this.elements.arcRadiusInput ? 'found' : 'NOT found');
                this.elements.arcStartAngleInput = document.getElementById('arcStartAngleInput');
                console.log('Element arcStartAngleInput:', this.elements.arcStartAngleInput ? 'found' : 'NOT found');
                this.elements.arcEndAngleInput = document.getElementById('arcEndAngleInput');
                console.log('Element arcEndAngleInput:', this.elements.arcEndAngleInput ? 'found' : 'NOT found');
                this.elements.arcClockwiseInput = document.getElementById('arcClockwiseInput');
                console.log('Element arcClockwiseInput:', this.elements.arcClockwiseInput ? 'found' : 'NOT found');
                this.elements.rectWidthInput = document.getElementById('rectWidthInput');
                console.log('Element rectWidthInput:', this.elements.rectWidthInput ? 'found' : 'NOT found');
                this.elements.rectHeightInput = document.getElementById('rectHeightInput');
                console.log('Element rectHeightInput:', this.elements.rectHeightInput ? 'found' : 'NOT found');
                this.elements.triBaseInput = document.getElementById('triBaseInput');
                console.log('Element triBaseInput:', this.elements.triBaseInput ? 'found' : 'NOT found');
                this.elements.triHeightInput = document.getElementById('triHeightInput');
                console.log('Element triHeightInput:', this.elements.triHeightInput ? 'found' : 'NOT found');

                this.elements.cubeOptions = document.getElementById('cubeOptions');
                console.log('Element cubeOptions:', this.elements.cubeOptions ? 'found' : 'NOT found');
                this.elements.sphereOptions = document.getElementById('sphereOptions');
                console.log('Element sphereOptions:', this.elements.sphereOptions ? 'found' : 'NOT found');
                this.elements.cylinderOptions = document.getElementById('cylinderOptions');
                console.log('Element cylinderOptions:', this.elements.cylinderOptions ? 'found' : 'NOT found');
                this.elements.addBasicShapeBtn = document.getElementById('addBasicShapeBtn');
                console.log('Element addBasicShapeBtn:', this.elements.addBasicShapeBtn ? 'found' : 'NOT found');

                // New camera type buttons
                this.elements.perspectiveViewBtn = document.getElementById('perspectiveViewBtn');
                console.log('Element perspectiveViewBtn:', this.elements.perspectiveViewBtn ? 'found' : 'NOT found');
                this.elements.orthographicViewBtn = document.getElementById('orthographicViewBtn');
                console.log('Element orthographicViewBtn:', this.elements.orthographicViewBtn ? 'found' : 'NOT found');

                // New drawing plane Y input
                this.elements.drawingPlaneYInput = document.getElementById('drawingPlaneYInput');
                console.log('Element drawingPlaneYInput:', this.elements.drawingPlaneYInput ? 'found' : 'NOT found');

                // New snap to grid elements
                this.elements.snapGridOnBtn = document.getElementById('snapGridOnBtn');
                console.log('Element snapGridOnBtn:', this.elements.snapGridOnBtn ? 'found' : 'NOT found');
                this.elements.snapGridOffBtn = document.getElementById('snapGridOffBtn');
                console.log('Element snapGridOffBtn:', this.elements.snapGridOffBtn ? 'found' : 'NOT found');
                this.elements.gridSnapResolutionInput = document.getElementById('gridSnapResolutionInput');
                console.log('Element gridSnapResolutionInput:', this.elements.gridSnapResolutionInput ? 'found' : 'NOT found');
            }

            addEventListeners() {
                // Mode buttons
                if (this.elements.viewModeBtn) {
                    this.elements.viewModeBtn.addEventListener('click', () => {
                        console.log('View Mode button clicked.');
                        this.drawingManager.setDrawingMode(false);
                        this.objectManager.paintBucketMode = false; // Directly set property
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                    });
                } else {
                    console.error("UIManager: viewModeBtn not found, cannot attach event listener.");
                }
                if (this.elements.drawModeBtn) {
                    this.elements.drawModeBtn.addEventListener('click', () => {
                        console.log('Draw Mode button clicked.');
                        this.drawingManager.setDrawingMode(true);
                        this.objectManager.paintBucketMode = false; // Directly set property
                        this.objectManager.selectObject(null); // Deselect any object in drawing mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                        this.drawingManager.clearDrawing(true); // Clear and save initial state for undo
                    });
                } else {
                    console.error("UIManager: drawModeBtn not found, cannot attach event listener.");
                }

                // Drawing Plane Y-position input
                if (this.elements.drawingPlaneYInput) {
                    this.elements.drawingPlaneYInput.addEventListener('input', () => {
                        const yValue = parseFloat(this.elements.drawingPlaneYInput.value);
                        if (!isNaN(yValue)) {
                            this.drawingManager.setDrawingPlaneY(yValue);
                        }
                    });
                }

                // Snap to Grid buttons
                if (this.elements.snapGridOnBtn) {
                    this.elements.snapGridOnBtn.addEventListener('click', () => {
                        this.drawingManager.setSnapToGrid(true);
                        this.updateUI();
                    });
                }
                if (this.elements.snapGridOffBtn) {
                    this.elements.snapGridOffBtn.addEventListener('click', () => {
                        this.drawingManager.setSnapToGrid(false);
                        this.updateUI();
                    });
                }

                // Grid Snap Resolution input
                if (this.elements.gridSnapResolutionInput) {
                    this.elements.gridSnapResolutionInput.addEventListener('input', () => {
                        const resolution = parseFloat(this.elements.gridSnapResolutionInput.value);
                        if (!isNaN(resolution) && resolution > 0) {
                            this.drawingManager.setGridSnapResolution(resolution);
                        }
                    });
                }

                // View preset buttons
                if (this.elements.viewTopBtn) this.elements.viewTopBtn.addEventListener('click', () => this.sceneManager.setPresetView('top'));
                if (this.elements.viewFrontBtn) this.elements.viewFrontBtn.addEventListener('click', () => this.sceneManager.setPresetView('front'));
                if (this.elements.viewRightBtn) this.elements.viewRightBtn.addEventListener('click', () => this.sceneManager.setPresetView('right'));
                if (this.elements.viewIsoBtn) this.elements.viewIsoBtn.addEventListener('click', () => this.sceneManager.setPresetView('iso'));

                // Camera type buttons
                if (this.elements.perspectiveViewBtn) {
                    this.elements.perspectiveViewBtn.addEventListener('click', () => {
                        this.sceneManager.setCameraType('perspective');
                        this.updateUI();
                    });
                }
                if (this.elements.orthographicViewBtn) {
                    this.elements.orthographicViewBtn.addEventListener('click', () => {
                        this.sceneManager.setCameraType('orthographic');
                        this.updateUI();
                    });
                }

                // Solid/Wireframe view buttons
                if (this.elements.solidViewBtn) {
                    this.elements.solidViewBtn.addEventListener('click', () => {
                        this.sceneManager.setWireframeMode(false);
                        this.updateUI();
                    });
                }
                if (this.elements.wireframeViewBtn) {
                    this.elements.wireframeViewBtn.addEventListener('click', () => {
                        this.sceneManager.setWireframeMode(true);
                        this.updateUI();
                    });
                }

                // Grid visibility buttons
                if (this.elements.showGridBtn) {
                    this.elements.showGridBtn.addEventListener('click', () => {
                        this.sceneManager.setGridVisibility(true);
                        this.updateUI();
                    });
                }
                if (this.elements.hideGridBtn) {
                    this.elements.hideGridBtn.addEventListener('click', () => {
                        this.sceneManager.setGridVisibility(false);
                        this.updateUI();
                    });
                }

                // Toolbar buttons
                if (this.elements.setupBaseBtn) this.elements.setupBaseBtn.addEventListener('click', () => this.sceneManager.resetScene());
                if (this.elements.materialsBtn) {
                    this.elements.materialsBtn.addEventListener('click', () => {
                        this.objectManager.paintBucketMode = false; // Directly set property
                        this.drawingManager.setDrawingMode(false); // Exit drawing mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                        if (this.objectManager.selectedObject) {
                            this.objectManager.selectObject(this.objectManager.selectedObject); // Re-select to update panel
                            this.elements.objectPropertiesPanel.classList.remove('hidden');
                        } else {
                            UIManager.showModalMessage("Materials", "Select an object to modify its material.");
                        }
                    });
                }
                if (this.elements.paintBucketBtn) {
                    this.elements.paintBucketBtn.addEventListener('click', () => {
                        this.objectManager.togglePaintBucketMode();
                        this.drawingManager.setDrawingMode(false);
                        this.objectManager.selectObject(null);
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                        UIManager.showModalMessage("Paint Bucket Mode", this.objectManager.paintBucketMode ? "Modalit√† 'Secchiello di vernice' attivata. Clicca su un oggetto per colorarlo." : "Modalit√† 'Secchiello di vernice' disattivata.");
                    });
                }
                if (this.elements.lightsBtn) this.elements.lightsBtn.addEventListener('click', () => UIManager.showModalMessage("Funzionalit√† Non Disponibile", "La gestione delle luci non √® ancora implementata."));
                if (this.elements.importBtn) this.elements.importBtn.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                    this.updateUI();
                    this.objectManager.startImportSequence();
                });
                if (this.elements.objInputHidden) this.elements.objInputHidden.addEventListener('change', (e) => this.objectManager.handleObjFileSelection(e.target.files[0]));
                if (this.elements.mtlInputHidden) this.elements.mtlInputHidden.addEventListener('change', (e) => this.objectManager.handleMtlFileSelection(e.target.files[0]));
                if (this.elements.textureInputHidden) this.elements.textureInputHidden.addEventListener('change', (e) => this.objectManager.handleTextureFileSelection(Array.from(e.target.files)));
                if (this.elements.controlsBtn) this.elements.controlsBtn.addEventListener('click', () => UIManager.showModalMessage("Funzionalit√† Non Disponibile", "Controlli avanzati non ancora implementati. Usa il mouse per orbitare."));
                if (this.elements.performanceBtn) this.elements.performanceBtn.addEventListener('click', () => UIManager.showModalMessage("Funzionalit√† Non Disponibile", "Opzioni di ottimizzazione delle prestazioni non ancora implementate."));
                if (this.elements.infoBtn) this.elements.infoBtn.addEventListener('click', () => this.showInfoModal());

                // Geometries Dropdown
                if (this.elements.lineToolBtnToolbar) {
                    this.elements.lineToolBtnToolbar.addEventListener('click', () => {
                        console.log('Line Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('line');
                    });
                }
                if (this.elements.polylineToolBtnToolbar) {
                    this.elements.polylineToolBtnToolbar.addEventListener('click', () => {
                        console.log('Polyline Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('polyline');
                    });
                }
                if (this.elements.circleToolBtnToolbar) {
                    this.elements.circleToolBtnToolbar.addEventListener('click', () => {
                        console.log('Circle Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('circle');
                    });
                }
                if (this.elements.arcToolBtnToolbar) {
                    this.elements.arcToolBtnToolbar.addEventListener('click', () => {
                        console.log('Arc Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('arc');
                    });
                }
                if (this.elements.triangleToolBtnToolbar) {
                    this.elements.triangleToolBtnToolbar.addEventListener('click', () => {
                        console.log('Triangle Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('triangle');
                    });
                }
                if (this.elements.rectangleToolBtnToolbar) {
                    this.elements.rectangleToolBtnToolbar.addEventListener('click', () => {
                        console.log('Rectangle Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('rectangle');
                    });
                }
                if (this.elements.addCubeBtnToolbar) this.elements.addCubeBtnToolbar.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('cube'); // Set basic 3D shape tool
                    this.objectManager.addBasic3DShape('cube');
                });
                if (this.elements.addSphereBtnToolbar) this.elements.addSphereBtnToolbar.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('sphere'); // Set basic 3D shape tool
                    this.objectManager.addBasic3DShape('sphere');
                });
                if (this.elements.addCylinderBtnToolbar) this.elements.addCylinderBtnToolbar.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('cylinder'); // Set basic 3D shape tool
                    this.objectManager.addBasic3DShape('cylinder');
                });

                // Templates Dropdown
                if (this.elements.applyWoodMaterialBtn) this.elements.applyWoodMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.woodMaterial, 'Legno'));
                if (this.elements.applyMarbleMaterialBtn) this.elements.applyMarbleMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.marbleMaterial, 'Marmo'));
                if (this.elements.applyMetalMaterialBtn) this.elements.applyMetalMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.metalMaterial, 'Metallo'));
                if (this.elements.addChairBtnToolbar) this.elements.addChairBtnToolbar.addEventListener('click', () => this.objectManager.addChair());
                if (this.elements.addTableBtnToolbar) this.elements.addTableBtnToolbar.addEventListener('click', () => this.objectManager.addTable());
                if (this.elements.addEmptyRoomBtnToolbar) this.elements.addEmptyRoomBtnToolbar.addEventListener('click', () => this.objectManager.addEmptyRoom());

                // Drawing and Extrusion controls
                if (this.elements.closePathBtn) this.elements.closePathBtn.addEventListener('click', () => this.drawingManager.closePath());
                if (this.elements.undoDrawingBtn) this.elements.undoDrawingBtn.addEventListener('click', () => this.drawingManager.undoDrawing());
                if (this.elements.extrudeBtn) this.elements.extrudeBtn.addEventListener('click', () => this.drawingManager.extrudeShape(parseFloat(this.elements.extrusionDepthInput.value)));

                // Object management controls
                if (this.elements.removeObjectBtn) this.elements.removeObjectBtn.addEventListener('click', () => this.objectManager.removeSelectedObject());
                if (this.elements.resetSceneBtnSide) this.elements.resetSceneBtnSide.addEventListener('click', () => this.sceneManager.resetScene());
                if (this.elements.generateCodeBtn) this.elements.generateCodeBtn.addEventListener('click', () => this.exportManager.generateThreeJsCode());
                if (this.elements.copyCodeBtn) this.elements.copyCodeBtn.addEventListener('click', () => this.exportManager.copyGeneratedCode());
                if (this.elements.printBtn) this.elements.printBtn.addEventListener('click', () => window.print());
                if (this.elements.exportDXFBtn) this.elements.exportDXFBtn.addEventListener('click', () => this.exportManager.exportDXF());
                if (this.elements.exportPDFBtn) this.elements.exportPDFBtn.addEventListener('click', () => this.exportManager.handleExport());

                // Object properties controls
                if (this.elements.objectColorInput) this.elements.objectColorInput.addEventListener('input', () => this.objectManager.updateSelectedObjectColor(this.elements.objectColorInput.value));
                if (this.elements.posXInput) this.elements.posXInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('x', parseFloat(this.elements.posXInput.value)));
                if (this.elements.posYInput) this.elements.posYInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('y', parseFloat(this.elements.posYInput.value)));
                if (this.elements.posZInput) this.elements.posZInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('z', parseFloat(this.elements.posZInput.value)));
                if (this.elements.rotXInput) this.elements.rotXInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('x', parseFloat(this.elements.rotXInput.value)));
                if (this.elements.rotYInput) this.elements.rotYInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('y', parseFloat(this.elements.rotYInput.value)));
                if (this.elements.rotZInput) this.elements.rotZInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('z', parseFloat(this.elements.rotZInput.value)));

                // Object selection dropdown
                if (this.elements.selectedObjectSelect) {
                    this.elements.selectedObjectSelect.addEventListener('change', () => {
                        const uuid = this.elements.selectedObjectSelect.value;
                        const obj = this.objectManager.objects.find(o => o.uuid === uuid);
                        this.objectManager.selectObject(obj);
                    });
                }

                // Keyboard shortcuts
                document.addEventListener('keydown', (event) => {
                    if (event.ctrlKey && event.key === 'z') {
                        event.preventDefault(); // Prevent browser undo
                        this.drawingManager.undoDrawing();
                    }
                });
            }

            updateUI() {
                // Update mode buttons
                if (this.elements.viewModeBtn) {
                    this.elements.viewModeBtn.classList.toggle('bg-blue-600', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('text-white', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('shadow-md', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('text-gray-700', this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('hover:bg-gray-200', this.drawingManager.drawingMode);
                }

                if (this.elements.drawModeBtn) {
                    this.elements.drawModeBtn.classList.toggle('bg-blue-600', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('text-white', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('shadow-md', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('text-gray-700', !this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('hover:bg-gray-200', !this.drawingManager.drawingMode);
                }

                // Show/hide control panels based on mode
                if (this.elements.viewControlsPanel) this.elements.viewControlsPanel.classList.toggle('hidden', this.drawingManager.drawingMode);
                if (this.elements.drawingControls) this.elements.drawingControls.classList.toggle('hidden', !this.drawingManager.drawingMode);
                
                // Show basic 3D shape controls only in view mode
                if (this.elements.basic3DShapeControls) this.elements.basic3DShapeControls.classList.toggle('hidden', this.drawingManager.drawingMode);
                
                if (this.elements.extrusionControls) this.elements.extrusionControls.classList.add('hidden'); // Always hide initially, shown by drawing manager

                // Object properties panel visibility
                if (this.elements.objectPropertiesPanel) this.elements.objectPropertiesPanel.classList.toggle('hidden', !this.objectManager.selectedObject || this.drawingManager.drawingMode);

                // Update drawing tool options visibility
                [this.elements.lineDrawingOptions, this.elements.circleDrawingOptions, this.elements.arcDrawingOptions, this.elements.rectangleDrawingOptions, this.elements.triangleDrawingOptions].forEach(opt => {
                    if (opt) opt.classList.add('hidden');
                });

                if (this.drawingManager.drawingMode) {
                    if (this.elements.drawingPlaneYInput) {
                        this.elements.drawingPlaneYInput.value = (this.drawingManager.drawingPlaneMesh.position.y * 100).toFixed(1);
                    }

                    // Update Snap to Grid buttons
                    if (this.elements.snapGridOnBtn) {
                        this.elements.snapGridOnBtn.classList.toggle('bg-blue-600', this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('text-white', this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('shadow-md', this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('text-gray-700', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('hover:bg-gray-200', !this.drawingManager.snapToGrid);
                    }
                    if (this.elements.snapGridOffBtn) {
                        this.elements.snapGridOffBtn.classList.toggle('bg-blue-600', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('text-white', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('shadow-md', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('text-gray-700', this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('hover:bg-gray-200', this.drawingManager.snapToGrid);
                    }

                    // Update Grid Snap Resolution input
                    if (this.elements.gridSnapResolutionInput) {
                        this.elements.gridSnapResolutionInput.value = (this.drawingManager.gridSnapResolution * 100).toFixed(0);
                    }


                    if (this.drawingManager.currentDrawingTool === 'line' || this.drawingManager.currentDrawingTool === 'polyline') {
                        if (this.elements.lineDrawingOptions) this.elements.lineDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.toggle('hidden', !(this.drawingManager.currentDrawingTool === 'polyline' && this.drawingManager.drawnPoints.length >= 3));
                    } else if (this.drawingManager.currentDrawingTool === 'circle') {
                        if (this.elements.circleDrawingOptions) this.elements.circleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'arc') {
                        if (this.elements.arcDrawingOptions) this.elements.arcDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'rectangle') { // Corrected from this.currentDrawingTool
                        if (this.elements.rectangleDrawingOptions) this.elements.rectangleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'triangle') { // Corrected from this.currentDrawingTool
                        if (this.elements.triangleDrawingOptions) this.elements.triangleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    }
                }

                // Update basic 3D shape tool options visibility
                [this.elements.cubeOptions, this.elements.sphereOptions, this.elements.cylinderOptions].forEach(opt => {
                    if (opt) opt.classList.add('hidden');
                });
                if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.add('hidden');

                if (!this.drawingManager.drawingMode && this.objectManager.currentBasic3DShapeTool) {
                    if (this.objectManager.currentBasic3DShapeTool === 'cube') {
                        if (this.elements.cubeOptions) this.elements.cubeOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    } else if (this.objectManager.currentBasic3DShapeTool === 'sphere') {
                        if (this.elements.sphereOptions) this.elements.sphereOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    } else if (this.objectManager.currentBasic3DShapeTool === 'cylinder') {
                        if (this.elements.cylinderOptions) this.elements.cylinderOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    }
                }

                // Update solid/wireframe buttons
                if (this.elements.solidViewBtn) {
                    this.elements.solidViewBtn.classList.toggle('bg-blue-600', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('text-white', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('shadow-md', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('text-gray-700', this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.isWireframe);
                }

                if (this.elements.wireframeViewBtn) {
                    this.elements.wireframeViewBtn.classList.toggle('bg-blue-600', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('text-white', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('shadow-md', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('text-gray-700', !this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('hover:bg-gray-200', !this.sceneManager.isWireframe);
                }

                // Update camera type buttons
                if (this.elements.perspectiveViewBtn) {
                    this.elements.perspectiveViewBtn.classList.toggle('bg-blue-600', this.sceneManager.cameraType === 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('text-white', this.sceneManager.cameraType === 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('shadow-md', this.sceneManager.cameraType === 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('text-gray-700', this.sceneManager.cameraType !== 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.cameraType !== 'perspective');
                }
                if (this.elements.orthographicViewBtn) {
                    this.elements.orthographicViewBtn.classList.toggle('bg-blue-600', this.sceneManager.cameraType === 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('text-white', this.sceneManager.cameraType === 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('shadow-md', this.sceneManager.cameraType === 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('text-gray-700', this.sceneManager.cameraType !== 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.cameraType !== 'orthographic');
                }

                // Update grid visibility buttons
                if (this.elements.showGridBtn) {
                    this.elements.showGridBtn.classList.toggle('bg-blue-600', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('text-white', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('shadow-md', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('text-gray-700', !this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('hover:bg-gray-200', !this.sceneManager.isGridVisible);
                }

                if (this.elements.hideGridBtn) {
                    this.elements.hideGridBtn.classList.toggle('bg-blue-600', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('text-white', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('shadow-md', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('text-gray-700', this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.isGridVisible);
                }

                // Update toolbar active states (only paint bucket for now)
                [this.elements.setupBaseBtn, this.elements.materialsBtn, this.elements.paintBucketBtn, this.elements.lightsBtn, this.elements.importBtn, this.elements.controlsBtn, this.elements.performanceBtn, this.elements.infoBtn, this.elements.geometriesDropdownBtn, this.elements.templatesDropdownBtn].forEach(btn => {
                    if (btn) btn.classList.remove('active');
                });
                if (this.elements.paintBucketBtn && this.objectManager.paintBucketMode) {
                    this.elements.paintBucketBtn.classList.add('active');
                }

                // Update drawn points count
                if (this.elements.drawnPointsCount) {
                    this.elements.drawnPointsCount.textContent = this.drawingManager.drawnPoints.length;
                }
            }

            // Method to update the dropdown list of selected objects
            updateSelectedObjectOptions(objects, selectedObject) {
                if (!this.elements.selectedObjectSelect) {
                    console.error("UIManager: selectedObjectSelect element not found.");
                    return;
                }
                this.elements.selectedObjectSelect.innerHTML = ''; // Clear existing options
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Nessun oggetto selezionato';
                this.elements.selectedObjectSelect.appendChild(defaultOption);

                objects.forEach(obj => {
                    const option = document.createElement('option');
                    option.value = obj.uuid;
                    option.textContent = obj.name || `Oggetto ${obj.uuid.substring(0, 4)}`;
                    this.elements.selectedObjectSelect.appendChild(option);
                });

                if (selectedObject) {
                    this.elements.selectedObjectSelect.value = selectedObject.uuid;
                } else {
                    this.elements.selectedObjectSelect.value = '';
                }
            }

            // Method to update the properties panel for the selected object
            updateObjectProperties(object) {
                if (!this.elements.objectPropertiesPanel) {
                    console.error("UIManager: objectPropertiesPanel element not found.");
                    return;
                }

                if (object) {
                    this.elements.objectPropertiesPanel.classList.remove('hidden');
                    // Set color
                    if (object.material && object.material.color) {
                        this.elements.objectColorInput.value = `#${object.material.color.getHexString()}`;
                    } else {
                        this.elements.objectColorInput.value = '#cccccc'; // Default if no color
                    }

                    // Set position
                    this.elements.posXInput.value = object.position.x.toFixed(2);
                    this.elements.posYInput.value = object.position.y.toFixed(2);
                    this.elements.posZInput.value = object.position.z.toFixed(2);

                    // Set rotation (convert radians to degrees)
                    this.elements.rotXInput.value = THREE.MathUtils.radToDeg(object.rotation.x).toFixed(0);
                    this.elements.rotYInput.value = THREE.MathUtils.radToDeg(object.rotation.y).toFixed(0);
                    this.elements.rotZInput.value = THREE.MathUtils.radToDeg(object.rotation.z).toFixed(0);
                } else {
                    this.elements.objectPropertiesPanel.classList.add('hidden');
                }
            }


            // Static method for modal messages
            static showModalMessage(title, message, customButtons = '') {
                const modalBackdrop = document.createElement('div');
                modalBackdrop.className = 'modal-backdrop';
                modalBackdrop.id = 'customModal';

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.innerHTML = `
                    <h3 class="font-bold">${title}</h3>
                    <p class="text-gray-700">${message}</p>
                    <div class="mt-4">
                        ${customButtons || `<button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove()">Chiudi</button>`}
                    </div>
                `;

                modalBackdrop.appendChild(modalContent);
                document.body.appendChild(modalBackdrop);
            }

            // Static method for floating status messages
            static showStatus(text, isError = false) {
                const el = document.getElementById('export-status');
                if (el) {
                    el.textContent = text;
                    el.style.display = 'block';
                    el.style.backgroundColor = isError ? '#c0392b' : '#2c3e50';
                    setTimeout(() => el.style.display = 'none', 3000);
                }
            }

            showInfoModal() {
                const infoContent = `
                    <p class="text-left text-gray-700 mb-4">Benvenuto! Ecco una guida rapida all'uso dei vari strumenti:</p>
                    <div class="text-left text-gray-700 text-sm">
                        <p class="mb-2"><strong>üõ†Ô∏è Setup Base:</strong> Resetta l'intera scena, rimuovendo tutti gli oggetti e il disegno 2D.</p>
                        <p class="mb-2"><strong>üßä Geometrie:</strong> Questo menu ti permette di selezionare strumenti per il disegno 2D o per aggiungere forme 3D di base:</p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Linea, Polilinea, Cerchio, Arco, Triangolo, Rettangolo:</strong> Strumenti per disegnare forme 2D sul piano. Una volta disegnate, puoi estruderle.</li>
                            <li><strong>Cubo, Sfera, Cilindro:</strong> Aggiunge direttamente queste forme 3D predefinite alla scena.</li>
                        </ul>
                        <p class="mb-2"><strong>üé® Materiali:</strong> Seleziona un oggetto nella scena e usa il pannello laterale "Propriet√† Oggetto" per cambiare il suo colore. Puoi anche applicare materiali predefiniti dal menu "Template".</p>
                        <p class="mb-2"><strong>üñåÔ∏è Applica Materiale:</strong> Attiva la modalit√† "secchiello di vernice". Clicca su qualsiasi oggetto nella scena per applicare il colore corrente selezionato nel pannello delle propriet√†.</p>
                        <p class="mb-2"><strong>üí° Luci:</strong> Funzionalit√† per la gestione dell'illuminazione (non ancora implementata).</p>
                        <p class="mb-2"><strong>üì¶ Importa:</strong> Ti permette di caricare modelli 3D esterni nei formati ".gltf", ".glb" o ".obj" nella scena.</p>
                        <p class="mb-2"><strong>ü™ë Template:</strong> Questo menu offre materiali predefiniti (Legno, Marmo, Metallo) da applicare agli oggetti selezionati e oggetti di interior design pre-assemblati (Sedia, Tavolo, Stanza Vuota).</p>
                        <p class="mb-2"><strong>‚úã Controlli:</strong> Informazioni sui controlli di navigazione (non ancora implementata).</p>
                        <p class="mb-2"><strong>‚ö° Performance:</strong> Opzioni di ottimizzazione del rendering (non ancora implementata).</p>
                        <p class="mb-2"><strong>‚ÑπÔ∏è Info:</strong> Mostra questa finestra di aiuto.</p>
                        <p class="mt-4"><strong>Modalit√† Vista/Disegno (Pannello Laterale):</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Vista:</strong> Ti permette di orbitare, zoomare e spostare la telecamera per visualizzare la scena 3D.</li>
                            <li><strong>Disegno:</strong> Attiva il piano di disegno 2D per creare forme che possono poi essere estruse.</li>
                            <li><strong>Sfera Rossa (Indicatore):</strong> In modalit√† Disegno, una piccola sfera rossa ti mostra esattamente dove verr√† posizionato il prossimo punto sul piano di disegno.</li>
                            <li><strong>Snap alla Griglia:</strong> Attiva/disattiva l'aggancio dei punti alla griglia. Puoi impostare la "Risoluzione Snap Griglia (cm)" per controllare la precisione dello snap.</li>
                        </ul>
                        <p class="mt-4"><strong>Controlli Generali:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Mouse:</strong> Clicca e trascina per orbitare (modalit√† Vista) o per disegnare (modalit√† Disegno).</li>
                            <li><strong>Rotellina del mouse:</strong> Zoom.</li>
                            <li><strong>Ctrl + Z:</strong> Annulla l'ultima operazione di disegno 2D.</li>
                        </ul>
                        <p class="mt-4"><strong>Funzionamento della modalit√† Ortogonale (Orto):</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Blocco del cursore:</strong> Quando la modalit√† Orto √® attiva, il cursore si muove solo lungo assi orizzontali o verticali rispetto al sistema di coordinate corrente (UCS).</li>
                            <li><strong>Disegno preciso:</strong> Permette di disegnare linee con angoli di 90 gradi, creando segmenti perfettamente orizzontali o verticali.</li>
                            <li><strong>Spostamento e copia:</strong> La modalit√† Orto √® utile anche per spostare o copiare elementi in direzione orizzontale o verticale.</li>
                            <li><strong>Attivazione/disattivazione:</strong> Si attiva/disattiva cliccando sul pulsante "Ortogonale" nel pannello di controllo. Il supporto per il tasto F8 e la disattivazione temporanea con Maiusc <strong>non sono implementati</strong> in questa versione.</li>
                            <li><strong>Priorit√†:</strong> La modalit√† Orto ha la precedenza sugli snap ad oggetto e sull'immissione diretta della distanza (questo comportamento <strong>non √® implementato</strong> in questa versione).</li>
                            <li><strong>Esempio pratico:</strong> Se si sta disegnando una linea e si vuole assicurare che sia perfettamente orizzontale, si pu√≤ attivare la modalit√† Orto prima di specificare il secondo punto della linea. In questo modo, il cursore si muover√† solo orizzontalmente, garantendo che la linea sia parallela all'asse X del sistema di coordinate.</li>
                        </ul>
                        <p class="mt-4"><strong>Differenza con il puntamento polare:</strong> La modalit√† Orto e il puntamento polare non possono essere attivati contemporaneamente. L'attivazione di Orto disattiva il puntamento polare e viceversa (il puntamento polare <strong>non √® implementato</strong> in questa versione).</p>
                        <p class="mt-4"><strong>Limitazioni Importazione OBJ+Texture:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>I file `.mtl` devono usare nomi semplici per le texture (es. "diffuse.jpg" invece di "./textures/diffuse.jpg").</li>
                            <li>Le dimensioni massime dei file sono limitate dalla memoria del browser.</li>
                            <li>Per modelli molto complessi (>50MB) potrebbero esserci problemi di prestazioni o di caricamento.</li>
                            <li>Se non vedi il tuo modello, prova a scalare la scena o il modello stesso.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Esportazione DXF:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>Supporta principalmente solo entit√† geometriche di base (punti, linee, polilinee). Spline, curve NURBS, testo, dimensioni e altre entit√† CAD complesse <strong>non sono supportate</strong> direttamente e vengono convertite in linee o saltate.</li>
                            <li>Le texture e i materiali <strong>non vengono esportati</strong> (il DXF √® principalmente un formato geometrico). I colori vengono mappati a indici colore DXF standard.</li>
                            <li>Per oggetti complessi o modelli importati, la geometria viene convertita in bordi (linee) per l'esportazione. Questo pu√≤ risultare in file DXF molto grandi o con dettagli eccessivi. Considera di semplificare la geometria prima dell'esportazione per ottenere un file DXF pi√π gestibile.</li>
                            <li>I gruppi di oggetti Three.js vengono esportati come "blocchi" DXF, migliorando l'organizzazione del file.</li>
                            <li>La scala di esportazione √® configurabile (default: 1 unit√† Three.js = 1 millimetro DXF).</li>
                            <li>La precisione decimale delle coordinate √® configurabile per bilanciare fedelt√† e dimensione del file.</li>
                            <li>Questa √® un'implementazione lato client e potrebbe non essere compatibile con tutte le versioni di software CAD o supportare tutte le specifiche DXF.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Esportazione PDF:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>L'esportazione PDF genera un'immagine raster (non vettoriale) della vista corrente del canvas.</li>
                            <li>La qualit√† dell'immagine dipender√† dalla risoluzione del canvas e dalle impostazioni del renderer.</li>
                            <li>Non √® un'esportazione CAD vettoriale, ma una "istantanea" visiva.</li>
                            <li>Il caricamento della libreria jsPDF avviene solo al momento del click per ottimizzare le prestazioni iniziali.</li>
                        </ul>
                    </div>
                `;
                UIManager.showModalMessage("Guida all'Uso del Modellatore 3D", infoContent);
            }
        }

        // --- Main Application Initialization ---
        let sceneManager, objectManager, drawingManager, uiManager, exportManager;

        function initApp() {
            // Check WebGL support
            if (!window.WebGLRenderingContext) {
                UIManager.showModalMessage("Warning", "Your browser may not support WebGL, 3D features might be limited.");
            }

            const canvasContainer = document.getElementById('canvas-container');

            // 1. Initialize SceneManager (no external dependencies yet)
            sceneManager = new SceneManager(canvasContainer);

            // 2. Initialize ObjectManager and DrawingManager with null UIManager references initially
            objectManager = new ObjectManager(sceneManager, null, null);
            drawingManager = new DrawingManager(sceneManager, null, objectManager);

            // Now, set the drawingManager reference on objectManager (circular dependency)
            objectManager.drawingManager = drawingManager;

            // 3. Initialize ExportManager with null UIManager reference initially
            exportManager = new ExportManager(sceneManager, objectManager, null);

            // 4. Initialize UIManager, passing all other managers
            uiManager = new UIManager(sceneManager, objectManager, drawingManager, exportManager);

            // 5. Assign the fully initialized uiManager to other managers
            objectManager.uiManager = uiManager;
            drawingManager.uiManager = uiManager;
            exportManager.uiManager = uiManager;

            // Start animation loop
            sceneManager.animate();

            // Initial UI updates and state saving, now that all managers are fully linked
            uiManager.updateUI();
            objectManager.uiManager.updateSelectedObjectOptions(objectManager.objects, objectManager.selectedObject);
            drawingManager.saveDrawingState(); // Save initial empty state for undo

            console.log("App initialized and animate loop started.");
        }

        // Load polyfills if needed
        function loadPolyfills() {
            const needed = [];
            if (!window.Promise) needed.push('promise');
            // Note: HTMLCanvasElement.prototype.toDataURL is generally supported
            // If specific older browser support is needed, consider adding more checks
            
            if (needed.length > 0) {
                const polyfillUrl = `https://cdn.polyfill.io/v3/polyfill.min.js?features=${needed.join(',')}`;
                const script = document.createElement('script');
                script.src = polyfillUrl;
                script.onload = () => console.log('Polyfills loaded.');
                script.onerror = () => console.error('Failed to load polyfills.');
                document.head.appendChild(script);
            }
        }

        window.onload = function () {
            loadPolyfills();
            initApp();
        }
    </script>
</body>
</html>
