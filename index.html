<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modellatore 3D con Estrusione</title>
    <!-- Carica Tailwind CSS per uno stile rapido e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Carica Three.js (versione 0.132.2) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- Carica OrbitControls per il controllo della telecamera (versione 0.132.2) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.min.js"></script>
    <!-- Carica GLTFLoader, OBJLoader e MTLLoader per l'importazione di modelli -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/MTLLoader.min.js"></script>
    <!-- jsPDF non è più caricato qui, ma dinamicamente -->
    <style>
        /* Variabili CSS da index (12).html */
        :root {
            --primary: #6a11cb;
            --secondary: #2575fc;
            --accent: #00c853;
            --warning: #ffab00;
            --danger: #ff1744;
            --dark: #1a1a2e;
            --light: #f0f5ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--dark), #0f1b31); /* Sfondo da index (12).html */
            color: var(--light); /* Colore testo da index (12).html */
            font-family: 'Inter', sans-serif; /* Mantenuto Inter, ma puoi cambiarlo a 'Segoe UI' se preferisci */
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px; /* Padding da index (12).html */
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            flex: 1; /* Permette al contenitore di espandersi */
            display: flex;
            flex-direction: column;
        }
        
        header {
            text-align: center;
            padding: 0; /* Rimosso padding */
            margin-bottom: 0; /* Rimosso margin */
        }
        
        /* Rimosso h1 e subtitle styles */

        /* Stile del pannello "Glass" da index (12).html */
        .glass-panel {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
            transition: all 0.3s ease;
        }

        /* Stili specifici per il layout del modellatore, adattati */
        #app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 0; /* Rimuovi padding duplicato dal container */
        }
        #canvas-container {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.3); /* Sfondo più scuro per il canvas */
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            width: 100% !important; /* Forza la larghezza al 100% del contenitore */
            height: 100% !important; /* Forza l'altezza al 100% del contenitore */
        }
        .control-panel {
            background-color: rgba(255, 255, 255, 0.08); /* Usa glass-panel background */
            border-radius: 20px; /* Usa glass-panel border-radius */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36); /* Usa glass-panel shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Usa glass-panel border */
            padding: 25px; /* Usa glass-panel padding */
            width: 350px; /* Larghezza fissa per il pannello di controllo */
            flex-shrink: 0; /* Impedisce al pannello di restringersi */
            overflow-y: auto; /* Scroll verticale se i contenuti superano l'altezza */
            margin-right: 20px;
            color: var(--light); /* Assicura che il testo sia chiaro */
        }
        @media (max-width: 1024px) {
            #app-container {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #FFFFFF; /* Colore più contrastato */
        }
        .input-group input[type="number"],
        .input-group input[type="color"],
        .input-group select,
        .input-group input[type="text"] {
            width: 100%;
            background: rgba(255, 255, 255, 0.15); /* Sfondo input più chiaro */
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .input-group input[type="number"]:focus,
        .input-group input[type="color"]:focus,
        .input-group select:focus,
        .input-group input[type="text"]:focus {
            outline: none;
            border-color: var(--primary); /* Colore focus primario */
            box-shadow: 0 0 0 3px rgba(106, 17, 203, 0.2); /* Ombra focus primario */
        }
        .input-group input[type="color"] {
            height: 40px;
            padding: 0;
        }
        .btn {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background: linear-gradient(90deg, var(--primary), var(--secondary)); /* Gradiente da index (12).html */
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(106, 17, 203, 0.3); /* Ombra da index (12).html */
        }
        .btn-primary:hover {
            transform: translateY(-3px); /* Effetto hover da index (12).html */
            box-shadow: 0 8px 25px rgba(106, 17, 203, 0.5); /* Ombra hover da index (12).html */
            background-color: var(--secondary); /* Fallback */
        }
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            color: var(--light);
            border: none;
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover più contrastato */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .btn-success {
            background-color: var(--accent);
            color: white;
        }
        .btn-success:hover {
            background-color: #16a34a;
            transform: translateY(-1px);
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .tool-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            color: var(--light); /* Testo chiaro */
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
            cursor: pointer;
            flex: 1;
            min-width: 70px;
        }
        .tool-button:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover più contrastato */
            transform: translateY(-1px);
        }
        .tool-button.active {
            background: linear-gradient(90deg, var(--primary), var(--secondary)); /* Gradiente attivo da index (12).html */
            color: white;
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.5); /* Ombra attiva da index (12).html */
        }
        .tool-button svg {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
            fill: currentColor;
        }
        .code-output {
            background-color: rgba(255, 255, 255, 0.15); /* Sfondo input più chiaro */
            color: #a7f3d0;
            padding: 15px;
            border-radius: 12px; /* Border-radius più arrotondato */
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 0.875rem;
            overflow-x: auto;
            max-height: 200px;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1); /* Bordo da index (12).html */
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.25); /* Sfondo più chiaro */
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: rgba(255, 255, 255, 0.35);
        }

        /* Stili per il modale */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 600px; /* Aumentato per contenere più testo */
            width: 90%;
            color: #333; /* Colore testo per il modale */
        }
        .modal-content h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #333;
        }
        .modal-content p {
            font-size: 16px; /* Ridotto leggermente per leggibilità */
            color: #555;
            margin-bottom: 15px; /* Ridotto leggermente */
        }
        .modal-content ul {
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            padding: 0; /* Rimosso padding */
            margin-top: 0; /* Rimosso margin */
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
        }

        /* Nuovi stili per la toolbar */
        .toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.08); /* glass-panel background */
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
        }
        .toolbar button {
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            color: var(--light);
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 80px; /* Larghezza minima per i pulsanti */
        }
        .toolbar button:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover più contrastato */
            transform: translateY(-2px);
        }
        .toolbar button.active {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.5);
        }
        .toolbar button span {
            font-size: 0.8rem; /* Testo più piccolo sotto l'icona */
            display: block;
            margin-top: 4px;
        }

        /* Dropdown styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            backdrop-filter: blur(10px);
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
            top: 100%; /* Posiziona sotto il pulsante */
            left: 50%;
            transform: translateX(-50%); /* Centra il dropdown */
            margin-top: 10px; /* Spazio dal pulsante */
        }

        .dropdown-content button {
            color: var(--light);
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            background-color: transparent; /* Rimuove sfondo predefinito */
            width: 100%;
            text-align: left;
            font-size: 0.9rem;
            border-radius: 8px; /* Arrotonda i pulsanti interni */
        }

        .dropdown-content button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        /* New CSS for #importBtn */
        #importBtn {
            background: #4CAF50;
            border: none;
            border-radius: 10px; /* Changed to match other buttons */
            padding: 10px 15px; /* Changed to match other buttons */
            font-size: 1.2rem; /* Changed to match other buttons */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s; /* Combined transitions */
            display: flex; /* Added flex for icon and text */
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 80px;
        }
        #importBtn:hover {
            transform: translateY(-2px); /* Consistent hover effect */
            background: #66BB6A;
        }
        #importBtn svg {
            fill: white;
            vertical-align: middle;
        }

        /* Stili per il pulsante PDF con spinner */
        .btn-spinner {
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Stili per il messaggio di stato fluttuante */
        #export-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1001; /* Assicura che sia sopra il modale */
        }
    </style>
</head>
<body class="flex flex-col">

    <div class="container">
        <!-- Header dell'applicazione - Rimosso testo -->
        <header></header>
        
        <!-- Nuova Barra degli Strumenti -->
        <div class="toolbar">
            <button id="setupBaseBtn" title="Inizializza motore 3D">🛠️<span>Setup Base</span></button>
            
            <div class="dropdown">
                <button id="geometriesDropdownBtn" title="Aggiungi forme base">🧊<span>Geometrie</span></button>
                <div class="dropdown-content">
                    <button id="lineToolBtnToolbar">Linea</button>
                    <button id="polylineToolBtnToolbar">Polilinea</button>
                    <button id="circleToolBtnToolbar">Cerchio</button>
                    <button id="arcToolBtnToolbar">Arco</button>
                    <button id="triangleToolBtnToolbar">Triangolo</button>
                    <button id="rectangleToolBtnToolbar">Rettangolo</button>
                    <hr class="my-2 border-gray-600">
                    <button id="addCubeBtnToolbar">Cubo</button>
                    <button id="addSphereBtnToolbar">Sfera</button>
                    <button id="addCylinderBtnToolbar">Cilindro</button>
                </div>
            </div>

            <button id="materialsBtn" title="Modifica superfici">🎨<span>Materiali</span></button>
            <button id="paintBucketBtn" title="Applica Materiale">🖌️<span>Applica</span></button>
            <button id="lightsBtn" title="Aggiungi illuminazione">💡<span>Luci</span></button>
            <button id="importBtn" title="Carica modelli 3D">📦<span>Importa</span></button>
            <!-- Hidden file inputs for OBJ/MTL/Texture loading -->
            <input type="file" id="objInputHidden" accept=".obj" hidden>
            <input type="file" id="mtlInputHidden" accept=".mtl" hidden>
            <input type="file" id="textureInputHidden" accept="image/*" multiple hidden>
            
            <div class="dropdown">
                <button id="templatesDropdownBtn" title="Template">🪑<span>Template</span></button>
                <div class="dropdown-content">
                    <button id="applyWoodMaterialBtn">🪵 Legno</button>
                    <button id="applyMarbleMaterialBtn">🏁 Marmo</button>
                    <button id="applyMetalMaterialBtn">🔩 Metallo</button>
                    <hr class="my-2 border-gray-600">
                    <button id="addChairBtnToolbar">🪑 Sedia</button>
                    <button id="addTableBtnToolbar">🛋️ Tavolo</button>
                    <button id="addEmptyRoomBtnToolbar">Stanza Vuota</button>
                </div>
            </div>

            <button id="controlsBtn" title="Naviga nella scena">✋<span>Controlli</span></button>
            <button id="performanceBtn" title="Ottimizza rendering">⚡<span>Performance</span></button>
            <button id="infoBtn" title="Informazioni sull'uso">ℹ️<span>Info</span></button>
        </div>
        
        <!-- Contenitore principale dell'app -->
        <main id="app-container" class="p-4 sm:p-6 lg:p-8">
            <!-- Pannello di controllo -->
            <aside class="control-panel glass-panel">
                <h2 class="text-2xl font-bold text-white mb-4">Controlli</h2>

                <!-- Modalità di Lavoro -->
                <div class="input-group">
                    <label>Modalità:</label>
                    <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                        <button id="viewModeBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Vista
                        </button>
                        <button id="drawModeBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Disegno
                        </button>
                    </div>
                </div>

                <!-- Controlli Vista -->
                <div id="viewControlsPanel" class="mt-6 border-t border-gray-200 pt-6">
                    <h3 class="text-xl font-semibold text-white mb-4">Controlli Vista</h3>
                    <div class="btn-group mb-4">
                        <button id="viewTopBtn" class="btn btn-secondary flex-1">Top</button>
                        <button id="viewFrontBtn" class="btn btn-secondary flex-1">Front</button>
                        <button id="viewRightBtn" class="btn btn-secondary flex-1">Right</button>
                        <button id="viewIsoBtn" class="btn btn-secondary flex-1">Isometrica</button>
                    </div>
                    <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                        <button id="solidViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Solido
                        </button>
                        <button id="wireframeViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Wireframe
                        </button>
                    </div>
                </div>

                <!-- Controlli Disegno (mostrati solo in modalità Disegno) -->
                <div id="drawingControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Opzioni Disegno 2D</h3>
                    <!-- Options for Line/Polyline -->
                    <div id="lineDrawingOptions" class="input-group">
                        <label>Punti Disegnati:</label>
                        <span id="drawnPointsCount" class="font-bold text-white">0</span>
                        <div class="flex gap-2 mt-2">
                            <input type="number" id="lineLengthInput" placeholder="Lunghezza (cm)" step="0.1" class="flex-1">
                        </div>
                    </div>

                    <!-- Options for Circle -->
                    <div id="circleDrawingOptions" class="input-group hidden">
                        <label for="circleRadiusInput">Raggio Cerchio (cm):</label>
                        <input type="number" id="circleRadiusInput" value="1" step="0.1">
                    </div>

                    <!-- Options for Arc -->
                    <div id="arcDrawingOptions" class="input-group hidden">
                        <label for="arcRadiusInput">Raggio Arco (cm):</label>
                        <input type="number" id="arcRadiusInput" value="1" step="0.1">
                        <label for="arcStartAngleInput">Angolo Iniziale (Gradi):</label>
                        <input type="number" id="arcStartAngleInput" value="0" step="1">
                        <label for="arcEndAngleInput">Angolo Finale (Gradi):</label>
                        <input type="number" id="arcEndAngleInput" value="90" step="1">
                        <label for="arcClockwiseInput">Senso Orario:</label>
                        <input type="checkbox" id="arcClockwiseInput">
                    </div>

                    <!-- Options for Rectangle -->
                    <div id="rectangleDrawingOptions" class="input-group hidden">
                        <label for="rectWidthInput">Larghezza Rettangolo (cm):</label>
                        <input type="number" id="rectWidthInput" value="2" step="0.1">
                        <label for="rectHeightInput">Altezza Rettangolo (cm):</label>
                        <input type="number" id="rectHeightInput" value="2" step="0.1">
                    </div>

                    <!-- Options for Triangle -->
                    <div id="triangleDrawingOptions" class="input-group hidden">
                        <label for="triBaseInput">Base Triangolo (cm):</label>
                        <input type="number" id="triBaseInput" value="2" step="0.1">
                        <label for="triHeightInput">Altezza Triangolo (cm):</label>
                        <input type="number" id="triHeightInput" value="2" step="0.1">
                    </div>

                    <!-- Grid Visibility Toggle -->
                    <div class="input-group">
                        <label>Griglia Visibile:</label>
                        <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                            <button id="showGridBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                                Mostra
                            </button>
                            <button id="hideGridBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                                Nascondi
                            </button>
                        </div>
                    </div>

                    <button id="closePathBtn" class="btn btn-success w-full mb-3">Concludi Percorso</button>
                    <button id="undoDrawingBtn" class="btn btn-secondary w-full">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M12 19V5M5 12L12 5L19 12"></path></svg>
                        Annulla (Ctrl+Z)
                    </button>
                </div>

                <!-- Controlli Forme 3D Base -->
                <div id="basic3DShapeControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Opzioni Forma 3D Base</h3>
                    <div id="cubeOptions" class="input-group hidden">
                        <label for="cubeSideInput">Lato Cubo (cm):</label>
                        <input type="number" id="cubeSideInput" value="2" step="0.1">
                    </div>
                    <div id="sphereOptions" class="input-group hidden">
                        <label for="sphereRadiusInput">Raggio Sfera (cm):</label>
                        <input type="number" id="sphereRadiusInput" value="1" step="0.1">
                    </div>
                    <div id="cylinderOptions" class="input-group hidden">
                        <label for="cylinderRadiusInput">Raggio Cilindro (cm):</label>
                        <input type="number" id="cylinderRadiusInput" value="1" step="0.1">
                        <label for="cylinderHeightInput">Altezza Cilindro (cm):</label>
                        <input type="number" id="cylinderHeightInput" value="2" step="0.1">
                    </div>
                    <button id="addBasicShapeBtn" class="btn btn-primary w-full hidden">Aggiungi Forma 3D</button>
                </div>

                <!-- Controlli Estrusione (mostrati solo dopo aver concluso un percorso) -->
                <div id="extrusionControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Estrusione</h3>
                    <div class="input-group">
                        <label for="extrusionDepth">Altezza Estrusione (cm):</label>
                        <input type="number" id="extrusionDepth" value="2" step="0.1">
                    </div>
                    <button id="extrudeBtn" class="btn btn-primary w-full">Estrudi</button>
                </div>

                <!-- Selezione Oggetto -->
                <div class="input-group mt-6 border-t border-gray-200 pt-6">
                    <label for="selectedObject">Oggetto Selezionato:</label>
                    <select id="selectedObject" class="mb-2"></select>
                    <button id="removeObjectBtn" class="btn btn-danger w-full">Rimuovi Selezionato</button>
                </div>

                <!-- Proprietà Oggetto Selezionato -->
                <div id="objectProperties" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Proprietà Oggetto</h3>

                    <div class="input-group">
                        <label for="objectColor">Colore:</label>
                        <input type="color" id="objectColor" value="#3b82f6">
                    </div>

                    <div class="input-group">
                        <label>Posizione (cm):</label>
                        <div class="flex gap-2">
                            <input type="number" id="posX" placeholder="X" step="0.1" class="flex-1">
                            <input type="number" id="posY" placeholder="Y" step="0.1" class="flex-1">
                            <input type="number" id="posZ" placeholder="Z" step="0.1" class="flex-1">
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Rotazione (Gradi):</label>
                        <div class="flex gap-2">
                            <input type="number" id="rotX" placeholder="X" step="1" class="flex-1">
                            <input type="number" id="rotY" placeholder="Y" step="1" class="flex-1">
                            <input type="number" id="rotZ" placeholder="Z" step="1" class="flex-1">
                        </div>
                    </div>
                </div>

                <div class="btn-group mt-6 border-t border-gray-200 pt-6">
                    <button id="resetSceneBtnSide" class="btn btn-secondary flex-1">Reset Scena</button>
                    <button id="generateCodeBtn" class="btn btn-primary flex-1">Genera Codice Three.js</button>
                    <button id="printBtn" class="btn btn-secondary flex-1">Stampa Disegno</button>
                    <button id="exportDXFBtn" class="btn btn-secondary flex-1">Esporta DXF</button> <!-- Nuovo pulsante DXF -->
                    <button id="exportPDFBtn" class="btn btn-secondary flex-1">
                        <span class="btn-icon">📄</span>
                        <span class="btn-text">Esporta PDF</span>
                        <span class="btn-spinner" hidden>⌛</span>
                    </button>
                </div>
            </aside>

            <!-- Contenitore Canvas 3D -->
            <main id="canvas-container" class="flex-1">
                <!-- Il canvas verrà aggiunto qui dal JavaScript -->
            </main>
        </main>

        <!-- Sezione Output Codice -->
        <section class="p-4 sm:p-6 lg:p-8 glass-panel">
            <h2 class="text-2xl font-bold text-white mb-4">Codice Three.js Generato</h2>
            <div class="code-output-wrapper relative">
                <button id="copyCodeBtn" class="copy-button">Copia Codice</button>
                <pre id="generatedCode" class="code-output">
// Il codice Three.js della tua scena apparirà qui.
// Puoi copiarlo e usarlo in un progetto Three.js!
                </pre>
            </div>
        </section>
    </div>

    <!-- Footer - Rimosso testo -->
    <footer></footer>

    <!-- Messaggio di stato fluttuante -->
    <div id="export-status"></div>

    <script>
        // Global error listener for unhandled errors
        window.addEventListener('error', (e) => {
            console.error("Unhandled global error:", e);
            UIManager.showModalMessage("Unexpected Error", `An unexpected error occurred: ${e.message || 'Details in console.'}`);
        });

        // Helper function to dispose of Three.js object resources
        function disposeObject(obj) {
            if (obj.geometry) {
                obj.geometry.dispose();
            }
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(material => material.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            if (obj.children) {
                obj.children.forEach(child => disposeObject(child)); // Recursively dispose children
            }
        }

        // Helper function to read a file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (error) => {
                    console.error(`Error reading file: ${file.name}`, error);
                    reject(error);
                };
                reader.readAsText(file);
            });
        }

        // Helper function to load a single texture from a File
        function loadTexture(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        resolve({ name: file.name, texture: texture });
                    };
                    img.onerror = (error) => {
                        console.error(`Error loading texture image ${file.name}:`, error);
                        reject(new Error(`Failed to load texture image: ${file.name}.`));
                    };
                    img.src = e.target.result;
                };
                reader.onerror = (error) => {
                    console.error(`Error reading texture file ${file.name}:`, error);
                    reject(new Error(`Failed to read texture file: ${file.name}.`));
                };
                reader.readAsDataURL(file);
            });
        }

        // === UIManager Class ===
        class UIManager {
            constructor(sceneManager, objectManager, drawingManager, exportManager) {
                this.sceneManager = sceneManager;
                this.objectManager = objectManager;
                this.drawingManager = drawingManager;
                this.exportManager = exportManager;

                this.elements = {}; // Store references to DOM elements
                this.initDOMElements();
                this.addEventListeners();
                this.updateUI(); // Initial UI update
            }

            initDOMElements() {
                this.elements.canvasContainer = document.getElementById('canvas-container');
                console.log('Element canvas-container:', this.elements.canvasContainer ? 'found' : 'NOT found');
                this.elements.viewModeBtn = document.getElementById('viewModeBtn');
                console.log('Element viewModeBtn:', this.elements.viewModeBtn ? 'found' : 'NOT found');
                this.elements.drawModeBtn = document.getElementById('drawModeBtn');
                console.log('Element drawModeBtn:', this.elements.drawModeBtn ? 'found' : 'NOT found');
                this.elements.viewControlsPanel = document.getElementById('viewControlsPanel');
                console.log('Element viewControlsPanel:', this.elements.viewControlsPanel ? 'found' : 'NOT found');
                this.elements.drawingControls = document.getElementById('drawingControls');
                console.log('Element drawingControls:', this.elements.drawingControls ? 'found' : 'NOT found');
                this.elements.basic3DShapeControls = document.getElementById('basic3DShapeControls');
                console.log('Element basic3DShapeControls:', this.elements.basic3DShapeControls ? 'found' : 'NOT found');
                this.elements.drawnPointsCount = document.getElementById('drawnPointsCount');
                console.log('Element drawnPointsCount:', this.elements.drawnPointsCount ? 'found' : 'NOT found');
                this.elements.closePathBtn = document.getElementById('closePathBtn');
                console.log('Element closePathBtn:', this.elements.closePathBtn ? 'found' : 'NOT found');
                this.elements.undoDrawingBtn = document.getElementById('undoDrawingBtn');
                console.log('Element undoDrawingBtn:', this.elements.undoDrawingBtn ? 'found' : 'NOT found');
                this.elements.extrusionControls = document.getElementById('extrusionControls');
                console.log('Element extrusionControls:', this.elements.extrusionControls ? 'found' : 'NOT found');
                this.elements.extrusionDepthInput = document.getElementById('extrusionDepth');
                console.log('Element extrusionDepthInput:', this.elements.extrusionDepthInput ? 'found' : 'NOT found');
                this.elements.extrudeBtn = document.getElementById('extrudeBtn');
                console.log('Element extrudeBtn:', this.elements.extrudeBtn ? 'found' : 'NOT found');
                this.elements.selectedObjectSelect = document.getElementById('selectedObject');
                console.log('Element selectedObjectSelect:', this.elements.selectedObjectSelect ? 'found' : 'NOT found');
                this.elements.removeObjectBtn = document.getElementById('removeObjectBtn');
                console.log('Element removeObjectBtn:', this.elements.removeObjectBtn ? 'found' : 'NOT found');
                this.elements.objectPropertiesPanel = document.getElementById('objectProperties');
                console.log('Element objectPropertiesPanel:', this.elements.objectPropertiesPanel ? 'found' : 'NOT found');
                this.elements.objectColorInput = document.getElementById('objectColor');
                console.log('Element objectColorInput:', this.elements.objectColorInput ? 'found' : 'NOT found');
                this.elements.posXInput = document.getElementById('posX');
                console.log('Element posXInput:', this.elements.posXInput ? 'found' : 'NOT found');
                this.elements.posYInput = document.getElementById('posY');
                console.log('Element posYInput:', this.elements.posYInput ? 'found' : 'NOT found');
                this.elements.posZInput = document.getElementById('posZ');
                console.log('Element posZInput:', this.elements.posZInput ? 'found' : 'NOT found');
                this.elements.rotXInput = document.getElementById('rotX');
                console.log('Element rotXInput:', this.elements.rotXInput ? 'found' : 'NOT found');
                this.elements.rotYInput = document.getElementById('rotY');
                console.log('Element rotYInput:', this.elements.rotYInput ? 'found' : 'NOT found');
                this.elements.rotZInput = document.getElementById('rotZ');
                console.log('Element rotZInput:', this.elements.rotZInput ? 'found' : 'NOT found');
                this.elements.resetSceneBtnSide = document.getElementById('resetSceneBtnSide');
                console.log('Element resetSceneBtnSide:', this.elements.resetSceneBtnSide ? 'found' : 'NOT found');
                this.elements.generateCodeBtn = document.getElementById('generateCodeBtn');
                console.log('Element generateCodeBtn:', this.elements.generateCodeBtn ? 'found' : 'NOT found');
                this.elements.printBtn = document.getElementById('printBtn');
                console.log('Element printBtn:', this.elements.printBtn ? 'found' : 'NOT found');
                this.elements.copyCodeBtn = document.getElementById('copyCodeBtn');
                console.log('Element copyCodeBtn:', this.elements.copyCodeBtn ? 'found' : 'NOT found');
                this.elements.exportDXFBtn = document.getElementById('exportDXFBtn');
                console.log('Element exportDXFBtn:', this.elements.exportDXFBtn ? 'found' : 'NOT found');
                this.elements.exportPDFBtn = document.getElementById('exportPDFBtn');
                console.log('Element exportPDFBtn:', this.elements.exportPDFBtn ? 'found' : 'NOT found');
                this.elements.generatedCodePre = document.getElementById('generatedCode');
                console.log('Element generatedCodePre:', this.elements.generatedCodePre ? 'found' : 'NOT found');
                this.elements.exportStatusDiv = document.getElementById('export-status');
                console.log('Element exportStatusDiv:', this.elements.exportStatusDiv ? 'found' : 'NOT found');

                // Toolbar buttons
                this.elements.setupBaseBtn = document.getElementById('setupBaseBtn');
                console.log('Element setupBaseBtn:', this.elements.setupBaseBtn ? 'found' : 'NOT found');
                this.elements.materialsBtn = document.getElementById('materialsBtn');
                console.log('Element materialsBtn:', this.elements.materialsBtn ? 'found' : 'NOT found');
                this.elements.paintBucketBtn = document.getElementById('paintBucketBtn');
                console.log('Element paintBucketBtn:', this.elements.paintBucketBtn ? 'found' : 'NOT found');
                this.elements.lightsBtn = document.getElementById('lightsBtn');
                console.log('Element lightsBtn:', this.elements.lightsBtn ? 'found' : 'NOT found');
                this.elements.importBtn = document.getElementById('importBtn');
                console.log('Element importBtn:', this.elements.importBtn ? 'found' : 'NOT found');
                this.elements.objInputHidden = document.getElementById('objInputHidden');
                console.log('Element objInputHidden:', this.elements.objInputHidden ? 'found' : 'NOT found');
                this.elements.mtlInputHidden = document.getElementById('mtlInputHidden');
                console.log('Element mtlInputHidden:', this.elements.mtlInputHidden ? 'found' : 'NOT found');
                this.elements.textureInputHidden = document.getElementById('textureInputHidden');
                console.log('Element textureInputHidden:', this.elements.textureInputHidden ? 'found' : 'NOT found');
                this.elements.controlsBtn = document.getElementById('controlsBtn');
                console.log('Element controlsBtn:', this.elements.controlsBtn ? 'found' : 'NOT found');
                this.elements.performanceBtn = document.getElementById('performanceBtn');
                console.log('Element performanceBtn:', this.elements.performanceBtn ? 'found' : 'NOT found');
                this.elements.infoBtn = document.getElementById('infoBtn');
                console.log('Element infoBtn:', this.elements.infoBtn ? 'found' : 'NOT found');
                this.elements.geometriesDropdownBtn = document.getElementById('geometriesDropdownBtn');
                console.log('Element geometriesDropdownBtn:', this.elements.geometriesDropdownBtn ? 'found' : 'NOT found');
                this.elements.templatesDropdownBtn = document.getElementById('templatesDropdownBtn');
                console.log('Element templatesDropdownBtn:', this.elements.templatesDropdownBtn ? 'found' : 'NOT found');

                // Toolbar Geometries Dropdown
                this.elements.lineToolBtnToolbar = document.getElementById('lineToolBtnToolbar');
                console.log('Element lineToolBtnToolbar:', this.elements.lineToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.polylineToolBtnToolbar = document.getElementById('polylineToolBtnToolbar');
                console.log('Element polylineToolBtnToolbar:', this.elements.polylineToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.circleToolBtnToolbar = document.getElementById('circleToolBtnToolbar');
                console.log('Element circleToolBtnToolbar:', this.elements.circleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.arcToolBtnToolbar = document.getElementById('arcToolBtnToolbar');
                console.log('Element arcToolBtnToolbar:', this.elements.arcToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.triangleToolBtnToolbar = document.getElementById('triangleToolBtnToolbar');
                console.log('Element triangleToolBtnToolbar:', this.elements.triangleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.rectangleToolBtnToolbar = document.getElementById('rectangleToolBtnToolbar');
                console.log('Element rectangleToolBtnToolbar:', this.elements.rectangleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.addCubeBtnToolbar = document.getElementById('addCubeBtnToolbar');
                console.log('Element addCubeBtnToolbar:', this.elements.addCubeBtnToolbar ? 'found' : 'NOT found');
                this.elements.addSphereBtnToolbar = document.getElementById('addSphereBtnToolbar');
                console.log('Element addSphereBtnToolbar:', this.elements.addSphereBtnToolbar ? 'found' : 'NOT found');
                this.elements.addCylinderBtnToolbar = document.getElementById('addCylinderBtnToolbar');
                console.log('Element addCylinderBtnToolbar:', this.elements.addCylinderBtnToolbar ? 'found' : 'NOT found');

                // Toolbar Templates Dropdown
                this.elements.applyWoodMaterialBtn = document.getElementById('applyWoodMaterialBtn');
                console.log('Element applyWoodMaterialBtn:', this.elements.applyWoodMaterialBtn ? 'found' : 'NOT found');
                this.elements.applyMarbleMaterialBtn = document.getElementById('applyMarbleMaterialBtn');
                console.log('Element applyMarbleMaterialBtn:', this.elements.applyMarbleMaterialBtn ? 'found' : 'NOT found');
                this.elements.applyMetalMaterialBtn = document.getElementById('applyMetalMaterialBtn');
                console.log('Element applyMetalMaterialBtn:', this.elements.applyMetalMaterialBtn ? 'found' : 'NOT found');
                this.elements.addChairBtnToolbar = document.getElementById('addChairBtnToolbar');
                console.log('Element addChairBtnToolbar:', this.elements.addChairBtnToolbar ? 'found' : 'NOT found');
                this.elements.addTableBtnToolbar = document.getElementById('addTableBtnToolbar');
                console.log('Element addTableBtnToolbar:', this.elements.addTableBtnToolbar ? 'found' : 'NOT found');
                this.elements.addEmptyRoomBtnToolbar = document.getElementById('addEmptyRoomBtnToolbar');
                console.log('Element addEmptyRoomBtnToolbar:', this.elements.addEmptyRoomBtnToolbar ? 'found' : 'NOT found');

                this.elements.showGridBtn = document.getElementById('showGridBtn');
                console.log('Element showGridBtn:', this.elements.showGridBtn ? 'found' : 'NOT found');
                this.elements.hideGridBtn = document.getElementById('hideGridBtn');
                console.log('Element hideGridBtn:', this.elements.hideGridBtn ? 'found' : 'NOT found');

                this.elements.lineDrawingOptions = document.getElementById('lineDrawingOptions');
                console.log('Element lineDrawingOptions:', this.elements.lineDrawingOptions ? 'found' : 'NOT found');
                this.elements.circleDrawingOptions = document.getElementById('circleDrawingOptions');
                console.log('Element circleDrawingOptions:', this.elements.circleDrawingOptions ? 'found' : 'NOT found');
                this.elements.arcDrawingOptions = document.getElementById('arcDrawingOptions');
                console.log('Element arcDrawingOptions:', this.elements.arcDrawingOptions ? 'found' : 'NOT found');
                this.elements.rectangleDrawingOptions = document.getElementById('rectangleDrawingOptions');
                console.log('Element rectangleDrawingOptions:', this.elements.rectangleDrawingOptions ? 'found' : 'NOT found');
                this.elements.triangleDrawingOptions = document.getElementById('triangleDrawingOptions');
                console.log('Element triangleDrawingOptions:', this.elements.triangleDrawingOptions ? 'found' : 'NOT found');

                this.elements.lineLengthInput = document.getElementById('lineLengthInput');
                console.log('Element lineLengthInput:', this.elements.lineLengthInput ? 'found' : 'NOT found');
                this.elements.circleRadiusInput = document.getElementById('circleRadiusInput');
                console.log('Element circleRadiusInput:', this.elements.circleRadiusInput ? 'found' : 'NOT found');
                this.elements.arcRadiusInput = document.getElementById('arcRadiusInput');
                console.log('Element arcRadiusInput:', this.elements.arcRadiusInput ? 'found' : 'NOT found');
                this.elements.arcStartAngleInput = document.getElementById('arcStartAngleInput');
                console.log('Element arcStartAngleInput:', this.elements.arcStartAngleInput ? 'found' : 'NOT found');
                this.elements.arcEndAngleInput = document.getElementById('arcEndAngleInput');
                console.log('Element arcEndAngleInput:', this.elements.arcEndAngleInput ? 'found' : 'NOT found');
                this.elements.arcClockwiseInput = document.getElementById('arcClockwiseInput');
                console.log('Element arcClockwiseInput:', this.elements.arcClockwiseInput ? 'found' : 'NOT found');
                this.elements.rectWidthInput = document.getElementById('rectWidthInput');
                console.log('Element rectWidthInput:', this.elements.rectWidthInput ? 'found' : 'NOT found');
                this.elements.rectHeightInput = document.getElementById('rectHeightInput');
                console.log('Element rectHeightInput:', this.elements.rectHeightInput ? 'found' : 'NOT found');
                this.elements.triBaseInput = document.getElementById('triBaseInput');
                console.log('Element triBaseInput:', this.elements.triBaseInput ? 'found' : 'NOT found');
                this.elements.triHeightInput = document.getElementById('triHeightInput');
                console.log('Element triHeightInput:', this.elements.triHeightInput ? 'found' : 'NOT found');

                this.elements.cubeOptions = document.getElementById('cubeOptions');
                console.log('Element cubeOptions:', this.elements.cubeOptions ? 'found' : 'NOT found');
                this.elements.sphereOptions = document.getElementById('sphereOptions');
                console.log('Element sphereOptions:', this.elements.sphereOptions ? 'found' : 'NOT found');
                this.elements.cylinderOptions = document.getElementById('cylinderOptions');
                console.log('Element cylinderOptions:', this.elements.cylinderOptions ? 'found' : 'NOT found');
                this.elements.addBasicShapeBtn = document.getElementById('addBasicShapeBtn');
                console.log('Element addBasicShapeBtn:', this.elements.addBasicShapeBtn ? 'found' : 'NOT found');
            }

            addEventListeners() {
                // Mode buttons
                if (this.elements.viewModeBtn) {
                    this.elements.viewModeBtn.addEventListener('click', () => {
                        this.drawingManager.setDrawingMode(false);
                        this.objectManager.setPaintBucketMode(false);
                        this.updateUI();
                    });
                } else {
                    console.error("UIManager: viewModeBtn not found, cannot attach event listener.");
                }
                if (this.elements.drawModeBtn) {
                    this.elements.drawModeBtn.addEventListener('click', () => {
                        this.drawingManager.setDrawingMode(true);
                        this.objectManager.setPaintBucketMode(false);
                        this.objectManager.selectObject(null); // Deselect any object in drawing mode
                        this.updateUI();
                        this.drawingManager.clearDrawing(true); // Clear and save initial state for undo
                    });
                } else {
                    console.error("UIManager: drawModeBtn not found, cannot attach event listener.");
                }

                // View preset buttons
                if (this.elements.viewTopBtn) this.elements.viewTopBtn.addEventListener('click', () => this.sceneManager.setPresetView('top'));
                if (this.elements.viewFrontBtn) this.elements.viewFrontBtn.addEventListener('click', () => this.sceneManager.setPresetView('front'));
                if (this.elements.viewRightBtn) this.elements.viewRightBtn.addEventListener('click', () => this.sceneManager.setPresetView('right'));
                if (this.elements.viewIsoBtn) this.elements.viewIsoBtn.addEventListener('click', () => this.sceneManager.setPresetView('iso'));

                // Solid/Wireframe view buttons
                if (this.elements.solidViewBtn) {
                    this.elements.solidViewBtn.addEventListener('click', () => {
                        this.sceneManager.setWireframeMode(false);
                        this.updateUI();
                    });
                }
                if (this.elements.wireframeViewBtn) {
                    this.elements.wireframeViewBtn.addEventListener('click', () => {
                        this.sceneManager.setWireframeMode(true);
                        this.updateUI();
                    });
                }

                // Grid visibility buttons
                if (this.elements.showGridBtn) {
                    this.elements.showGridBtn.addEventListener('click', () => {
                        this.sceneManager.setGridVisibility(true);
                        this.updateUI();
                    });
                }
                if (this.elements.hideGridBtn) {
                    this.elements.hideGridBtn.addEventListener('click', () => {
                        this.sceneManager.setGridVisibility(false);
                        this.updateUI();
                    });
                }

                // Toolbar buttons
                if (this.elements.setupBaseBtn) this.elements.setupBaseBtn.addEventListener('click', () => this.sceneManager.resetScene());
                if (this.elements.materialsBtn) {
                    this.elements.materialsBtn.addEventListener('click', () => {
                        this.objectManager.setPaintBucketMode(false);
                        this.updateUI();
                        if (this.objectManager.selectedObject) {
                            this.objectManager.selectObject(this.objectManager.selectedObject); // Re-select to update panel
                            this.elements.objectPropertiesPanel.classList.remove('hidden');
                        } else {
                            UIManager.showModalMessage("Materials", "Select an object to modify its material.");
                        }
                    });
                }
                if (this.elements.paintBucketBtn) {
                    this.elements.paintBucketBtn.addEventListener('click', () => {
                        this.objectManager.togglePaintBucketMode();
                        this.drawingManager.setDrawingMode(false);
                        this.objectManager.selectObject(null);
                        this.updateUI();
                        UIManager.showModalMessage("Paint Bucket Mode", this.objectManager.paintBucketMode ? "Paint Bucket mode activated. Click on an object to color it." : "Paint Bucket mode deactivated.");
                    });
                }
                if (this.elements.lightsBtn) this.elements.lightsBtn.addEventListener('click', () => UIManager.showModalMessage("Feature Not Available", "Light management is not yet implemented."));
                if (this.elements.importBtn) this.elements.importBtn.addEventListener('click', () => this.objectManager.startImportSequence());
                if (this.elements.objInputHidden) this.elements.objInputHidden.addEventListener('change', (e) => this.objectManager.handleObjFileSelection(e.target.files[0]));
                if (this.elements.mtlInputHidden) this.elements.mtlInputHidden.addEventListener('change', (e) => this.objectManager.handleMtlFileSelection(e.target.files[0]));
                if (this.elements.textureInputHidden) this.elements.textureInputHidden.addEventListener('change', (e) => this.objectManager.handleTextureFileSelection(Array.from(e.target.files)));
                if (this.elements.controlsBtn) this.elements.controlsBtn.addEventListener('click', () => UIManager.showModalMessage("Feature Not Available", "Advanced controls not yet implemented. Use mouse to orbit."));
                if (this.elements.performanceBtn) this.elements.performanceBtn.addEventListener('click', () => UIManager.showModalMessage("Feature Not Available", "Performance optimization options not yet implemented."));
                if (this.elements.infoBtn) this.elements.infoBtn.addEventListener('click', () => this.showInfoModal());

                // Geometries Dropdown
                if (this.elements.lineToolBtnToolbar) this.elements.lineToolBtnToolbar.addEventListener('click', () => this.drawingManager.setCurrentDrawingTool('line'));
                if (this.elements.polylineToolBtnToolbar) this.elements.polylineToolBtnToolbar.addEventListener('click', () => this.drawingManager.setCurrentDrawingTool('polyline'));
                if (this.elements.circleToolBtnToolbar) this.elements.circleToolBtnToolbar.addEventListener('click', () => this.drawingManager.setCurrentDrawingTool('circle'));
                if (this.elements.arcToolBtnToolbar) this.elements.arcToolBtnToolbar.addEventListener('click', () => this.drawingManager.setCurrentDrawingTool('arc'));
                if (this.elements.triangleToolBtnToolbar) this.elements.triangleToolBtnToolbar.addEventListener('click', () => this.drawingManager.setCurrentDrawingTool('triangle'));
                if (this.elements.rectangleToolBtnToolbar) this.elements.rectangleToolBtnToolbar.addEventListener('click', () => this.drawingManager.setCurrentDrawingTool('rectangle'));
                if (this.elements.addCubeBtnToolbar) this.elements.addCubeBtnToolbar.addEventListener('click', () => this.objectManager.addBasic3DShape('cube'));
                if (this.elements.addSphereBtnToolbar) this.elements.addSphereBtnToolbar.addEventListener('click', () => this.objectManager.addBasic3DShape('sphere'));
                if (this.elements.addCylinderBtnToolbar) this.elements.addCylinderBtnToolbar.addEventListener('click', () => this.objectManager.addBasic3DShape('cylinder'));

                // Templates Dropdown
                if (this.elements.applyWoodMaterialBtn) this.elements.applyWoodMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.woodMaterial, 'Wood'));
                if (this.elements.applyMarbleMaterialBtn) this.elements.applyMarbleMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.marbleMaterial, 'Marble'));
                if (this.elements.applyMetalMaterialBtn) this.elements.applyMetalMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.metalMaterial, 'Metal'));
                if (this.elements.addChairBtnToolbar) this.elements.addChairBtnToolbar.addEventListener('click', () => this.objectManager.addChair());
                if (this.elements.addTableBtnToolbar) this.elements.addTableBtnToolbar.addEventListener('click', () => this.objectManager.addTable());
                if (this.elements.addEmptyRoomBtnToolbar) this.elements.addEmptyRoomBtnToolbar.addEventListener('click', () => this.objectManager.addEmptyRoom());

                // Drawing and Extrusion controls
                if (this.elements.closePathBtn) this.elements.closePathBtn.addEventListener('click', () => this.drawingManager.closePath());
                if (this.elements.undoDrawingBtn) this.elements.undoDrawingBtn.addEventListener('click', () => this.drawingManager.undoDrawing());
                if (this.elements.extrudeBtn) this.elements.extrudeBtn.addEventListener('click', () => this.drawingManager.extrudeShape(parseFloat(this.elements.extrusionDepthInput.value)));

                // Object management controls
                if (this.elements.removeObjectBtn) this.elements.removeObjectBtn.addEventListener('click', () => this.objectManager.removeSelectedObject());
                if (this.elements.resetSceneBtnSide) this.elements.resetSceneBtnSide.addEventListener('click', () => this.sceneManager.resetScene());
                if (this.elements.generateCodeBtn) this.elements.generateCodeBtn.addEventListener('click', () => this.generateThreeJsCode());
                if (this.elements.copyCodeBtn) this.elements.copyCodeBtn.addEventListener('click', () => this.copyGeneratedCode());
                if (this.elements.printBtn) this.elements.printBtn.addEventListener('click', () => window.print());
                if (this.elements.exportDXFBtn) this.elements.exportDXFBtn.addEventListener('click', () => this.exportManager.exportDXF());
                if (this.elements.exportPDFBtn) this.elements.exportPDFBtn.addEventListener('click', () => this.exportManager.handleExport());

                // Object properties controls
                if (this.elements.objectColorInput) this.elements.objectColorInput.addEventListener('input', () => this.objectManager.updateSelectedObjectColor(this.elements.objectColorInput.value));
                if (this.elements.posXInput) this.elements.posXInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('x', parseFloat(this.elements.posXInput.value)));
                if (this.elements.posYInput) this.elements.posYInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('y', parseFloat(this.elements.posYInput.value)));
                if (this.elements.posZInput) this.elements.posZInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('z', parseFloat(this.elements.posZInput.value)));
                if (this.elements.rotXInput) this.elements.rotXInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('x', parseFloat(this.elements.rotXInput.value)));
                if (this.elements.rotYInput) this.elements.rotYInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('y', parseFloat(this.elements.rotYInput.value)));
                if (this.elements.rotZInput) this.elements.rotZInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('z', parseFloat(this.elements.rotZInput.value)));

                // Object selection dropdown
                if (this.elements.selectedObjectSelect) {
                    this.elements.selectedObjectSelect.addEventListener('change', () => {
                        const uuid = this.elements.selectedObjectSelect.value;
                        const obj = this.objectManager.objects.find(o => o.uuid === uuid);
                        this.objectManager.selectObject(obj);
                    });
                }

                // Keyboard shortcuts
                document.addEventListener('keydown', (event) => {
                    if (event.ctrlKey && event.key === 'z') {
                        event.preventDefault(); // Prevent browser undo
                        this.drawingManager.undoDrawing();
                    }
                });
            }

            updateUI() {
                // Update mode buttons
                if (this.elements.viewModeBtn) {
                    this.elements.viewModeBtn.classList.toggle('bg-blue-600', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('text-white', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('shadow-md', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('text-gray-700', this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('hover:bg-gray-200', this.drawingManager.drawingMode);
                }

                if (this.elements.drawModeBtn) {
                    this.elements.drawModeBtn.classList.toggle('bg-blue-600', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('text-white', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('shadow-md', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('text-gray-700', !this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('hover:bg-gray-200', !this.drawingManager.drawingMode);
                }

                // Show/hide control panels based on mode
                if (this.elements.viewControlsPanel) this.elements.viewControlsPanel.classList.toggle('hidden', this.drawingManager.drawingMode);
                if (this.elements.drawingControls) this.elements.drawingControls.classList.toggle('hidden', !this.drawingManager.drawingMode);
                if (this.elements.basic3DShapeControls) this.elements.basic3DShapeControls.classList.toggle('hidden', this.drawingManager.drawingMode);
                if (this.elements.extrusionControls) this.elements.extrusionControls.classList.add('hidden'); // Always hide initially, shown by drawing manager

                // Object properties panel visibility
                if (this.elements.objectPropertiesPanel) this.elements.objectPropertiesPanel.classList.toggle('hidden', !this.objectManager.selectedObject || this.drawingManager.drawingMode);

                // Update drawing tool options visibility
                [this.elements.lineDrawingOptions, this.elements.circleDrawingOptions, this.elements.arcDrawingOptions, this.elements.rectangleDrawingOptions, this.elements.triangleDrawingOptions].forEach(opt => {
                    if (opt) opt.classList.add('hidden');
                });

                if (this.drawingManager.drawingMode) {
                    if (this.drawingManager.currentDrawingTool === 'line' || this.drawingManager.currentDrawingTool === 'polyline') {
                        if (this.elements.lineDrawingOptions) this.elements.lineDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.toggle('hidden', !(this.drawingManager.currentDrawingTool === 'polyline' && this.drawingManager.drawnPoints.length >= 3));
                    } else if (this.drawingManager.currentDrawingTool === 'circle') {
                        if (this.elements.circleDrawingOptions) this.elements.circleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'arc') {
                        if (this.elements.arcDrawingOptions) this.elements.arcDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'rectangle') {
                        if (this.elements.rectangleDrawingOptions) this.elements.rectangleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'triangle') {
                        if (this.elements.triangleDrawingOptions) this.elements.triangleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    }
                }

                // Update basic 3D shape tool options visibility
                [this.elements.cubeOptions, this.elements.sphereOptions, this.elements.cylinderOptions].forEach(opt => {
                    if (opt) opt.classList.add('hidden');
                });
                if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.add('hidden');

                if (!this.drawingManager.drawingMode && this.objectManager.currentBasic3DShapeTool) {
                    if (this.objectManager.currentBasic3DShapeTool === 'cube') {
                        if (this.elements.cubeOptions) this.elements.cubeOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    } else if (this.objectManager.currentBasic3DShapeTool === 'sphere') {
                        if (this.elements.sphereOptions) this.elements.sphereOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    } else if (this.objectManager.currentBasic3DShapeTool === 'cylinder') {
                        if (this.elements.cylinderOptions) this.elements.cylinderOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    }
                }

                // Update solid/wireframe buttons
                if (this.elements.solidViewBtn) {
                    this.elements.solidViewBtn.classList.toggle('bg-blue-600', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('text-white', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('shadow-md', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('text-gray-700', this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.isWireframe);
                }

                if (this.elements.wireframeViewBtn) {
                    this.elements.wireframeViewBtn.classList.toggle('bg-blue-600', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('text-white', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('shadow-md', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('text-gray-700', !this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('hover:bg-gray-200', !this.sceneManager.isWireframe);
                }

                // Update grid visibility buttons
                if (this.elements.showGridBtn) {
                    this.elements.showGridBtn.classList.toggle('bg-blue-600', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('text-white', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('shadow-md', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('text-gray-700', !this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('hover:bg-gray-200', !this.sceneManager.isGridVisible);
                }

                if (this.elements.hideGridBtn) {
                    this.elements.hideGridBtn.classList.toggle('bg-blue-600', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('text-white', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('shadow-md', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('text-gray-700', this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.isGridVisible);
                }

                // Update toolbar active states (only paint bucket for now)
                [this.elements.setupBaseBtn, this.elements.materialsBtn, this.elements.paintBucketBtn, this.elements.lightsBtn, this.elements.importBtn, this.elements.controlsBtn, this.elements.performanceBtn, this.elements.infoBtn, this.elements.geometriesDropdownBtn, this.elements.templatesDropdownBtn].forEach(btn => {
                    if (btn) btn.classList.remove('active');
                });
                if (this.elements.paintBucketBtn && this.objectManager.paintBucketMode) {
                    this.elements.paintBucketBtn.classList.add('active');
                }

                // Update drawn points count
                if (this.elements.drawnPointsCount) {
                    this.elements.drawnPointsCount.textContent = this.drawingManager.drawnPoints.length;
                }
            }

            // Static method for modal messages
            static showModalMessage(title, message) {
                const modalBackdrop = document.createElement('div');
                modalBackdrop.className = 'modal-backdrop';
                modalBackdrop.id = 'customModal';

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.innerHTML = `
                    <h3 class="font-bold">${title}</h3>
                    <p>${message}</p>
                    <button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove()">Close</button>
                `;

                modalBackdrop.appendChild(modalContent);
                document.body.appendChild(modalBackdrop);
            }

            // Static method for floating status messages
            static showStatus(text, isError = false) {
                const el = document.getElementById('export-status');
                if (el) {
                    el.textContent = text;
                    el.style.display = 'block';
                    el.style.backgroundColor = isError ? '#c0392b' : '#2c3e50';
                    setTimeout(() => el.style.display = 'none', 3000);
                }
            }

            showInfoModal() {
                const infoContent = `
                    <h3 class="font-bold text-gray-800">Guida all'Uso del Modellatore 3D</h3>
                    <p class="text-left text-gray-700 mb-4">Benvenuto! Ecco una guida rapida all'uso dei vari strumenti:</p>
                    <div class="text-left text-gray-700 text-sm">
                        <p class="mb-2"><strong>🛠️ Setup Base:</strong> Resetta l'intera scena, rimuovendo tutti gli oggetti e il disegno 2D.</p>
                        <p class="mb-2"><strong>🧊 Geometrie:</strong> Questo menu ti permette di selezionare strumenti per il disegno 2D o per aggiungere forme 3D di base:</p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>**Linea, Polilinea, Cerchio, Arco, Triangolo, Rettangolo:** Strumenti per disegnare forme 2D sul piano. Una volta disegnate, puoi estruderle.</li>
                            <li>**Cubo, Sfera, Cilindro:** Aggiunge direttamente queste forme 3D predefinite alla scena.</li>
                        </ul>
                        <p class="mb-2"><strong>🎨 Materiali:</strong> Seleziona un oggetto nella scena e usa il pannello laterale "Proprietà Oggetto" per cambiare il suo colore. Puoi anche applicare materiali predefiniti dal menu "Template".</p>
                        <p class="mb-2"><strong>🖌️ Applica Materiale:</strong> Attiva la modalità "secchiello di vernice". Clicca su qualsiasi oggetto nella scena per applicare il colore corrente selezionato nel pannello delle proprietà.</p>
                        <p class="mb-2"><strong>💡 Luci:</strong> Funzionalità per la gestione dell'illuminazione (non ancora implementata).</p>
                        <p class="mb-2"><strong>📦 Importa:</strong> Ti permette di caricare modelli 3D esterni nei formati `.gltf`, `.glb` o `.obj` nella scena.</p>
                        <p class="mb-2"><strong>🪑 Template:</strong> Questo menu offre materiali predefiniti (Legno, Marmo, Metallo) da applicare agli oggetti selezionati e oggetti di interior design pre-assemblati (Sedia, Tavolo, Stanza Vuota).</p>
                        <p class="mb-2"><strong>✋ Controlli:</strong> Informazioni sui controlli di navigazione (non ancora implementata).</p>
                        <p class="mb-2"><strong>⚡ Performance:</strong> Opzioni di ottimizzazione del rendering (non ancora implementata).</p>
                        <p class="mb-2"><strong>ℹ️ Info:</strong> Mostra questa finestra di aiuto.</p>
                        <p class="mt-4"><strong>Modalità Vista/Disegno (Pannello Laterale):</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>**Vista:** Ti permette di orbitare, zoomare e spostare la telecamera per visualizzare la scena 3D.</li>
                            <li>**Disegno:** Attiva il piano di disegno 2D per creare forme che possono poi essere estruse.</li>
                        </ul>
                        <p class="mt-4"><strong>Controlli Generali:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>**Mouse:** Clicca e trascina per orbitare (modalità Vista) o per disegnare (modalità Disegno).</li>
                            <li>**Rotellina del mouse:** Zoom.</li>
                            <li>**Ctrl + Z:** Annulla l'ultima operazione di disegno 2D.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Importazione OBJ+Texture:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>I file `.mtl` devono usare nomi semplici per le texture (es. "diffuse.jpg" invece di "./textures/diffuse.jpg").</li>
                            <li>Le dimensioni massime dei file sono limitate dalla memoria del browser.</li>
                            <li>Per modelli molto complessi (>50MB) potrebbero esserci problemi di prestazioni o di caricamento.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Esportazione DXF:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>Supporta principalmente solo entità geometriche di base (punti, linee, polilinee). Spline, curve NURBS, testo, dimensioni e altre entità CAD complesse **non sono supportate** direttamente e vengono convertite in linee o saltate.</li>
                            <li>Le texture e i materiali **non vengono esportati** (il DXF è principalmente un formato geometrico). I colori vengono mappati a indici colore DXF standard.</li>
                            <li>Per oggetti complessi o modelli importati, la geometria viene convertita in bordi (linee) per l'esportazione. Questo può risultare in file DXF molto grandi o con dettagli eccessivi. Considera di semplificare la geometria prima dell'esportazione per ottenere un file DXF più gestibile.</li>
                            <li>I gruppi di oggetti Three.js vengono esportati come "blocchi" DXF, migliorando l'organizzazione del file.</li>
                            <li>La scala di esportazione è configurabile (default: 1 unità Three.js = 1 millimetro DXF).</li>
                            <li>La precisione decimale delle coordinate è configurabile per bilanciare fedeltà e dimensione del file.</li>
                            <li>Questa è un'implementazione lato client e potrebbe non essere compatibile con tutte le versioni di software CAD o supportare tutte le specifiche DXF.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Esportazione PDF:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>L'esportazione PDF genera un'immagine raster (non vettoriale) della vista corrente del canvas.</li>
                            <li>La qualità dell'immagine dipenderà dalla risoluzione del canvas e dalle impostazioni del renderer.</li>
                            <li>Non è un'esportazione CAD vettoriale, ma una "istantanea" visiva.</li>
                            <li>Il caricamento della libreria jsPDF avviene solo al momento del click per ottimizzare le prestazioni iniziali.</li>
                        </ul>
                    </div>
                `;
                UIManager.showModalMessage("Information on Usage", infoContent);
            }

            generateThreeJsCode() {
                const code = this.objectManager.generateThreeJsCode();
                this.elements.generatedCodePre.textContent = code;
                UIManager.showModalMessage("Code Generated", "The Three.js code of your scene has been generated and displayed below. You can copy it and use it in a Three.js project!");
            }

            copyGeneratedCode() {
                const codeToCopy = this.elements.generatedCodePre.textContent;
                const textArea = document.createElement('textarea');
                textArea.value = codeToCopy;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    UIManager.showModalMessage("Copied!", "Three.js code copied to clipboard.");
                } catch (err) {
                    UIManager.showModalMessage("Error", "Could not copy code. Your browser might not support this feature in an iframe environment.");
                }
                document.body.removeChild(textArea);
            }

            updateSelectedObjectOptions(objects, selectedObject) {
                if (this.elements.selectedObjectSelect) {
                    this.elements.selectedObjectSelect.innerHTML = '<option value="">None</option>';
                    objects.forEach(obj => {
                        const option = document.createElement('option');
                        option.value = obj.uuid;
                        option.textContent = obj.name;
                        this.elements.selectedObjectSelect.appendChild(option);
                    });
                    if (selectedObject) {
                        this.elements.selectedObjectSelect.value = selectedObject.uuid;
                    }
                }
            }

            updatePropertiesPanel(selectedObject) {
                if (selectedObject && this.elements.objectColorInput && this.elements.posXInput && this.elements.posYInput && this.elements.posZInput && this.elements.rotXInput && this.elements.rotYInput && this.elements.rotZInput) {
                    let currentMaterial = null;
                    if (selectedObject instanceof THREE.Group && selectedObject.children.length > 0) {
                        const meshChild = selectedObject.children.find(child => child instanceof THREE.Mesh && child.material);
                        if (meshChild) {
                            currentMaterial = meshChild.material;
                        }
                    } else if (selectedObject.material instanceof THREE.MeshStandardMaterial || selectedObject.material instanceof THREE.MeshBasicMaterial) {
                        currentMaterial = selectedObject.material;
                    } else if (Array.isArray(selectedObject.material) && selectedObject.material.length > 0) {
                        currentMaterial = selectedObject.material[0];
                    }

                    if (currentMaterial && currentMaterial.color) {
                        this.elements.objectColorInput.value = '#' + currentMaterial.color.getHexString();
                    } else {
                        this.elements.objectColorInput.value = '#3b82f6';
                    }
                    
                    this.elements.posXInput.value = (selectedObject.position.x / this.sceneManager.UNIT_SCALE).toFixed(2);
                    this.elements.posYInput.value = (selectedObject.position.y / this.sceneManager.UNIT_SCALE).toFixed(2);
                    this.elements.posZInput.value = (selectedObject.position.z / this.sceneManager.UNIT_SCALE).toFixed(2);
                    this.elements.rotXInput.value = THREE.MathUtils.radToDeg(selectedObject.rotation.x).toFixed(0);
                    this.elements.rotYInput.value = THREE.MathUtils.radToDeg(selectedObject.rotation.y).toFixed(0);
                    this.elements.rotZInput.value = THREE.MathUtils.radToDeg(selectedObject.rotation.z).toFixed(0);
                }
            }

            updateExtrusionControlsVisibility(isVisible) {
                if (this.elements.extrusionControls) {
                    this.elements.extrusionControls.classList.toggle('hidden', !isVisible);
                }
            }
        }

        // === SceneManager Class ===
        class SceneManager {
            constructor(canvasContainer) {
                this.canvasContainer = canvasContainer;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.gridHelper = null;
                this.axesHelper = null;
                this.drawingPlane = null;

                this.isWireframe = false;
                this.isGridVisible = true;
                this.UNIT_SCALE = 1; // 1 Three.js unit = 1 cm
                this.SNAP_TOLERANCE = 0.5; // Tolerance for snapping to axes in drawing mode

                this.initScene();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x282c34);

                this.camera = new THREE.PerspectiveCamera(75, this.canvasContainer.clientWidth / this.canvasContainer.clientHeight, 0.1, 1000);
                this.camera.position.set(5, 5, 5);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.canvasContainer.appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 500;
                this.controls.update();

                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1, 1, 1).normalize();
                this.scene.add(directionalLight);

                this.gridHelper = new THREE.GridHelper(100, 100, 0x000000, 0x888888);
                this.scene.add(this.gridHelper);

                this.axesHelper = new THREE.AxesHelper(5);
                this.scene.add(this.axesHelper);

                const planeGeometry = new THREE.PlaneGeometry(200, 200);
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.15 });
                this.drawingPlane = new THREE.Mesh(planeGeometry, planeMaterial);
                this.drawingPlane.rotation.x = -Math.PI / 2;
                this.drawingPlane.position.y = -0.01;
                this.scene.add(this.drawingPlane);

                window.addEventListener('resize', () => this.onWindowResize(), false);
            }

            onWindowResize() {
                this.camera.aspect = this.canvasContainer.clientWidth / this.canvasContainer.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
                this.controls.update();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            setWireframeMode(isWireframe) {
                this.isWireframe = isWireframe;
                // ObjectManager will update object materials
            }

            setGridVisibility(isVisible) {
                this.isGridVisible = isVisible;
                if (this.gridHelper) this.gridHelper.visible = isVisible;
            }

            setPresetView(view) {
                const distance = this.camera.position.distanceTo(this.controls.target);
                let targetPosition = new THREE.Vector3(0, 0, 0);
                this.controls.target.copy(targetPosition);

                switch (view) {
                    case 'top':
                        this.camera.position.set(0, distance, 0);
                        break;
                    case 'front':
                        this.camera.position.set(0, 0, distance);
                        break;
                    case 'right':
                        this.camera.position.set(distance, 0, 0);
                        break;
                    case 'iso':
                        this.camera.position.set(distance, distance, distance);
                        break;
                }
                this.controls.update();
                UIManager.showModalMessage("View Changed", `View set to: ${view.charAt(0).toUpperCase() + view.slice(1)}`);
            }

            resetScene() {
                this.objectManager.objects.forEach(obj => {
                    this.scene.remove(obj);
                    disposeObject(obj);
                });
                this.objectManager.objects = [];
                this.objectManager.selectObject(null); // Deselect object
                this.drawingManager.clearDrawing(false); // Clear drawing without saving to history
                this.drawingManager.drawingHistory = []; // Clear drawing history
                this.drawingManager.historyIndex = -1;

                this.camera.position.set(5, 5, 5);
                this.controls.target.set(0, 0, 0);
                this.controls.update();

                if (this.axesHelper) this.axesHelper.visible = true;
                if (this.gridHelper) this.gridHelper.visible = this.isGridVisible;
                if (this.drawingPlane) this.drawingPlane.visible = this.drawingManager.drawingMode;

                // UIManager will handle UI updates
                UIManager.showModalMessage("Scene Reset", "The 3D scene has been reset.");
            }
        }

        // === ObjectManager Class ===
        class ObjectManager {
            constructor(sceneManager, uiManager) {
                this.sceneManager = sceneManager;
                this.uiManager = uiManager;
                this.objects = []; // Array of managed 3D objects
                this.selectedObject = null;
                this.paintBucketMode = false;
                this.currentBasic3DShapeTool = null;

                // Materiali predefiniti
                this.woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });
                this.marbleMaterial = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, roughness: 0.1 });
                this.metalMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 1.0 });
                this.floorMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.8 });

                this.currentObjFile = null;
                this.currentMtlFile = null;
                this.currentTextures = {};

                this.sceneManager.renderer.domElement.addEventListener('click', (event) => this.onCanvasClick(event), false);
            }

            togglePaintBucketMode() {
                this.paintBucketMode = !this.paintBucketMode;
                this.uiManager.updateUI();
            }

            setPaintBucketMode(mode) {
                this.paintBucketMode = mode;
                this.uiManager.updateUI();
            }

            onCanvasClick(event) {
                if (this.paintBucketMode) {
                    const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
                    const mouse = new THREE.Vector2(
                        ((event.clientX - rect.left) / rect.width) * 2 - 1,
                        -((event.clientY - rect.top) / rect.height) * 2 + 1
                    );
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, this.sceneManager.camera);

                    const intersects = raycaster.intersectObjects(this.objects, true);
                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        if (intersectedObject instanceof THREE.Mesh && intersectedObject.material) {
                            const currentColor = this.uiManager.elements.objectColorInput.value;
                            intersectedObject.material.color.set(currentColor);
                            intersectedObject.material.wireframe = this.sceneManager.isWireframe;
                            UIManager.showModalMessage("Material Applied", `Color ${currentColor} applied to ${intersectedObject.name || 'object'}.`);
                        } else {
                            UIManager.showModalMessage("No Material", "The clicked object does not have an applicable material.");
                        }
                    } else {
                        UIManager.showModalMessage("No Object", "Click on a 3D object to apply the material.");
                    }
                } else if (!this.sceneManager.drawingManager.drawingMode) {
                    const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
                    const mouse = new THREE.Vector2(
                        ((event.clientX - rect.left) / rect.width) * 2 - 1,
                        -((event.clientY - rect.top) / rect.height) * 2 + 1
                    );
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, this.sceneManager.camera);

                    const intersects = raycaster.intersectObjects(this.objects, true);
                    if (intersects.length > 0) {
                        let selected = intersects[0].object;
                        while (selected.parent && this.objects.includes(selected.parent)) {
                            selected = selected.parent;
                        }
                        this.selectObject(selected);
                    } else {
                        this.selectObject(null);
                    }
                }
            }

            selectObject(object) {
                if (this.selectedObject) {
                    if (this.selectedObject.material && this.selectedObject.material.emissive) {
                        this.selectedObject.material.emissive.setHex(0x000000);
                    } else if (this.selectedObject.children) {
                        this.selectedObject.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x000000);
                            }
                        });
                    }
                }
                this.selectedObject = object;
                if (this.selectedObject) {
                    if (this.selectedObject.material && this.selectedObject.material.emissive) {
                        this.selectedObject.material.emissive.setHex(0x222222);
                    } else if (this.selectedObject.children) {
                        this.selectedObject.children.forEach(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissive.setHex(0x222222);
                            }
                        });
                    }
                }
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updatePropertiesPanel(this.selectedObject);
                this.uiManager.updateUI(); // Update visibility of panels
            }

            updateSelectedObjectColor(colorHex) {
                if (this.selectedObject) {
                    if (this.selectedObject instanceof THREE.Group) {
                        this.selectedObject.children.forEach(child => {
                            if (child.material && child.material.color) {
                                child.material.color.set(colorHex);
                            }
                        });
                    } else if (this.selectedObject.material && this.selectedObject.material.color) {
                        this.selectedObject.material.color.set(colorHex);
                    }
                }
            }

            updateSelectedObjectPosition(axis, value) {
                if (this.selectedObject && !isNaN(value)) {
                    this.selectedObject.position[axis] = value * this.sceneManager.UNIT_SCALE;
                }
            }

            updateSelectedObjectRotation(axis, value) {
                if (this.selectedObject && !isNaN(value)) {
                    this.selectedObject.rotation[axis] = THREE.MathUtils.degToRad(value);
                }
            }

            addBasic3DShape(type) {
                let geometry;
                let meshName;
                this.currentBasic3DShapeTool = type; // Set the tool for UI update
                this.uiManager.updateUI(); // Update UI to show relevant options

                let material = new THREE.MeshStandardMaterial({ color: 0x3b82f6, wireframe: this.sceneManager.isWireframe, roughness: 0.5 });

                try {
                    if (type === 'cube') {
                        const side = parseFloat(this.uiManager.elements.cubeSideInput.value) * this.sceneManager.UNIT_SCALE;
                        if (isNaN(side) || side <= 0) throw new Error("Invalid cube side.");
                        geometry = new THREE.BoxGeometry(side, side, side);
                        meshName = `Cube_${this.objects.length + 1}`;
                        geometry.userData.type = 'box';
                        geometry.userData.side = side;
                    } else if (type === 'sphere') {
                        const radius = parseFloat(this.uiManager.elements.sphereRadiusInput.value) * this.sceneManager.UNIT_SCALE;
                        if (isNaN(radius) || radius <= 0) throw new Error("Invalid sphere radius.");
                        geometry = new THREE.SphereGeometry(radius, 32, 32);
                        meshName = `Sphere_${this.objects.length + 1}`;
                        geometry.userData.type = 'sphere';
                        geometry.userData.radius = radius;
                    } else if (type === 'cylinder') {
                        const radius = parseFloat(this.uiManager.elements.cylinderRadiusInput.value) * this.sceneManager.UNIT_SCALE;
                        const height = parseFloat(this.uiManager.elements.cylinderHeightInput.value) * this.sceneManager.UNIT_SCALE;
                        if (isNaN(radius) || radius <= 0 || isNaN(height) || height <= 0) throw new Error("Invalid cylinder radius/height.");
                        geometry = new THREE.CylinderGeometry(radius, radius, height, 32);
                        meshName = `Cylinder_${this.objects.length + 1}`;
                        geometry.userData.type = 'cylinder';
                        geometry.userData.radius = radius;
                        geometry.userData.height = height;
                    } else {
                        throw new Error("Select a basic 3D shape to add.");
                    }

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.name = meshName;
                    this.sceneManager.scene.add(mesh);
                    this.objects.push(mesh);
                    this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                    this.selectObject(mesh);
                    UIManager.showModalMessage("3D Shape Added", `${meshName} added to the scene.`);
                } catch (error) {
                    UIManager.showModalMessage("Error", `Failed to add shape: ${error.message}`);
                }
            }

            addChair() {
                const chairGroup = new THREE.Group();
                chairGroup.name = `Chair_${this.objects.length + 1}`;

                const seat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.05, 0.5), this.woodMaterial);
                seat.position.y = 0.25;
                chairGroup.add(seat);

                const legGeometry = new THREE.BoxGeometry(0.05, 0.25, 0.05);
                const leg1 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg1.position.set(-0.2, 0.125, -0.2);
                chairGroup.add(leg1);

                const leg2 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg2.position.set(0.2, 0.125, -0.2);
                chairGroup.add(leg2);

                const leg3 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg3.position.set(-0.2, 0.125, 0.2);
                chairGroup.add(leg3);

                const leg4 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg4.position.set(0.2, 0.125, 0.2);
                chairGroup.add(leg4);

                const backrest = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.05), this.woodMaterial);
                backrest.position.set(0, 0.5, 0.225);
                chairGroup.add(backrest);

                this.sceneManager.scene.add(chairGroup);
                this.objects.push(chairGroup);
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.selectObject(chairGroup);
                UIManager.showModalMessage("Chair Added", `A chair has been added to the scene.`);
            }

            addTable() {
                const tableGroup = new THREE.Group();
                tableGroup.name = `Table_${this.objects.length + 1}`;

                const tabletop = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 1), this.woodMaterial);
                tabletop.position.y = 0.75;
                tableGroup.add(tabletop);

                const legGeometry = new THREE.BoxGeometry(0.08, 0.7, 0.08);
                const leg1 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg1.position.set(-0.6, 0.35, -0.4);
                tableGroup.add(leg1);

                const leg2 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg2.position.set(0.6, 0.35, -0.4);
                tableGroup.add(leg2);

                const leg3 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg3.position.set(-0.6, 0.35, 0.4);
                tableGroup.add(leg3);

                const leg4 = new THREE.Mesh(legGeometry, this.woodMaterial);
                leg4.position.set(0.6, 0.35, 0.4);
                tableGroup.add(leg4);

                this.sceneManager.scene.add(tableGroup);
                this.objects.push(tableGroup);
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.selectObject(tableGroup);
                UIManager.showModalMessage("Table Added", `A table has been added to the scene.`);
            }

            addEmptyRoom() {
                const existingFloor = this.objects.find(obj => obj.name === 'Floor');
                if (existingFloor) {
                    this.sceneManager.scene.remove(existingFloor);
                    disposeObject(existingFloor);
                    this.objects = this.objects.filter(obj => obj.name !== 'Floor');
                }

                const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), this.floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0;
                floor.name = "Floor";
                this.sceneManager.scene.add(floor);
                this.objects.push(floor);
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.selectObject(floor);
                UIManager.showModalMessage("Empty Room Added", "A floor has been added to the scene.");
            }

            removeSelectedObject() {
                if (this.selectedObject) {
                    this.sceneManager.scene.remove(this.selectedObject);
                    disposeObject(this.selectedObject);
                    this.objects = this.objects.filter(obj => obj.uuid !== this.selectedObject.uuid);
                    this.selectedObject = null;
                    this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                    this.uiManager.updateUI(); // Hide properties panel
                    UIManager.showModalMessage("Object Removed", "The selected object has been removed from the scene.");
                } else {
                    UIManager.showModalMessage("No Selection", "No object is selected for removal.");
                }
            }

            centerModel(object) {
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                object.position.sub(center);
            }

            async startImportSequence() {
                this.currentObjFile = null;
                this.currentMtlFile = null;
                this.currentTextures = {};
                if (this.uiManager.elements.objInputHidden) this.uiManager.elements.objInputHidden.value = '';
                if (this.uiManager.elements.mtlInputHidden) this.uiManager.elements.mtlInputHidden.value = '';
                if (this.uiManager.elements.textureInputHidden) this.uiManager.elements.textureInputHidden.value = '';
                if (this.uiManager.elements.objInputHidden) this.uiManager.elements.objInputHidden.click();
            }

            async handleObjFileSelection(file) {
                this.currentObjFile = file;
                if (this.currentObjFile) {
                    if (this.currentObjFile.name.endsWith('.obj')) {
                        if (this.uiManager.elements.mtlInputHidden) this.uiManager.elements.mtlInputHidden.click();
                    } else if (this.currentObjFile.name.endsWith('.gltf') || this.currentObjFile.name.endsWith('.glb')) {
                        await this.loadModel(this.currentObjFile, null);
                    } else {
                        UIManager.showModalMessage("Unsupported Format", `File format is not supported. Load .gltf, .glb or .obj.`);
                    }
                } else {
                    UIManager.showModalMessage("Import Cancelled", "No OBJ file selected.");
                }
            }

            async handleMtlFileSelection(file) {
                this.currentMtlFile = file;
                if (this.currentMtlFile) {
                    if (this.uiManager.elements.textureInputHidden) this.uiManager.elements.textureInputHidden.click();
                } else {
                    if (this.currentObjFile) {
                        await this.loadModel(this.currentObjFile, null);
                    } else {
                        UIManager.showModalMessage("Import Cancelled", "No MTL file selected.");
                    }
                }
            }

            async handleTextureFileSelection(files) {
                this.currentTextures = {};
                if (files.length > 0) {
                    UIManager.showModalMessage("Loading Textures", `Loading ${files.length} textures...`);
                    try {
                        const loadedTextures = await Promise.all(files.map(loadTexture));
                        loadedTextures.forEach(item => {
                            this.currentTextures[item.name] = item.texture;
                        });
                    } catch (error) {
                        UIManager.showModalMessage("Texture Error", `Error loading textures: ${error.message}`);
                    }
                }

                if (this.currentObjFile) {
                    await this.loadModel(this.currentObjFile, this.currentMtlFile);
                } else {
                    UIManager.showModalMessage("Import Error", "No OBJ file available for loading.");
                }
            }

            async loadModel(objFile, mtlFile) {
                this.objects.forEach(obj => {
                    this.sceneManager.scene.remove(obj);
                    disposeObject(obj);
                });
                this.objects = [];
                this.selectObject(null);

                try {
                    if (objFile.name.endsWith('.obj')) {
                        const mtlLoader = new THREE.MTLLoader();
                        mtlLoader.setTexturePath('');
                        mtlLoader.setMaterialOptions({ ignoreZeroRGBs: true, invertTrProperty: true });

                        let materials;
                        if (mtlFile) {
                            const mtlContent = await readFileAsText(mtlFile);
                            materials = mtlLoader.parse(mtlContent);
                            materials.materials.forEach((material) => {
                                Object.entries(material).forEach(([key, value]) => {
                                    if (key.startsWith('map_') && typeof value === 'string') {
                                        const texName = value.split('/').pop();
                                        if (this.currentTextures[texName]) {
                                            material[key] = this.currentTextures[texName];
                                        }
                                    }
                                });
                            });
                            materials.preload();
                        }

                        const objLoader = new THREE.OBJLoader();
                        if (materials) {
                            objLoader.setMaterials(materials);
                        }

                        const objContent = await readFileAsText(objFile);
                        const object = objLoader.parse(objContent);
                        object.name = objFile.name.split('.')[0];
                        
                        this.sceneManager.scene.add(object);
                        this.objects.push(object);
                        this.centerModel(object);
                        this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                        this.selectObject(object);
                        UIManager.showModalMessage("Model Loaded", `Model "${objFile.name}" loaded successfully.`);

                    } else if (objFile.name.endsWith('.gltf') || objFile.name.endsWith('.glb')) {
                        const gltfLoader = new THREE.GLTFLoader();
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            gltfLoader.parse(
                                event.target.result,
                                '',
                                (gltf) => {
                                    const model = gltf.scene;
                                    model.name = objFile.name.split('.')[0];
                                    this.sceneManager.scene.add(model);
                                    this.objects.push(model);
                                    this.centerModel(model);
                                    this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                                    this.selectObject(model);
                                    UIManager.showModalMessage("Model Loaded", `Model "${objFile.name}" loaded successfully.`);
                                },
                                undefined,
                                (error) => {
                                    console.error('GLTF/GLB loading error:', error);
                                    UIManager.showModalMessage("Loading Error", `Failed to load model "${objFile.name}". Ensure it is a valid GLTF/GLB file.`);
                                }
                            );
                        };
                        reader.readAsArrayBuffer(objFile);
                    } else {
                        UIManager.showModalMessage("Unsupported Format", `File format is not supported. Load .gltf, .glb or .obj.`);
                    }
                } catch (error) {
                    console.error("Error loading model:", error);
                    UIManager.showModalMessage("Loading Error", `An error occurred while loading the model: ${error.message}`);
                }
            }

            generateThreeJsCode() {
                let code = `import * as THREE from 'three';\n\n`;
                code += `const scene = new THREE.Scene();\n`;
                code += `scene.background = new THREE.Color(0x282c34);\n\n`;
                code += `const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n`;
                code += `camera.position.set(${this.sceneManager.camera.position.x.toFixed(2)}, ${this.sceneManager.camera.position.y.toFixed(2)}, ${this.sceneManager.camera.position.z.toFixed(2)});\n\n`;
                code += `const renderer = new THREE.WebGLRenderer({ antialias: true });\n`;
                code += `renderer.setSize(window.innerWidth, window.innerHeight);\n`;
                code += `renderer.setPixelRatio(window.devicePixelRatio);\n`;
                code += `document.body.appendChild(renderer.domElement);\n\n`;
                code += `const ambientLight = new THREE.AmbientLight(0x404040);\n`;
                code += `scene.add(ambientLight);\n`;
                code += `const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n`;
                code += `directionalLight.position.set(1, 1, 1).normalize();\n`;
                code += `scene.add(directionalLight);\n\n`;

                code += `const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7 });\n`;
                code += `const marbleMaterial = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, roughness: 0.1 });\n`;
                code += `const metalMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 1.0 });\n`;
                code += `const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.8 });\n\n`;

                this.objects.forEach(obj => {
                    let materialHexColor = '3b82f6';
                    let materialWireframe = false;
                    let materialRoughness = 0.5;
                    let materialMetalness = 0.0;

                    if (obj instanceof THREE.Group) {
                        code += `// Object: ${obj.name} (Group)\n`;
                        code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Group = new THREE.Group();\n`;
                        obj.children.forEach((child, index) => {
                            let childMaterialHexColor = '8B4513';
                            let childMaterialRoughness = 0.7;
                            let childMaterialMetalness = 0.0;

                            if (child.material) {
                                if (child.material.color) childMaterialHexColor = child.material.color.getHexString();
                                if (child.material.roughness !== undefined) childMaterialRoughness = child.material.roughness;
                                if (child.material.metalness !== undefined) childMaterialMetalness = child.material.metalness;
                            }

                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index}Geometry = new THREE.${child.geometry.type}(`;
                            if (child.geometry instanceof THREE.BoxGeometry) {
                                code += `${child.geometry.parameters.width.toFixed(2)}, ${child.geometry.parameters.height.toFixed(2)}, ${child.geometry.parameters.depth.toFixed(2)}`;
                            } else if (child.geometry instanceof THREE.PlaneGeometry) {
                                code += `${child.geometry.parameters.width.toFixed(2)}, ${child.geometry.parameters.height.toFixed(2)}`;
                            } else if (child.geometry instanceof THREE.SphereGeometry) {
                                code += `${child.geometry.parameters.radius.toFixed(2)}, ${child.geometry.parameters.widthSegments}, ${child.geometry.parameters.heightSegments}`;
                            } else if (child.geometry instanceof THREE.CylinderGeometry) {
                                code += `${child.geometry.parameters.radiusTop.toFixed(2)}, ${child.geometry.parameters.radiusBottom.toFixed(2)}, ${child.geometry.parameters.height.toFixed(2)}, ${child.geometry.parameters.radialSegments}`;
                            }
                            code += `);\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index}Material = new THREE.MeshStandardMaterial({ color: 0x${childMaterialHexColor}, roughness: ${childMaterialRoughness.toFixed(2)}, metalness: ${childMaterialMetalness.toFixed(2)} });\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index} = new THREE.Mesh(${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index}Geometry, ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index}Material);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index}.position.set(${child.position.x.toFixed(2)}, ${child.position.y.toFixed(2)}, ${child.position.z.toFixed(2)});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Group.add(${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Child${index});\n`;
                        });
                        code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Group.position.set(${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)});\n`;
                        code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Group.rotation.set(${obj.rotation.x.toFixed(2)}, ${obj.rotation.y.toFixed(2)}, ${obj.rotation.z.toFixed(2)});\n`;
                        code += `scene.add(${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Group);\n\n`;
                        return;
                    }

                    if (obj.material) {
                        if (obj.material.color) materialHexColor = obj.material.color.getHexString();
                        materialWireframe = obj.material.wireframe !== undefined ? obj.material.wireframe : materialWireframe;
                        materialRoughness = obj.material.roughness !== undefined ? obj.material.roughness : materialRoughness;
                        materialMetalness = obj.material.metalness !== undefined ? obj.material.metalness : materialMetalness;
                    }

                    if (obj.userData && obj.userData.shapeData) {
                        let shapeData = obj.userData.shapeData;
                        let extrusionDepth = obj.userData.extrusionDepth;

                        if (shapeData.type === 'circle') {
                            code += `// Object: ${obj.name} (Circle Extrusion)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape = new THREE.Shape();\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.absarc(0, 0, ${shapeData.radius.toFixed(2)}, 0, Math.PI * 2, false);\n\n`;
                        } else if (shapeData.type === 'arc') {
                            code += `// Object: ${obj.name} (Arc Extrusion)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape = new THREE.Shape();\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.absarc(0, 0, ${shapeData.radius.toFixed(2)}, ${shapeData.startAngle.toFixed(2)}, ${shapeData.endAngle.toFixed(2)}, ${shapeData.clockwise});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(0, 0);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(Math.cos(${shapeData.startAngle.toFixed(2)}) * ${shapeData.radius.toFixed(2)}, Math.sin(${shapeData.startAngle.toFixed(2)}) * ${shapeData.radius.toFixed(2)});\n\n`;
                        } else if (shapeData.type === 'rectangle') {
                            code += `// Object: ${obj.name} (Rectangle Extrusion)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape = new THREE.Shape();\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.moveTo(0, 0);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${shapeData.width.toFixed(2)}, 0);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${shapeData.width.toFixed(2)}, ${shapeData.height.toFixed(2)});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(0, ${shapeData.height.toFixed(2)});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(0, 0);\n\n`;
                        } else if (shapeData.type === 'triangle') {
                            const p1 = shapeData.points[0];
                            const p2 = shapeData.points[1];
                            const p3 = shapeData.points[2];
                            code += `// Object: ${obj.name} (Triangle Extrusion)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape = new THREE.Shape();\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.moveTo(${p1.x.toFixed(2)}, ${p1.y.toFixed(2)});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${p2.x.toFixed(2)}, ${p2.y.toFixed(2)});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${p3.x.toFixed(2)}, ${p3.y.toFixed(2)});\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${p1.x.toFixed(2)}, ${p1.y.toFixed(2)});\n\n`;
                        } else if (shapeData.type === 'polyline') {
                            const points = shapeData.points;
                            const firstPoint = points[0];

                            code += `// Object: ${obj.name} (Polyline Extrusion)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape = new THREE.Shape();\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.moveTo(${(points[0].x - firstPoint.x).toFixed(2)}, ${(points[0].y - firstPoint.y).toFixed(2)});\n`;
                            for (let i = 1; i < points.length; i++) {
                                code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${(points[i].x - firstPoint.x).toFixed(2)}, ${(points[i].y - firstPoint.y).toFixed(2)});\n`;
                            }
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(${(points[0].x - firstPoint.x).toFixed(2)}, ${(points[0].y - firstPoint.y).toFixed(2)});\n\n`;
                        } else if (shapeData.type === 'lineExtrusion') {
                            const points = shapeData.points;
                            const width = shapeData.width;
                            const p1 = points[0];
                            const p2 = points[1];

                            code += `// Object: ${obj.name} (Line Extrusion)\n`;
                            code += `const p1 = new THREE.Vector2(${p1.x.toFixed(2)}, ${p1.y.toFixed(2)});\n`;
                            code += `const p2 = new THREE.Vector2(${p2.x.toFixed(2)}, ${p2.y.toFixed(2)});\n`;
                            code += `const width = ${width.toFixed(2)};\n`;
                            code += `const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n`;
                            code += `const dx = Math.cos(angle + Math.PI / 2) * width / 2;\n`;
                            code += `const dy = Math.sin(angle + Math.PI / 2) * width / 2;\n\n`;

                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape = new THREE.Shape();\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.moveTo(p1.x + dx, p1.y + dy);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(p2.x + dx, p2.y + dy);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(p2.x - dx, p2.y - dy);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(p1.x - dx, p1.y - dy);\n`;
                            code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape.lineTo(p1.x + dx, p1.y + dy);\n\n`;
                        }

                        code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}ExtrudeSettings = {\n`;
                        code += `  steps: 1,\n`;
                        code += `  depth: ${extrusionDepth.toFixed(2)},\n`;
                        code += `  bevelEnabled: false\n`;
                        code += `};\n`;
                        code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry = new THREE.ExtrudeGeometry(${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Shape, ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}ExtrudeSettings);\n`;

                    } else if (obj.geometry.userData && obj.geometry.userData.type) {
                        const geoData = obj.geometry.userData;
                        if (geoData.type === 'box') {
                            code += `// Object: ${obj.name} (Cube)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry = new THREE.BoxGeometry(${geoData.side.toFixed(2)}, ${geoData.side.toFixed(2)}, ${geoData.side.toFixed(2)});\n`;
                        } else if (geoData.type === 'sphere') {
                            code += `// Object: ${obj.name} (Sphere)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry = new THREE.SphereGeometry(${geoData.radius.toFixed(2)}, 32, 32);\n`;
                        } else if (geoData.type === 'cylinder') {
                            code += `// Object: ${obj.name} (Cylinder)\n`;
                            code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry = new THREE.CylinderGeometry(${geoData.radius.toFixed(2)}, ${geoData.radius.toFixed(2)}, ${geoData.height.toFixed(2)}, 32);\n`;
                        }
                    } else if (obj.name === 'Floor') {
                        code += `// Object: ${obj.name} (Floor)\n`;
                        code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry = new THREE.PlaneGeometry(${obj.geometry.parameters.width.toFixed(2)}, ${obj.geometry.parameters.height.toFixed(2)});\n`;
                        materialHexColor = this.floorMaterial.color.getHexString();
                        materialRoughness = this.floorMaterial.roughness;
                        materialMetalness = this.floorMaterial.metalness;
                    } else {
                        code += `// Object: ${obj.name} (Imported Model or Complex Geometry)\n`;
                        code += `// The exact geometry of this object cannot be directly serialized into basic Three.js code.\n`;
                        code += `// It is recommended to reload the original model or export it to a standard format like GLTF/GLB.\n`;
                        code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry = new THREE.BoxGeometry(1, 1, 1); // Placeholder geometry\n`;
                    }

                    code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Material = new THREE.MeshStandardMaterial({ color: 0x${materialHexColor}, roughness: ${materialRoughness.toFixed(2)}, metalness: ${materialMetalness.toFixed(2)}, wireframe: ${materialWireframe} });\n`;
                    code += `const ${obj.name.replace(/[^a-zA-Z0-9]/g, '')} = new THREE.Mesh(${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Geometry, ${obj.name.replace(/[^a-zA-Z0-9]/g, '')}Material);\n`;
                    code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}.position.set(${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)});\n`;
                    code += `${obj.name.replace(/[^a-zA-Z0-9]/g, '')}.rotation.set(${obj.rotation.x.toFixed(2)}, ${obj.rotation.y.toFixed(2)}, ${obj.rotation.z.toFixed(2)});\n`;
                    code += `scene.add(${obj.name.replace(/[^a-zA-Z0-9]/g, '')});\n\n`;
                });

                code += `function animate() {\n`;
                code += `  requestAnimationFrame(animate);\n`;
                code += `  // Add any custom animation logic here if needed\n`;
                code += `  renderer.render(scene, camera);\n`;
                code += `}\n`;
                code += `animate();\n`;

                return code;
            }

            applyMaterial(material, materialName) {
                if (this.selectedObject) {
                    if (this.selectedObject instanceof THREE.Group) {
                        this.selectedObject.children.forEach(child => {
                            if (child.material) {
                                child.material = material.clone();
                                child.material.wireframe = this.sceneManager.isWireframe;
                            }
                        });
                    } else {
                        this.selectedObject.material = material.clone();
                        this.selectedObject.material.wireframe = this.sceneManager.isWireframe;
                    }
                    this.uiManager.updatePropertiesPanel(this.selectedObject);
                    UIManager.showModalMessage("Material Applied", `Material "${materialName}" applied to the selected object.`);
                } else {
                    UIManager.showModalMessage("No Selection", "Select an object to apply the material.");
                }
            }
        }

        // === DrawingManager Class ===
        class DrawingManager {
            constructor(sceneManager, uiManager, objectManager) {
                this.sceneManager = sceneManager;
                this.uiManager = uiManager;
                this.objectManager = objectManager;

                this.drawingMode = false;
                this.currentDrawingTool = 'line';
                this.drawnPoints = [];
                this.drawingLines = [];
                this.previewLine = null;

                this.drawingHistory = [];
                this.historyIndex = -1;

                this.sceneManager.renderer.domElement.addEventListener('click', (event) => this.onCanvasClick(event), false);
                this.sceneManager.renderer.domElement.addEventListener('mousemove', (event) => this.onCanvasMouseMove(event), false);
            }

            setDrawingMode(mode) {
                this.drawingMode = mode;
                if (this.sceneManager.controls) this.sceneManager.controls.enabled = !mode;
                if (this.sceneManager.renderer) this.sceneManager.renderer.domElement.style.cursor = mode ? 'crosshair' : 'grab';
                if (this.sceneManager.drawingPlane) this.sceneManager.drawingPlane.visible = mode;
                this.clearDrawing(false); // Clear drawing when changing mode
                this.uiManager.updateUI();
            }

            setCurrentDrawingTool(tool) {
                this.currentDrawingTool = tool;
                this.setDrawingMode(true); // Ensure drawing mode is active
                this.clearDrawing(true); // Clear previous drawing and save state
                this.uiManager.updateUI();
                UIManager.showModalMessage("Drawing Tool", `Drawing tool set to: ${tool.charAt(0).toUpperCase() + tool.slice(1)}.`);
            }

            onCanvasClick(event) {
                if (!this.drawingMode) return;

                // Prevent rapid clicks
                if (this.clickTimeout) {
                    clearTimeout(this.clickTimeout);
                    this.clickTimeout = null;
                    return;
                }
                this.clickTimeout = setTimeout(() => { this.clickTimeout = null; }, 200);

                const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.sceneManager.camera);
                const intersects = raycaster.intersectObject(this.sceneManager.drawingPlane);

                if (intersects.length > 0) {
                    const point3D = intersects[0].point;
                    const point2D = new THREE.Vector2(point3D.x, point3D.z);

                    if (this.currentDrawingTool === 'line' || this.currentDrawingTool === 'polyline') {
                        this.addDrawingPoint(point2D);
                    } else if (this.currentDrawingTool === 'circle') {
                        if (this.drawnPoints.length === 0) {
                            this.drawnPoints.push(point2D);
                            UIManager.showModalMessage("Circle Center", "You have selected the center of the circle. Now you can extrude it.");
                            this.uiManager.updateExtrusionControlsVisibility(true);
                            this.saveDrawingState();
                        } else {
                            this.createCircleShape(this.drawnPoints[0], parseFloat(this.uiManager.elements.circleRadiusInput.value) * this.sceneManager.UNIT_SCALE);
                            this.clearDrawing();
                        }
                    } else if (this.currentDrawingTool === 'arc') {
                        if (this.drawnPoints.length === 0) {
                            this.drawnPoints.push(point2D);
                            UIManager.showModalMessage("Arc Center", "Click to define the arc center. Then enter radius and angles.");
                            this.uiManager.updateExtrusionControlsVisibility(true);
                            this.saveDrawingState();
                        } else {
                            this.createArcShape(this.drawnPoints[0], parseFloat(this.uiManager.elements.arcRadiusInput.value) * this.sceneManager.UNIT_SCALE,
                                THREE.MathUtils.degToRad(parseFloat(this.uiManager.elements.arcStartAngleInput.value)),
                                THREE.MathUtils.degToRad(parseFloat(this.uiManager.elements.arcEndAngleInput.value)),
                                this.uiManager.elements.arcClockwiseInput.checked);
                            this.clearDrawing();
                        }
                    } else if (this.currentDrawingTool === 'rectangle') {
                        if (this.drawnPoints.length === 0) {
                            this.drawnPoints.push(point2D);
                            UIManager.showModalMessage("First Rectangle Corner", "Click to define the first corner of the rectangle.");
                            this.saveDrawingState();
                        } else {
                            this.createRectangleShape(this.drawnPoints[0], parseFloat(this.uiManager.elements.rectWidthInput.value) * this.sceneManager.UNIT_SCALE, parseFloat(this.uiManager.elements.rectHeightInput.value) * this.sceneManager.UNIT_SCALE);
                            this.clearDrawing();
                        }
                    } else if (this.currentDrawingTool === 'triangle') {
                        if (this.drawnPoints.length === 0) {
                            this.drawnPoints.push(point2D);
                            UIManager.showModalMessage("Triangle Base Start", "Click to define the start of the triangle base.");
                            this.saveDrawingState();
                        } else if (this.drawnPoints.length === 1) {
                            this.drawnPoints.push(point2D);
                            UIManager.showModalMessage("Triangle Base End", "Click to define the end of the triangle base.");
                            this.saveDrawingState();
                        } else {
                            this.createTriangleShape(this.drawnPoints[0], this.drawnPoints[1], parseFloat(this.uiManager.elements.triHeightInput.value) * this.sceneManager.UNIT_SCALE);
                            this.clearDrawing();
                        }
                    }
                }
            }

            onCanvasMouseMove(event) {
                if (!this.drawingMode || (this.currentDrawingTool !== 'line' && this.currentDrawingTool !== 'polyline') || this.drawnPoints.length === 0) {
                    if (this.previewLine) {
                        this.sceneManager.scene.remove(this.previewLine);
                        if (this.previewLine.geometry) this.previewLine.geometry.dispose();
                        if (this.previewLine.material) this.previewLine.material.dispose();
                        this.previewLine = null;
                    }
                    if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.placeholder = `Length (cm)`;
                    return;
                }

                const rect = this.sceneManager.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.sceneManager.camera);
                const intersects = raycaster.intersectObject(this.sceneManager.drawingPlane);

                if (intersects.length > 0) {
                    const currentPoint3D = intersects[0].point;
                    const lastDrawnPoint = this.drawnPoints[this.drawnPoints.length - 1];

                    let snappedPoint = new THREE.Vector3(currentPoint3D.x, this.sceneManager.drawingPlane.position.y, currentPoint3D.z);
                    let lineColor = 0x0000ff;

                    const targetPoint2D = new THREE.Vector2(currentPoint3D.x, currentPoint3D.z);
                    const lastPoint2D = lastDrawnPoint;

                    if (Math.abs(targetPoint2D.y - lastPoint2D.y) < this.sceneManager.SNAP_TOLERANCE) {
                        snappedPoint.z = lastPoint2D.y;
                        lineColor = 0xff0000;
                    }
                    if (Math.abs(targetPoint2D.x - lastPoint2D.x) < this.sceneManager.SNAP_TOLERANCE) {
                        snappedPoint.x = lastPoint2D.x;
                        lineColor = 0x00ff00;
                    }

                    const points = [
                        new THREE.Vector3(lastDrawnPoint.x, this.sceneManager.drawingPlane.position.y, lastDrawnPoint.y),
                        snappedPoint
                    ];

                    if (this.previewLine) {
                        this.sceneManager.scene.remove(this.previewLine);
                        if (this.previewLine.geometry) this.previewLine.geometry.dispose();
                        if (this.previewLine.material) this.previewLine.material.dispose();
                    }
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    this.previewLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: lineColor }));
                    this.sceneManager.scene.add(this.previewLine);

                    const length = new THREE.Vector2(snappedPoint.x, snappedPoint.z).distanceTo(lastDrawnPoint);
                    if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.placeholder = `Length: ${(length / this.sceneManager.UNIT_SCALE).toFixed(2)} cm`;
                }
            }

            addDrawingPoint(point) {
                let finalPoint = point.clone();

                if (this.drawnPoints.length > 0) {
                    const lastPoint = this.drawnPoints[this.drawnPoints.length - 1];
                    const targetPoint2D = point;
                    const lastPoint2D = lastPoint;

                    if (Math.abs(targetPoint2D.y - lastPoint2D.y) < this.sceneManager.SNAP_TOLERANCE) {
                        finalPoint.y = lastPoint2D.y;
                    }
                    if (Math.abs(targetPoint2D.x - lastPoint2D.x) < this.sceneManager.SNAP_TOLERANCE) {
                        finalPoint.x = lastPoint2D.x;
                    }

                    if (this.uiManager.elements.lineLengthInput && this.uiManager.elements.lineLengthInput.value !== "") {
                        const desiredLength = parseFloat(this.uiManager.elements.lineLengthInput.value) * this.sceneManager.UNIT_SCALE;
                        if (isNaN(desiredLength) || desiredLength <= 0) {
                            UIManager.showModalMessage("Error", "Invalid line length. Enter a positive value.");
                            if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.value = "";
                            return;
                        }

                        const direction = finalPoint.clone().sub(lastPoint).normalize();
                        finalPoint = lastPoint.clone().add(direction.multiplyScalar(desiredLength));
                        if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.value = "";
                    }
                }

                this.drawnPoints.push(finalPoint);
                this.uiManager.updateUI(); // Update drawn points count

                const dotGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(finalPoint.x, this.sceneManager.drawingPlane.position.y, finalPoint.y);
                this.sceneManager.scene.add(dot);
                this.drawingLines.push(dot);

                if (this.drawnPoints.length > 1) {
                    const prevPoint = this.drawnPoints[this.drawnPoints.length - 2];
                    const currentPoint = this.drawnPoints[this.drawnPoints.length - 1];
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(prevPoint.x, this.sceneManager.drawingPlane.position.y, prevPoint.y),
                        new THREE.Vector3(currentPoint.x, this.sceneManager.drawingPlane.position.y, currentPoint.y)
                    ]);
                    const line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                    this.sceneManager.scene.add(line);
                    this.drawingLines.push(line);
                }

                if (this.previewLine) {
                    this.sceneManager.scene.remove(this.previewLine);
                    if (this.previewLine.geometry) this.previewLine.geometry.dispose();
                    if (this.previewLine.material) this.previewLine.material.dispose();
                    this.previewLine = null;
                }
                if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.placeholder = `Length (cm)`;

                if (this.currentDrawingTool === 'line' && this.drawnPoints.length === 2) {
                    this.uiManager.updateExtrusionControlsVisibility(true);
                    if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');
                    UIManager.showModalMessage("Line Drawn", "The line has been drawn. Now you can extrude it!");
                    this.saveDrawingState();
                } else if (this.currentDrawingTool === 'polyline') {
                    if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.toggle('hidden', this.drawnPoints.length < 3);
                    this.uiManager.updateExtrusionControlsVisibility(false);
                    this.saveDrawingState();
                } else {
                    if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');
                    this.uiManager.updateExtrusionControlsVisibility(false);
                }
            }

            closePath() {
                if (this.currentDrawingTool !== 'polyline' || this.drawnPoints.length < 3) {
                    UIManager.showModalMessage("Error", "This function is for polylines with at least 3 points.");
                    return;
                }

                if (this.previewLine) {
                    this.sceneManager.scene.remove(this.previewLine);
                    if (this.previewLine.geometry) this.previewLine.geometry.dispose();
                    if (this.previewLine.material) this.previewLine.material.dispose();
                    this.previewLine = null;
                }

                const firstPoint = this.drawnPoints[0];
                const lastPoint = this.drawnPoints[this.drawnPoints.length - 1];
                const closingLineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(lastPoint.x, this.sceneManager.drawingPlane.position.y, lastPoint.y),
                    new THREE.Vector3(firstPoint.x, this.sceneManager.drawingPlane.position.y, firstPoint.y)
                ]);
                const closingLine = new THREE.Line(closingLineGeometry, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
                this.sceneManager.scene.add(closingLine);
                this.drawingLines.push(closingLine);

                this.uiManager.updateExtrusionControlsVisibility(true);
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');

                UIManager.showModalMessage("Path Closed", "The 2D path has been closed. Now you can extrude it!");
                this.saveDrawingState();
            }

            createCircleShape(centerPoint, radius) {
                if (radius <= 0) {
                    UIManager.showModalMessage("Error", "Circle radius must be greater than 0.");
                    return;
                }

                const shape = new THREE.Shape();
                shape.absarc(0, 0, radius, 0, Math.PI * 2, false);

                const shapeData = {
                    type: 'circle',
                    center: { x: centerPoint.x, y: centerPoint.y },
                    radius: radius
                };

                this.drawnPoints = [centerPoint];
                this.drawnPoints[0].userData = shapeData;

                this.uiManager.updateExtrusionControlsVisibility(true);
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');

                const circleGeometry = new THREE.CircleGeometry(radius, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                const circleMesh = new THREE.Mesh(circleGeometry, circleMaterial);
                circleMesh.position.set(centerPoint.x, this.sceneManager.drawingPlane.position.y + 0.01, centerPoint.y);
                circleMesh.rotation.x = -Math.PI / 2;
                this.sceneManager.scene.add(circleMesh);
                this.drawingLines.push(circleMesh);

                UIManager.showModalMessage("Circle Drawn", "A circle has been drawn. Now you can extrude it!");
                this.saveDrawingState();
            }

            createArcShape(centerPoint, radius, startAngle, endAngle, clockwise) {
                if (radius <= 0) {
                    UIManager.showModalMessage("Error", "Arc radius must be greater than 0.");
                    return;
                }

                const shape = new THREE.Shape();
                shape.absarc(0, 0, radius, startAngle, endAngle, clockwise);

                const shapeData = {
                    type: 'arc',
                    center: { x: centerPoint.x, y: centerPoint.y },
                    radius: radius,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    clockwise: clockwise
                };

                this.drawnPoints = [centerPoint];
                this.drawnPoints[0].userData = shapeData;

                this.uiManager.updateExtrusionControlsVisibility(true);
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');

                const points = shape.getPoints(50);
                const geometry = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x + centerPoint.x, this.sceneManager.drawingPlane.position.y + 0.01, p.y + centerPoint.y)));
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const line = new THREE.Line(geometry, material);
                this.sceneManager.scene.add(line);
                this.drawingLines.push(line);

                UIManager.showModalMessage("Arc Drawn", "An arc has been drawn. Now you can extrude it!");
                this.saveDrawingState();
            }

            createRectangleShape(originPoint, width, height) {
                if (width <= 0 || height <= 0) {
                    UIManager.showModalMessage("Error", "Rectangle width and height must be greater than 0.");
                    return;
                }

                const shape = new THREE.Shape();
                shape.moveTo(0, 0);
                shape.lineTo(width, 0);
                shape.lineTo(width, height);
                shape.lineTo(0, height);
                shape.lineTo(0, 0);

                const shapeData = {
                    type: 'rectangle',
                    origin: { x: originPoint.x, y: originPoint.y },
                    width: width,
                    height: height
                };

                this.drawnPoints = [originPoint];
                this.drawnPoints[0].userData = shapeData;

                this.uiManager.updateExtrusionControlsVisibility(true);
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');

                const rectGeometry = new THREE.PlaneGeometry(width, height);
                const rectMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                const rectMesh = new THREE.Mesh(rectGeometry, rectMaterial);
                rectMesh.position.set(originPoint.x + width / 2, this.sceneManager.drawingPlane.position.y + 0.01, originPoint.y + height / 2);
                rectMesh.rotation.x = -Math.PI / 2;
                this.sceneManager.scene.add(rectMesh);
                this.drawingLines.push(rectMesh);

                UIManager.showModalMessage("Rectangle Drawn", "A rectangle has been drawn. Now you can extrude it!");
                this.saveDrawingState();
            }

            createTriangleShape(p1, p2, height) {
                if (height <= 0) {
                    UIManager.showModalMessage("Error", "Triangle height must be greater than 0.");
                    return;
                }

                const baseVector = new THREE.Vector2().subVectors(p2, p1);
                const baseLength = baseVector.length();
                if (baseLength === 0) {
                    UIManager.showModalMessage("Error", "Triangle base cannot have zero length.");
                    return;
                }

                const midPoint = new THREE.Vector2().addVectors(p1, p2).multiplyScalar(0.5);
                const normalVector = new THREE.Vector2(-baseVector.y, baseVector.x).normalize();

                const p3 = new THREE.Vector2().addVectors(midPoint, normalVector.multiplyScalar(height));

                const shape = new THREE.Shape();
                shape.moveTo(p1.x, p1.y);
                shape.lineTo(p2.x, p2.y);
                shape.lineTo(p3.x, p3.y);
                shape.lineTo(p1.x, p1.y);

                const shapeData = {
                    type: 'triangle',
                    points: [{ x: p1.x, y: p1.y }, { x: p2.x, y: p2.y }, { x: p3.x, y: p3.y }]
                };

                this.drawnPoints = [p1];
                this.drawnPoints[0].userData = shapeData;

                this.uiManager.updateExtrusionControlsVisibility(true);
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');

                const triangleGeometry = new THREE.BufferGeometry().setFromPoints(shape.getPoints().map(p => new THREE.Vector3(p.x, this.sceneManager.drawingPlane.position.y + 0.01, p.y)));
                const triangleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                const triangleMesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
                this.sceneManager.scene.add(triangleMesh);
                this.drawingLines.push(triangleMesh);

                UIManager.showModalMessage("Triangle Drawn", "A triangle has been drawn. Now you can extrude it!");
                this.saveDrawingState();
            }

            clearDrawing(saveToHistory = true) {
                this.drawingLines.forEach(obj => {
                    this.sceneManager.scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                this.drawingLines = [];
                this.drawnPoints = [];
                this.uiManager.updateUI(); // Update drawn points count
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.add('hidden');
                this.uiManager.updateExtrusionControlsVisibility(false);
                if (this.previewLine) {
                    this.sceneManager.scene.remove(this.previewLine);
                    if (this.previewLine.geometry) this.previewLine.geometry.dispose();
                    if (this.previewLine.material) this.previewLine.material.dispose();
                    this.previewLine = null;
                }
                if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.value = "";
                if (this.uiManager.elements.lineLengthInput) this.uiManager.elements.lineLengthInput.placeholder = "Length (cm)";
                if (saveToHistory) {
                    this.saveDrawingState();
                    UIManager.showModalMessage("Drawing Cleared", "The 2D drawing has been cleared.");
                }
            }

            extrudeShape(depth) {
                if (this.drawnPoints.length === 0 || !this.drawnPoints[0].userData) {
                    UIManager.showModalMessage("Error", "Draw a 2D shape before extruding.");
                    return;
                }

                if (isNaN(depth) || depth <= 0) {
                    UIManager.showModalMessage("Error", "Enter a valid extrusion height (greater than 0).");
                    return;
                }

                let geometry;
                let shapeToExtrude;
                let extrusionOrigin = new THREE.Vector3(this.drawnPoints[0].x, this.sceneManager.drawingPlane.position.y, this.drawnPoints[0].y);

                const shapeData = this.drawnPoints[0].userData;

                if (shapeData.type === 'circle') {
                    shapeToExtrude = new THREE.Shape();
                    shapeToExtrude.absarc(0, 0, shapeData.radius, 0, Math.PI * 2, false);
                    extrusionOrigin.set(shapeData.center.x, this.sceneManager.drawingPlane.position.y, shapeData.center.y);
                } else if (shapeData.type === 'arc') {
                    shapeToExtrude = new THREE.Shape();
                    shapeToExtrude.absarc(0, 0, shapeData.radius, shapeData.startAngle, shapeData.endAngle, shapeData.clockwise);
                    shapeToExtrude.lineTo(0, 0);
                    shapeToExtrude.lineTo(Math.cos(shapeData.startAngle) * shapeData.radius, Math.sin(shapeData.startAngle) * shapeData.radius);
                    extrusionOrigin.set(shapeData.center.x, this.sceneManager.drawingPlane.position.y, shapeData.center.y);
                } else if (shapeData.type === 'rectangle') {
                    shapeToExtrude = new THREE.Shape();
                    shapeToExtrude.moveTo(0, 0);
                    shapeToExtrude.lineTo(shapeData.width, 0);
                    shapeToExtrude.lineTo(shapeData.width, shapeData.height);
                    shapeToExtrude.lineTo(0, shapeData.height);
                    shapeToExtrude.lineTo(0, 0);
                    extrusionOrigin.set(shapeData.origin.x, this.sceneManager.drawingPlane.position.y, shapeData.origin.y);
                } else if (shapeData.type === 'triangle') {
                    const p1 = shapeData.points[0];
                    const p2 = shapeData.points[1];
                    const p3 = shapeData.points[2];
                    shapeToExtrude = new THREE.Shape();
                    shapeToExtrude.moveTo(p1.x, p1.y);
                    shapeToExtrude.lineTo(p2.x, p2.y);
                    shapeToExtrude.lineTo(p3.x, p3.y);
                    shapeToExtrude.lineTo(p1.x, p1.y);
                    extrusionOrigin.set(0, this.sceneManager.drawingPlane.position.y, 0);
                } else if (this.currentDrawingTool === 'line' && this.drawnPoints.length === 2) {
                    const p1 = this.drawnPoints[0];
                    const p2 = this.drawnPoints[1];
                    const width = 0.1 * this.sceneManager.UNIT_SCALE;

                    const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                    const dx = Math.cos(angle + Math.PI / 2) * width / 2;
                    const dy = Math.sin(angle + Math.PI / 2) * width / 2;

                    shapeToExtrude = new THREE.Shape();
                    shapeToExtrude.moveTo(p1.x + dx, p1.y + dy);
                    shapeToExtrude.lineTo(p2.x + dx, p2.y + dy);
                    shapeToExtrude.lineTo(p2.x - dx, p2.y - dy);
                    shapeToExtrude.lineTo(p1.x - dx, p1.y - dy);
                    shapeToExtrude.lineTo(p1.x + dx, p1.y + dy);
                    extrusionOrigin.set(0, this.sceneManager.drawingPlane.position.y, 0);
                } else if (this.currentDrawingTool === 'polyline' && this.drawnPoints.length >= 3) {
                    shapeToExtrude = new THREE.Shape();
                    const firstPoint = this.drawnPoints[0];
                    shapeToExtrude.moveTo(this.drawnPoints[0].x - firstPoint.x, this.drawnPoints[0].y - firstPoint.y);
                    for (let i = 1; i < this.drawnPoints.length; i++) {
                        shapeToExtrude.lineTo(this.drawnPoints[i].x - firstPoint.x, this.drawnPoints[i].y - firstPoint.y);
                    }
                    shapeToExtrude.lineTo(this.drawnPoints[0].x - firstPoint.x, this.drawnPoints[0].y - firstPoint.y);
                    extrusionOrigin.set(firstPoint.x, this.sceneManager.drawingPlane.position.y, firstPoint.y);
                } else {
                    UIManager.showModalMessage("Error", "Unrecognized or invalid 2D shape for extrusion.");
                    return;
                }

                const extrudeSettings = {
                    steps: 1,
                    depth: depth,
                    bevelEnabled: false
                };

                geometry = new THREE.ExtrudeGeometry(shapeToExtrude, extrudeSettings);
                const material = new THREE.MeshStandardMaterial({ color: 0x3b82f6, wireframe: this.sceneManager.isWireframe, roughness: 0.5 });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.copy(extrusionOrigin);
                mesh.name = `Extrusion_${this.objectManager.objects.length + 1}`;
                
                mesh.userData.shapeData = JSON.parse(JSON.stringify(shapeData));
                mesh.userData.extrusionDepth = depth;

                this.sceneManager.scene.add(mesh);
                this.objectManager.objects.push(mesh);

                this.clearDrawing(false);
                this.objectManager.uiManager.updateSelectedObjectOptions(this.objectManager.objects, this.objectManager.selectedObject);
                this.objectManager.selectObject(mesh);

                UIManager.showModalMessage("Extrusion Completed", `The shape has been extruded with a height of ${depth / this.sceneManager.UNIT_SCALE} cm.`);
            }

            saveDrawingState() {
                if (this.historyIndex < this.drawingHistory.length - 1) {
                    this.drawingHistory = this.drawingHistory.slice(0, this.historyIndex + 1);
                }

                const serializedPoints = this.drawnPoints.map(p => ({ x: p.x, y: p.y, userData: p.userData ? JSON.parse(JSON.stringify(p.userData)) : undefined }));
                const serializedLines = this.drawingLines.map(line => {
                    if (line instanceof THREE.Line) {
                        const positions = line.geometry.attributes.position.array;
                        return {
                            type: 'line',
                            points: [
                                { x: positions[0], y: positions[2] },
                                { x: positions[3], y: positions[5] }
                            ],
                            color: line.material.color.getHex()
                        };
                    } else if (line instanceof THREE.Mesh && line.geometry.type === 'BoxGeometry') {
                        return {
                            type: 'dot',
                            position: { x: line.position.x, y: line.position.z },
                            color: line.material.color.getHex()
                        };
                    } else if (line instanceof THREE.Mesh && line.geometry.type === 'CircleGeometry') {
                        return {
                            type: 'circle2D',
                            position: { x: line.position.x, y: line.position.z },
                            radius: line.geometry.parameters.radius,
                            color: line.material.color.getHex(),
                            opacity: line.material.opacity
                        };
                    } else if (line instanceof THREE.Line && line.geometry.type === 'BufferGeometry' && line.geometry.attributes.position.count > 2) {
                        const positions = line.geometry.attributes.position.array;
                        const points = [];
                        for (let i = 0; i < positions.length; i += 3) {
                            points.push({ x: positions[i], y: positions[i+2] });
                        }
                        return {
                            type: 'shapeOutline',
                            points: points,
                            color: line.material.color.getHex()
                        };
                    }
                    return null;
                }).filter(Boolean);

                this.drawingHistory.push({
                    points: serializedPoints,
                    lines: serializedLines
                });
                this.historyIndex++;
            }

            restoreDrawingState(state) {
                this.clearDrawing(false);

                this.drawnPoints = state.points.map(p => {
                    const vec2 = new THREE.Vector2(p.x, p.y);
                    if (p.userData) {
                        vec2.userData = p.userData;
                    }
                    return vec2;
                });

                state.lines.forEach(lineData => {
                    if (lineData.type === 'line') {
                        const points = [
                            new THREE.Vector3(lineData.points[0].x, this.sceneManager.drawingPlane.position.y, lineData.points[0].y),
                            new THREE.Vector3(lineData.points[1].x, this.sceneManager.drawingPlane.position.y, lineData.points[1].y)
                        ];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: lineData.color }));
                        this.sceneManager.scene.add(line);
                        this.drawingLines.push(line);
                    } else if (lineData.type === 'dot') {
                        const dotGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                        const dotMaterial = new THREE.MeshBasicMaterial({ color: lineData.color });
                        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                        dot.position.set(lineData.position.x, this.sceneManager.drawingPlane.position.y, lineData.position.y);
                        this.sceneManager.scene.add(dot);
                        this.drawingLines.push(dot);
                    } else if (lineData.type === 'circle2D') {
                        const circleGeometry = new THREE.CircleGeometry(lineData.radius, 32);
                        const circleMaterial = new THREE.MeshBasicMaterial({ color: lineData.color, transparent: true, opacity: lineData.opacity, side: THREE.DoubleSide });
                        const circleMesh = new THREE.Mesh(circleGeometry, circleMaterial);
                        circleMesh.position.set(lineData.position.x, this.sceneManager.drawingPlane.position.y + 0.01, lineData.position.y);
                        circleMesh.rotation.x = -Math.PI / 2;
                        this.sceneManager.scene.add(circleMesh);
                        this.drawingLines.push(circleMesh);
                    } else if (lineData.type === 'shapeOutline') {
                        const points3D = lineData.points.map(p => new THREE.Vector3(p.x, this.sceneManager.drawingPlane.position.y + 0.01, p.y));
                        const geometry = new THREE.BufferGeometry().setFromPoints(points3D);
                        const material = new THREE.LineBasicMaterial({ color: lineData.color });
                        const line = new THREE.Line(geometry, material);
                        this.sceneManager.scene.add(line);
                        this.drawingLines.push(line);
                    }
                });

                this.uiManager.updateUI();
                if (this.uiManager.elements.closePathBtn) this.uiManager.elements.closePathBtn.classList.toggle('hidden', !(this.currentDrawingTool === 'polyline' && this.drawnPoints.length >= 3));
                this.uiManager.updateExtrusionControlsVisibility(false);
            }

            undoDrawing() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreDrawingState(this.drawingHistory[this.historyIndex]);
                    UIManager.showModalMessage("Undo", "Drawing operation undone.");
                } else {
                    UIManager.showModalMessage("Undo", "No operation to undo.");
                }
            }
        }

        // === ExportManager Class ===
        class ExportManager {
            constructor(sceneManager, objectManager, uiManager) {
                this.sceneManager = sceneManager;
                this.objectManager = objectManager;
                this.uiManager = uiManager;
                this.jsPDFLoaded = false;
                this.preExportState = {}; // To store scene state before export
            }

            async loadJSPDF() {
                if (this.jsPDFLoaded && window.jspdf && window.jspdf.jsPDF) {
                    return window.jspdf;
                }
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    script.onload = () => {
                        if (window.jspdf && window.jspdf.jsPDF) {
                            this.jsPDFLoaded = true;
                            resolve(window.jspdf);
                        } else {
                            reject(new Error("jsPDF did not load correctly."));
                        }
                    };
                    script.onerror = (error) => {
                        reject(new Error(`Error loading jsPDF: ${error.message}`));
                    };
                    document.head.appendChild(script);
                });
            }

            backupSceneState() {
                this.preExportState = {
                    pixelRatio: this.sceneManager.renderer.getPixelRatio(),
                    size: { width: this.sceneManager.renderer.domElement.width, height: this.sceneManager.renderer.domElement.height },
                    cameraPos: this.sceneManager.camera.position.clone(),
                    cameraAspect: this.sceneManager.camera.aspect,
                    cameraFov: this.sceneManager.camera.fov,
                    controlsTarget: this.sceneManager.controls.target.clone()
                };
            }

            restoreSceneState() {
                if (this.sceneManager.renderer) {
                    this.sceneManager.renderer.setPixelRatio(this.preExportState.pixelRatio);
                    this.sceneManager.renderer.setSize(this.preExportState.size.width, this.preExportState.size.height, false);
                }
                if (this.sceneManager.camera) {
                    this.sceneManager.camera.position.copy(this.preExportState.cameraPos);
                    this.sceneManager.camera.aspect = this.preExportState.cameraAspect;
                    this.sceneManager.camera.fov = this.preExportState.cameraFov;
                    this.sceneManager.camera.updateProjectionMatrix();
                }
                if (this.sceneManager.controls) {
                    this.sceneManager.controls.target.copy(this.preExportState.controlsTarget);
                    this.sceneManager.controls.update();
                }
                if (this.sceneManager.renderer && this.sceneManager.scene && this.sceneManager.camera) {
                    this.sceneManager.renderer.render(this.sceneManager.scene, this.sceneManager.camera);
                }
            }

            optimizeForExport() {
                if (this.sceneManager.scene) {
                    this.sceneManager.scene.traverse(obj => {
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(mat => {
                                    mat.dithering = false;
                                    mat.shadowSide = null;
                                });
                            } else {
                                mat.dithering = false;
                                mat.shadowSide = null;
                            }
                        }
                    });
                }
                if (this.sceneManager.renderer) {
                    this.sceneManager.renderer.autoClear = true;
                    this.sceneManager.renderer.info.autoReset = false;
                }
            }

            setHiDPICanvas(canvas, dpi = 150) {
                const scale = dpi / 96;
                const newWidth = canvas.clientWidth * scale;
                const newHeight = canvas.clientHeight * scale;

                if (this.sceneManager.renderer) {
                    this.sceneManager.renderer.setSize(newWidth, newHeight, false);
                }
                if (this.sceneManager.camera) {
                    this.sceneManager.camera.aspect = newWidth / newHeight;
                    this.sceneManager.camera.updateProjectionMatrix();
                }
                if (this.sceneManager.renderer && this.sceneManager.scene && this.sceneManager.camera) {
                    this.sceneManager.renderer.render(this.sceneManager.scene, this.sceneManager.camera);
                }
            }

            checkFileSize(dataUrl) {
                const sizeMB = (dataUrl.length * 0.75) / (1024 * 1024);
                if (sizeMB > 10) {
                    UIManager.showStatus(`Warning: Large PDF image (${sizeMB.toFixed(2)}MB).`, true);
                    return false;
                }
                return true;
            }

            checkMemorySafe(canvas) {
                const maxPixels = 4096 * 4096;
                const currentPixels = canvas.width * canvas.height;
                
                if (currentPixels > maxPixels) {
                    throw new Error(`Canvas dimensions (${currentPixels}px) too large for export. Reduce browser window or DPI scale.`);
                }
            }

            async handleExport() {
                const btn = this.uiManager.elements.exportPDFBtn;
                const btnIcon = btn ? btn.querySelector('.btn-icon') : null;
                const btnText = btn ? btn.querySelector('.btn-text') : null;
                const btnSpinner = btn ? btn.querySelector('.btn-spinner') : null;
                
                if (btn) btn.disabled = true;
                if (btnIcon) btnIcon.hidden = true;
                if (btnText) btnText.textContent = 'Generating...';
                if (btnSpinner) btnSpinner.hidden = false;
                UIManager.showStatus('Generating PDF...');

                try {
                    await this.exportToPDF();
                    
                    if (btnIcon) btnIcon.textContent = '✓';
                    if (btnIcon) btnIcon.hidden = false;
                    if (btnText) btnText.textContent = 'Done!';
                    UIManager.showStatus('PDF generated successfully!');
                } catch (error) {
                    if (btnIcon) btnIcon.textContent = '❌';
                    if (btnIcon) btnIcon.hidden = false;
                    if (btnText) btnText.textContent = 'Retry';
                    UIManager.showStatus('Error: ' + error.message, true);
                    console.error("Error during PDF export:", error);
                } finally {
                    if (btnSpinner) btnSpinner.hidden = true;
                    setTimeout(() => {
                        if (btnIcon) btnIcon.textContent = '📄';
                        if (btnText) btnText.textContent = 'Export PDF';
                        if (btn) btn.disabled = false;
                    }, 3000);
                }
            }

            async exportToPDF() {
                try {
                    this.backupSceneState();
                    this.optimizeForExport();
                    
                    if (this.sceneManager.renderer && this.sceneManager.renderer.domElement) {
                        this.checkMemorySafe(this.sceneManager.renderer.domElement);
                        this.setHiDPICanvas(this.sceneManager.renderer.domElement, 150);
                    }

                    if (this.sceneManager.renderer && this.sceneManager.scene && this.sceneManager.camera) {
                        this.sceneManager.renderer.render(this.sceneManager.scene, this.sceneManager.camera);
                    }

                    const imageData = this.sceneManager.renderer ? this.sceneManager.renderer.domElement.toDataURL('image/jpeg', 0.85) : null;

                    if (!imageData) {
                        throw new Error("Could not capture image data from canvas.");
                    }

                    if (!this.checkFileSize(imageData)) {
                        throw new Error("The generated PDF file is too large. Reduce scene complexity or export resolution.");
                    }

                    const { jsPDF } = await this.loadJSPDF();
                    
                    const doc = new jsPDF({
                        orientation: 'landscape',
                        unit: 'px',
                        format: [this.sceneManager.renderer.domElement.width, this.sceneManager.renderer.domElement.height]
                    });

                    doc.addImage(imageData, 'JPEG', 0, 0, this.sceneManager.renderer.domElement.width, this.sceneManager.renderer.domElement.height);

                    doc.save('3d_scene.pdf');

                } catch (error) {
                    console.error("Error during PDF export:", error);
                    throw new Error(`An error occurred during PDF export: ${error.message || 'Unknown reason'}.`);
                } finally {
                    this.restoreSceneState();
                }
            }

            downloadDXFFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            getSafeColor(object, defaultColor = 7) {
                try {
                    if (!object.material) return defaultColor;
                    
                    let color;
                    if (Array.isArray(object.material)) {
                        color = object.material[0]?.color || new THREE.Color('white');
                    } else {
                        color = object.material.color || new THREE.Color('white');
                    }
                    
                    const rgb = color.isColor ? color : new THREE.Color(color);
                    
                    const brightness = (rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
                    return Math.max(1, Math.min(255, Math.floor(brightness * 255)));
                } catch (e) {
                    console.warn(`DXF: Color conversion failed for ${object.uuid}:`, e);
                    return defaultColor;
                }
            }

            safeCurveToLines(object, segments = 12) {
                try {
                    let curve;
                    
                    if (object.geometry && object.geometry.parameters && object.geometry.parameters.path) {
                        curve = object.geometry.parameters.path;
                    } else if (object instanceof THREE.Line && object.geometry instanceof THREE.BufferGeometry) {
                        const positions = object.geometry.attributes.position.array;
                        const points = [];
                        for (let i = 0; i < positions.length; i += 3) {
                            points.push(new THREE.Vector3(positions[i], positions[i+1], positions[i+2]));
                        }
                        if (points.length > 1) {
                            curve = new THREE.CatmullRomCurve3(points);
                        }
                    } else if (object.userData && object.userData.shapeData) {
                        const shapeData = object.userData.shapeData;
                        if (shapeData.type === 'circle') {
                            const radius = shapeData.radius;
                            const center = new THREE.Vector2(shapeData.center.x, shapeData.center.y);
                            const shape = new THREE.Shape();
                            shape.absarc(center.x, center.y, radius, 0, Math.PI * 2, false);
                            curve = new THREE.CurvePath().add(shape);
                        } else if (shapeData.type === 'arc') {
                            const radius = shapeData.radius;
                            const center = new THREE.Vector2(shapeData.center.x, shapeData.center.y);
                            const startAngle = shapeData.startAngle;
                            const endAngle = shapeData.endAngle;
                            const clockwise = shapeData.clockwise;
                            const shape = new THREE.Shape();
                            shape.absarc(center.x, center.y, radius, startAngle, endAngle, clockwise);
                            curve = new THREE.CurvePath().add(shape);
                        } else if (shapeData.type === 'rectangle' || shapeData.type === 'triangle' || shapeData.type === 'polyline' || shapeData.type === 'lineExtrusion') {
                            return null;
                        }
                    }

                    if (!curve) {
                        throw new Error("Unsupported or not found curve type.");
                    }

                    const points = curve.getPoints(segments);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    return {
                        type: 'LINE_SEGMENTS_APPROXIMATED_CURVE',
                        geometry: geometry,
                        material: object.material,
                        matrixWorld: object.matrixWorld
                    };
                } catch (error) {
                    console.warn(`DXF: Curve conversion failed for ${object.uuid}. Fallback to bounding box:`, error);
                    
                    const box = new THREE.Box3().setFromObject(object);
                    const helper = new THREE.Box3Helper(box, 0xffff00);
                    
                    helper.applyMatrix4(object.matrixWorld);

                    return {
                        type: 'LINE_SEGMENTS_BOUNDING_BOX',
                        geometry: helper.geometry,
                        material: new THREE.LineBasicMaterial({ color: 0xffff00 }),
                        matrixWorld: new THREE.Matrix4()
                    };
                }
            }

            convertObjectToDXFEntity(object, options) {
                let dxfEntity = '';
                const scale = options.scale;
                const precision = options.decimalPrecision;
                const colorIndex = this.getSafeColor(object);

                const position = new THREE.Vector3();
                const quaternion = new THREE.Quaternion();
                const scaleVec = new THREE.Vector3();
                object.matrixWorld.decompose(position, quaternion, scaleVec);

                position.multiplyScalar(scale);

                if (object instanceof THREE.Mesh) {
                    let geometry = object.geometry;

                    if (geometry.attributes.normal === undefined) {
                        geometry.computeVertexNormals();
                    }

                    const edges = new THREE.EdgesGeometry(geometry);
                    const linePositions = edges.attributes.position.array;

                    for (let i = 0; i < linePositions.length; i += 6) {
                        const start = new THREE.Vector3(linePositions[i], linePositions[i + 1], linePositions[i + 2]);
                        const end = new THREE.Vector3(linePositions[i + 3], linePositions[i + 4], linePositions[i + 5]);

                        start.applyMatrix4(object.matrixWorld);
                        end.applyMatrix4(object.matrixWorld);

                        dxfEntity += `0\nLINE\n8\n0\n62\n${colorIndex}\n10\n${(start.x * scale).toFixed(precision)}\n20\n${(start.y * scale).toFixed(precision)}\n30\n${(start.z * scale).toFixed(precision)}\n11\n${(end.x * scale).toFixed(precision)}\n21\n${(end.y * scale).toFixed(precision)}\n31\n${(end.z * scale).toFixed(precision)}\n`;
                    }
                } else if (object instanceof THREE.Line || object instanceof THREE.LineSegments) {
                    const positions = object.geometry.attributes.position.array;

                    for (let i = 0; i < positions.length; i += 6) {
                        const start = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                        const end = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);

                        start.applyMatrix4(object.matrixWorld);
                        end.applyMatrix4(object.matrixWorld);

                        dxfEntity += `0\nLINE\n8\n0\n62\n${colorIndex}\n10\n${(start.x * scale).toFixed(precision)}\n20\n${(start.y * scale).toFixed(precision)}\n30\n${(start.z * scale).toFixed(precision)}\n11\n${(end.x * scale).toFixed(precision)}\n21\n${(end.y * scale).toFixed(precision)}\n31\n${(end.z * scale).toFixed(precision)}\n`;
                    }
                } else if (object.type === 'LINE_SEGMENTS_APPROXIMATED_CURVE' || object.type === 'LINE_SEGMENTS_BOUNDING_BOX') {
                    const positions = object.geometry.attributes.position.array;
                    const approxColorIndex = this.getSafeColor(object, 2);

                    for (let i = 0; i < positions.length; i += 6) {
                        const start = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                        const end = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);

                        if (object.matrixWorld) {
                            start.applyMatrix4(object.matrixWorld);
                            end.applyMatrix4(object.matrixWorld);
                        }
                        
                        dxfEntity += `0\nLINE\n8\n0\n62\n${approxColorIndex}\n10\n${(start.x * scale).toFixed(precision)}\n20\n${(start.y * scale).toFixed(precision)}\n30\n${(start.z * scale).toFixed(precision)}\n11\n${(end.x * scale).toFixed(precision)}\n21\n${(end.y * scale).toFixed(precision)}\n31\n${(end.z * scale).toFixed(precision)}\n`;
                    }
                } else {
                    if (options.logWarnings) {
                        console.warn(`DXF: Unsupported object type for export: ${object.type} (UUID: ${object.uuid})`);
                    }
                    if (!options.skipUnsupported) {
                        throw new Error(`Unsupported object type: ${object.type}`);
                    }
                    return '';
                }
                return dxfEntity;
            }

            exportGroupAsBlockSafe(group, options = {}) {
                const blockId = `BLK_${group.uuid.replace(/-/g, '').slice(0, 8)}`;
                let blockContent = '';
                let partialSuccess = true;

                try {
                    group.children.forEach(child => {
                        try {
                            const entity = this.convertObjectToDXFEntity(child, options);
                            if (entity) blockContent += entity;
                        } catch (childError) {
                            partialSuccess = false;
                            if (options.logWarnings) {
                                console.warn(`DXF: Failed to export child ${child.uuid} in group ${group.uuid}:`, childError);
                            }
                        }
                    });

                    if (!partialSuccess) {
                        throw new Error("Some children were not exported in the block.");
                    }

                    let blockDefinition = `0\nBLOCK\n8\n0\n2\n${blockId}\n70\n1\n10\n0.0\n20\n0.0\n30\n0.0\n3\n${blockId}\n1\n\n`;
                    blockDefinition += blockContent;
                    blockDefinition += `0\nENDBLK\n`;

                    let blockInsertion = `0\nINSERT\n8\n0\n2\n${blockId}\n10\n${(group.position.x * options.scale).toFixed(options.decimalPrecision)}\n20\n${(group.position.y * options.scale).toFixed(options.decimalPrecision)}\n30\n${(group.position.z * options.scale).toFixed(options.decimalPrecision)}\n`;
                    
                    const rotationZ = THREE.MathUtils.radToDeg(group.rotation.y);
                    blockInsertion += `50\n${rotationZ.toFixed(options.decimalPrecision)}\n`;

                    blockInsertion += `41\n${group.scale.x.toFixed(options.decimalPrecision)}\n`;
                    blockInsertion += `42\n${group.scale.y.toFixed(options.decimalPrecision)}\n`;
                    blockInsertion += `43\n${group.scale.z.toFixed(options.decimalPrecision)}\n`;

                    return {
                        blockId,
                        blockDefinition,
                        blockInsertion,
                        success: partialSuccess,
                        warnings: partialSuccess ? null : "Some group elements were not exported correctly."
                    };

                } catch (error) {
                    console.error(`DXF: Exporting group as block failed for ${group.uuid}. Exporting as flat entities:`, error);
                    
                    let fallbackContent = '';
                    group.children.forEach(child => {
                        const tempChild = child.clone();
                        tempChild.applyMatrix4(group.matrixWorld);
                        const entity = this.convertObjectToDXFEntity(tempChild, options);
                        if (entity) fallbackContent += entity;
                    });
                    
                    return {
                        blockId: null,
                        blockDefinition: null,
                        blockInsertion: fallbackContent,
                        success: false,
                        error: `Group export failed: ${error.message}. Exported as flat entities.`
                    };
                }
            }

            buildDXFHeader(options) {
                return `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n9\n$INSUNITS\n70\n4\n0\nENDSEC\n0\nSECTION\n2\nTABLES\n0\nTABLE\n2\nLTYPE\n70\n1\n0\nLTYPE\n2\nCONTINUOUS\n70\n64\n1\nSolid line\n40\n0.0\n0\nENDTAB\n0\nTABLE\n2\nLAYER\n70\n1\n0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n0\nENDTAB\n0\nENDSEC\n0\nSECTION\n2\nBLOCKS\n`;
            }

            exportDXF() {
                const defaults = {
                    scale: 1000,
                    decimalPrecision: 3,
                    curveSegments: 24,
                    skipUnsupported: true,
                    logWarnings: true
                };
                const opts = { ...defaults };

                let blocksSection = '';
                let entitiesSection = '';
                const blockDefinitions = {};

                let hasWarnings = false;
                let errorMessage = null;

                try {
                    this.objectManager.objects.forEach(object => {
                        try {
                            if (object instanceof THREE.Group) {
                                const result = this.exportGroupAsBlockSafe(object, opts);
                                if (result.blockDefinition && !blockDefinitions[result.blockId]) {
                                    blocksSection += result.blockDefinition;
                                    blockDefinitions[result.blockId] = true;
                                }
                                entitiesSection += result.blockInsertion;
                                if (!result.success) hasWarnings = true;
                                if (result.error) errorMessage = result.error;
                            } else {
                                const entity = this.convertObjectToDXFEntity(object, opts);
                                if (entity) entitiesSection += entity;
                            }
                        } catch (error) {
                            hasWarnings = true;
                            if (opts.logWarnings) {
                                console.warn(`DXF: Object skipped ${object.name || object.type} (UUID: ${object.uuid}):`, error);
                            }
                            if (!opts.skipUnsupported) {
                                throw new Error(`Error exporting object ${object.name || object.type}: ${error.message}`);
                            }
                        }
                    });

                    let dxf = this.buildDXFHeader(opts);
                    dxf += blocksSection;
                    dxf += `0\nENDSEC\n0\nSECTION\n2\nENTITIES\n`;
                    dxf += entitiesSection;
                    dxf += `0\nENDSEC\n0\nEOF`;

                    this.downloadDXFFile(dxf, '3d_scene.dxf');
                    UIManager.showModalMessage("DXF Export Completed", "The scene has been exported to DXF. " + (hasWarnings ? "Some warnings occurred. Check console." : ""));
                } catch (majorError) {
                    console.error("DXF: Export completely failed:", majorError);
                    UIManager.showModalMessage("DXF Export Error", `A critical error occurred during DXF export: ${majorError.message}`);
                }
            }
        }

        // --- Main Application Initialization ---
        let sceneManager, objectManager, drawingManager, uiManager, exportManager;

        function initApp() {
            // Check WebGL support
            if (!window.WebGLRenderingContext) {
                UIManager.showModalMessage("Warning", "Your browser may not support WebGL, 3D features might be limited.");
            }

            const canvasContainer = document.getElementById('canvas-container');
            sceneManager = new SceneManager(canvasContainer);
            objectManager = new ObjectManager(sceneManager, null); // UIManager will be set later
            drawingManager = new DrawingManager(sceneManager, null, objectManager); // UIManager will be set later
            exportManager = new ExportManager(sceneManager, objectManager, null); // UIManager will be set later

            // Now that all managers are instantiated, pass references to UIManager
            uiManager = new UIManager(sceneManager, objectManager, drawingManager, exportManager);
            objectManager.uiManager = uiManager;
            drawingManager.uiManager = uiManager;
            exportManager.uiManager = uiManager;

            // Start animation loop
            sceneManager.animate();

            // Initial UI updates
            uiManager.updateUI();
            objectManager.uiManager.updateSelectedObjectOptions(objectManager.objects, objectManager.selectedObject);
            drawingManager.saveDrawingState(); // Save initial empty state for undo
        }

        // Load polyfills if needed
        function loadPolyfills() {
            const needed = [];
            if (!window.Promise) needed.push('promise');
            // Note: HTMLCanvasElement.prototype.toDataURL is generally supported
            // If specific older browser support is needed, consider adding more checks
            
            if (needed.length > 0) {
                const polyfillUrl = `https://cdn.polyfill.io/v3/polyfill.min.js?features=${needed.join(',')}`;
                const script = document.createElement('script');
                script.src = polyfillUrl;
                script.onload = () => console.log('Polyfills loaded.');
                script.onerror = () => console.error('Failed to load polyfills.');
                document.head.appendChild(script);
            }
        }

        window.onload = function () {
            loadPolyfills();
            initApp();
        }
    </script>
</body>
</html>
