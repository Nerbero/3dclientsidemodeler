<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modellatore 3D con Estrusione</title>
    <!-- Carica Tailwind CSS per uno stile rapido e responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Carica Three.js (versione 0.132.2) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <!-- Carica OrbitControls per il controllo della telecamera (versione 0.132.2) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.min.js"></script>
    <!-- Carica GLTFLoader, OBJLoader e MTLLoader per l'importazione di modelli -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/MTLLoader.min.js"></script>
    <!-- jsPDF non è più caricato qui, ma dinamicamente -->
    <style>
        /* Variabili CSS da index (12).html */
        :root {
            --primary: #6a11cb;
            --secondary: #2575fc;
            --accent: #00c853;
            --warning: #ffab00;
            --danger: #ff1744;
            --dark: #1a1a2e;
            --light: #f0f5ff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, var(--dark), #0f1b31); /* Sfondo da index (12).html */
            color: var(--light); /* Colore testo da index (12).html */
            font-family: 'Inter', sans-serif; /* Mantenuto Inter, ma puoi cambiarlo a 'Segoe UI' se preferisci */
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px; /* Padding da index (12).html */
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            flex: 1; /* Permette al contenitore di espandersi */
            display: flex;
            flex-direction: column;
        }
        
        header {
            text-align: center;
            padding: 0; /* Rimosso padding */
            margin-bottom: 0; /* Rimosso margin */
        }
        
        /* Rimosso h1 e subtitle styles */

        /* Stile del pannello "Glass" da index (12).html */
        .glass-panel {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            margin: 15px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
            transition: all 0.3s ease;
        }

        /* Stili specifici per il layout del modellatore, adattati */
        #app-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            padding: 0; /* Rimuovi padding duplicato dal container */
        }
        #canvas-container {
            flex: 1;
            background-color: rgba(0, 0, 0, 0.3); /* Sfondo più scuro per il canvas */
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            width: 100% !important; /* Forza la larghezza al 100% del contenitore */
            height: 100% !important; /* Forza l'altezza al 100% del contenitore */
        }
        .control-panel {
            background-color: rgba(255, 255, 255, 0.08); /* Usa glass-panel background */
            border-radius: 20px; /* Usa glass-panel border-radius */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36); /* Usa glass-panel shadow */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Usa glass-panel border */
            padding: 25px; /* Usa glass-panel padding */
            width: 350px; /* Larghezza fissa per il pannello di controllo */
            flex-shrink: 0; /* Impedisce al pannello di restringersi */
            overflow-y: auto; /* Scroll verticale se i contenuti superano l'altezza */
            margin-right: 20px;
            color: var(--light); /* Assicura che il testo sia chiaro */
        }
        @media (max-width: 1024px) {
            #app-container {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
            }
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #FFFFFF; /* Colore più contrastato */
        }
        .input-group input[type="number"],
        .input-group input[type="color"],
        .input-group select,
        .input-group input[type="text"] {
            width: 100%;
            background: rgba(255, 255, 255, 0.15); /* Sfondo input più chiaro */
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .input-group input[type="color"] {
            height: 40px;
            padding: 0;
        }
        .btn {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background: linear-gradient(90deg, var(--primary), var(--secondary)); /* Gradiente da index (12).html */
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(106, 17, 203, 0.3); /* Ombra da index (12).html */
        }
        .btn-primary:hover {
            transform: translateY(-3px); /* Effetto hover da index (12).html */
            box-shadow: 0 8px 25px rgba(106, 17, 203, 0.5); /* Ombra hover da index (12).html */
            background-color: var(--secondary); /* Fallback */
        }
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            color: var(--light);
            border: none;
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover più contrastato */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        .btn-danger:hover {
            background-color: #dc2626;
            transform: translateY(-1px);
        }
        .btn-success {
            background-color: var(--accent);
            color: white;
        }
        .btn-success:hover {
            background-color: #16a34a;
            transform: translateY(-1px);
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .tool-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            color: var(--light); /* Testo chiaro */
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
            cursor: pointer;
            flex: 1;
            min-width: 70px;
        }
        .tool-button:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover più contrastato */
            transform: translateY(-1px);
        }
        .tool-button.active {
            background: linear-gradient(90deg, var(--primary), var(--secondary)); /* Gradiente attivo da index (12).html */
            color: white;
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.5); /* Ombra attiva da index (12).html */
        }
        .tool-button svg {
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
            fill: currentColor;
        }
        .code-output {
            background-color: rgba(255, 255, 255, 0.15); /* Sfondo input più chiaro */
            color: #a7f3d0;
            padding: 15px;
            border-radius: 12px; /* Border-radius più arrotondato */
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 0.875rem;
            overflow-x: auto;
            max-height: 200px;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1); /* Bordo da index (12).html */
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.25); /* Sfondo più chiaro */
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: rgba(255, 255, 255, 0.35);
        }

        /* Stili per il modale */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 600px; /* Aumentato per contenere più testo */
            width: 90%;
            color: #333; /* Colore testo per il modale */
        }
        .modal-content h3 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #333;
        }
        .modal-content p {
            font-size: 16px; /* Ridotto leggermente per leggibilità */
            color: #555;
            margin-bottom: 15px; /* Ridotto leggermente */
        }
        .modal-content ul {
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            padding: 0; /* Rimosso padding */
            margin-top: 0; /* Rimosso margin */
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
        }

        /* Nuovi stili per la toolbar */
        .toolbar {
            display: flex;
            justify-content: center;
            gap: 10px;
            padding: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.08); /* glass-panel background */
            backdrop-filter: blur(12px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.36);
            position: relative; /* Aggiunto per stacking context */
            z-index: 101; /* Aggiunto per essere sopra il canvas */
        }
        .toolbar button {
            background-color: rgba(255, 255, 255, 0.2); /* Sfondo più contrastato */
            color: var(--light);
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 80px; /* Larghezza minima per i pulsanti */
        }
        .toolbar button:hover {
            background-color: rgba(255, 255, 255, 0.3); /* Sfondo hover più contrastato */
            transform: translateY(-2px);
        }
        .toolbar button.active {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            box-shadow: 0 0 15px rgba(106, 17, 203, 0.5);
        }
        .toolbar button span {
            font-size: 0.8rem; /* Testo più piccolo sotto l'icona */
            display: block;
            margin-top: 4px;
        }

        /* Dropdown styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.5); /* Aumentata opacità per leggibilità */
            backdrop-filter: blur(8px); /* Leggermente meno blur */
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 100; /* Aumentato z-index per essere sopra il canvas e il pannello */
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
            top: 100%; /* Posiziona sotto il pulsante */
            left: 50%;
            transform: translateX(-50%); /* Centra il dropdown */
            margin-top: 10px; /* Spazio dal pulsante */
        }

        .dropdown-content button {
            color: var(--light);
            padding: 8px 12px;
            text-decoration: none;
            display: block;
            background-color: transparent; /* Rimuove sfondo predefinito */
            width: 100%;
            text-align: left;
            font-size: 0.9rem;
            border-radius: 8px; /* Arrotonda i pulsanti interni */
        }

        .dropdown-content button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        /* New CSS for #importBtn */
        #importBtn {
            background: #4CAF50;
            border: none;
            border-radius: 10px; /* Changed to match other buttons */
            padding: 10px 15px; /* Changed to match other buttons */
            font-size: 1.2rem; /* Changed to match other buttons */
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s; /* Combined transitions */
            display: flex; /* Added flex for icon and text */
            align-items: center;
            justify-content: center;
            gap: 5px;
            min-width: 80px;
        }
        #importBtn:hover {
            transform: translateY(-2px); /* Consistent hover effect */
            background: #66BB6A;
        }
        #importBtn svg {
            fill: white;
            vertical-align: middle;
        }

        /* Stili per il pulsante PDF con spinner */
        .btn-spinner {
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Stili per il messaggio di stato fluttuante */
        #export-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 1001; /* Assicura che sia sopra il modale */
        }
    </style>
</head>
<body class="flex flex-col">

    <div class="container">
        <!-- Header dell'applicazione - Rimosso testo -->
        <header></header>
        
        <!-- Nuova Barra degli Strumenti -->
        <div class="toolbar">
            <button id="setupBaseBtn" title="Inizializza motore 3D">🛠️<span>Setup Base</span></button>
            
            <div class="dropdown">
                <button id="geometriesDropdownBtn" title="Aggiungi forme base">🧊<span>Geometrie</span></button>
                <div class="dropdown-content">
                    <button id="lineToolBtnToolbar">Linea</button>
                    <button id="polylineToolBtnToolbar">Polilinea</button>
                    <button id="circleToolBtnToolbar">Cerchio</button>
                    <button id="arcToolBtnToolbar">Arco</button>
                    <button id="triangleToolBtnToolbar">Triangolo</button>
                    <button id="rectangleToolBtnToolbar">Rettangolo</button>
                    <hr class="my-2 border-gray-600">
                    <button id="addCubeBtnToolbar">Cubo</button>
                    <button id="addSphereBtnToolbar">Sfera</button>
                    <button id="addCylinderBtnToolbar">Cilindro</button>
                </div>
            </div>

            <button id="materialsBtn" title="Modifica superfici">🎨<span>Materiali</span></button>
            <button id="paintBucketBtn" title="Applica Materiale">🖌️<span>Applica</span></button>
            <button id="lightsBtn" title="Aggiungi illuminazione">💡<span>Luci</span></button>
            <button id="importBtn" title="Carica modelli 3D">📦<span>Importa</span></button>
            <!-- Hidden file inputs for OBJ/MTL/Texture loading -->
            <input type="file" id="objInputHidden" accept=".obj" hidden>
            <input type="file" id="mtlInputHidden" accept=".mtl" hidden>
            <input type="file" id="textureInputHidden" accept="image/*" multiple hidden>
            
            <div class="dropdown">
                <button id="templatesDropdownBtn" title="Template">🪑<span>Template</span></button>
                <div class="dropdown-content">
                    <button id="applyWoodMaterialBtn">🪵 Legno</button>
                    <button id="applyMarbleMaterialBtn">🏁 Marmo</button>
                    <button id="applyMetalMaterialBtn">🔩 Metallo</button>
                    <hr class="my-2 border-gray-600">
                    <button id="addChairBtnToolbar">🪑 Sedia</button>
                    <button id="addTableBtnToolbar">🛋️ Tavolo</button>
                    <button id="addEmptyRoomBtnToolbar">Stanza Vuota</button>
                </div>
            </div>

            <button id="controlsBtn" title="Naviga nella scena">✋<span>Controlli</span></button>
            <button id="performanceBtn" title="Ottimizza rendering">⚡<span>Performance</span></button>
            <button id="infoBtn" title="Informazioni sull'uso">ℹ️<span>Info</span></button>
        </div>
        
        <!-- Contenitore principale dell'app -->
        <main id="app-container" class="p-4 sm:p-6 lg:p-8">
            <!-- Pannello di controllo -->
            <aside class="control-panel glass-panel">
                <h2 class="text-2xl font-bold text-white mb-4">Controlli</h2>

                <!-- Modalità di Lavoro -->
                <div class="input-group">
                    <label>Modalità:</label>
                    <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                        <button id="viewModeBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Vista
                        </button>
                        <button id="drawModeBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Disegno
                        </button>
                    </div>
                </div>

                <!-- Controlli Vista -->
                <div id="viewControlsPanel" class="mt-6 border-t border-gray-200 pt-6">
                    <h3 class="text-xl font-semibold text-white mb-4">Controlli Vista</h3>
                    <div class="btn-group mb-4">
                        <button id="viewTopBtn" class="btn btn-secondary flex-1">Top</button>
                        <button id="viewFrontBtn" class="btn btn-secondary flex-1">Front</button>
                        <button id="viewRightBtn" class="btn btn-secondary flex-1">Right</button>
                        <button id="viewIsoBtn" class="btn btn-secondary flex-1">Isometrica</button>
                    </div>
                    <div class="btn-group mb-4">
                        <button id="perspectiveViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Prospettica
                        </button>
                        <button id="orthographicViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Ortogonale
                        </button>
                    </div>
                    <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                        <button id="solidViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                            Solido
                        </button>
                        <button id="wireframeViewBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                            Wireframe
                        </button>
                    </div>
                </div>

                <!-- Controlli Disegno (mostrati solo in modalità Disegno) -->
                <div id="drawingControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Opzioni Disegno 2D</h3>
                    <!-- Input for Drawing Plane Y-position -->
                    <div class="input-group">
                        <label for="drawingPlaneYInput">Altezza Piano Disegno (cm):</label>
                        <input type="number" id="drawingPlaneYInput" value="0" step="0.1">
                    </div>

                    <!-- Snap to Grid Toggle -->
                    <div class="input-group">
                        <label>Snap alla Griglia:</label>
                        <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                            <button id="snapGridOnBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                                Attiva
                            </button>
                            <button id="snapGridOffBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                                Disattiva
                            </button>
                        </div>
                    </div>

                    <!-- Grid Snap Resolution Input -->
                    <div class="input-group">
                        <label for="gridSnapResolutionInput">Risoluzione Snap Griglia (cm):</label>
                        <input type="number" id="gridSnapResolutionInput" value="10" step="1">
                    </div>


                    <!-- Options for Line/Polyline -->
                    <div id="lineDrawingOptions" class="input-group">
                        <label>Punti Disegnati:</label>
                        <span id="drawnPointsCount" class="font-bold text-white">0</span>
                        <div class="flex gap-2 mt-2">
                            <input type="number" id="lineLengthInput" placeholder="Lunghezza (cm)" step="0.1" class="flex-1">
                        </div>
                    </div>

                    <!-- Options for Circle -->
                    <div id="circleDrawingOptions" class="input-group hidden">
                        <label for="circleRadiusInput">Raggio Cerchio (cm):</label>
                        <input type="number" id="circleRadiusInput" value="1" step="0.1">
                    </div>

                    <!-- Options for Arc -->
                    <div id="arcDrawingOptions" class="input-group hidden">
                        <label for="arcRadiusInput">Raggio Arco (cm):</label>
                        <input type="number" id="arcRadiusInput" value="1" step="0.1">
                        <label for="arcStartAngleInput">Angolo Iniziale (Gradi):</label>
                        <input type="number" id="arcStartAngleInput" value="0" step="1">
                        <label for="arcEndAngleInput">Angolo Finale (Gradi):</label>
                        <input type="number" id="arcEndAngleInput" value="90" step="1">
                        <label for="arcClockwiseInput">Senso Orario:</label>
                        <input type="checkbox" id="arcClockwiseInput">
                    </div>

                    <!-- Options for Rectangle -->
                    <div id="rectangleDrawingOptions" class="input-group hidden">
                        <label for="rectWidthInput">Larghezza Rettangolo (cm):</label>
                        <input type="number" id="rectWidthInput" value="2" step="0.1">
                        <label for="rectHeightInput">Altezza Rettangolo (cm):</label>
                        <input type="number" id="rectHeightInput" value="2" step="0.1">
                    </div>

                    <!-- Options for Triangle -->
                    <div id="triangleDrawingOptions" class="input-group hidden">
                        <label for="triBaseInput">Base Triangolo (cm):</label>
                        <input type="number" id="triBaseInput" value="2" step="0.1">
                        <label for="triHeightInput">Altezza Triangolo (cm):</label>
                        <input type="number" id="triHeightInput" value="2" step="0.1">
                    </div>

                    <!-- Grid Visibility Toggle -->
                    <div class="input-group">
                        <label>Griglia Visibile:</label>
                        <div class="flex justify-center bg-gray-100 rounded-lg p-1 shadow-inner">
                            <button id="showGridBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 bg-blue-600 text-white shadow-md">
                                Mostra
                            </button>
                            <button id="hideGridBtn" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 text-gray-700 hover:bg-gray-200">
                                Nascondi
                            </button>
                        </div>
                    </div>

                    <button id="closePathBtn" class="btn btn-success w-full mb-3">Concludi Percorso</button>
                    <button id="undoDrawingBtn" class="btn btn-secondary w-full">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5"><path d="M12 19V5M5 12L12 5L19 12"></path></svg>
                        Annulla (Ctrl+Z)
                    </button>
                </div>

                <!-- Controlli Forme 3D Base -->
                <div id="basic3DShapeControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Opzioni Forma 3D Base</h3>
                    <div id="cubeOptions" class="input-group hidden">
                        <label for="cubeSideInput">Lato Cubo (cm):</label>
                        <input type="number" id="cubeSideInput" value="2" step="0.1">
                    </div>
                    <div id="sphereOptions" class="input-group hidden">
                        <label for="sphereRadiusInput">Raggio Sfera (cm):</label>
                        <input type="number" id="sphereRadiusInput" value="1" step="0.1">
                    </div>
                    <div id="cylinderOptions" class="input-group hidden">
                        <label for="cylinderRadiusInput">Raggio Cilindro (cm):</label>
                        <input type="number" id="cylinderRadiusInput" value="1" step="0.1">
                        <label for="cylinderHeightInput">Altezza Cilindro (cm):</label>
                        <input type="number" id="cylinderHeightInput" value="2" step="0.1">
                    </div>
                    <button id="addBasicShapeBtn" class="btn btn-primary w-full hidden">Aggiungi Forma 3D</button>
                </div>

                <!-- Controlli Estrusione (mostrati solo dopo aver concluso un percorso) -->
                <div id="extrusionControls" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Estrusione</h3>
                    <div class="input-group">
                        <label for="extrusionDepth">Altezza Estrusione (cm):</label>
                        <input type="number" id="extrusionDepth" value="2" step="0.1">
                    </div>
                    <button id="extrudeBtn" class="btn btn-primary w-full">Estrudi</button>
                </div>

                <!-- Selezione Oggetto -->
                <div class="input-group mt-6 border-t border-gray-200 pt-6">
                    <label for="selectedObject">Oggetto Selezionato:</label>
                    <select id="selectedObject" class="mb-2"></select>
                    <button id="removeObjectBtn" class="btn btn-danger w-full">Rimuovi Selezionato</button>
                </div>

                <!-- Proprietà Oggetto Selezionato -->
                <div id="objectProperties" class="mt-6 border-t border-gray-200 pt-6 hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">Proprietà Oggetto</h3>

                    <div class="input-group">
                        <label for="objectColor">Colore:</label>
                        <input type="color" id="objectColor" value="#3b82f6">
                    </div>

                    <div class="input-group">
                        <label>Posizione (cm):</label>
                        <div class="flex gap-2">
                            <input type="number" id="posX" placeholder="X" step="0.1" class="flex-1">
                            <input type="number" id="posY" placeholder="Y" step="0.1" class="flex-1">
                            <input type="number" id="posZ" placeholder="Z" step="0.1" class="flex-1">
                        </div>
                    </div>

                    <div class="input-group">
                        <label>Rotazione (Gradi):</label>
                        <div class="flex gap-2">
                            <input type="number" id="rotX" placeholder="X" step="1" class="flex-1">
                            <input type="number" id="rotY" placeholder="Y" step="1" class="flex-1">
                            <input type="number" id="rotZ" placeholder="Z" step="1" class="flex-1">
                        </div>
                    </div>
                </div>

                <div class="btn-group mt-6 border-t border-gray-200 pt-6">
                    <button id="resetSceneBtnSide" class="btn btn-secondary flex-1">Reset Scena</button>
                    <button id="generateCodeBtn" class="btn btn-primary flex-1">Genera Codice Three.js</button>
                    <button id="printBtn" class="btn btn-secondary flex-1">Stampa Disegno</button>
                    <button id="exportDXFBtn" class="btn btn-secondary flex-1">Esporta DXF</button> <!-- Nuovo pulsante DXF -->
                    <button id="exportPDFBtn" class="btn btn-secondary flex-1">
                        <span class="btn-icon">📄</span>
                        <span class="btn-text">Esporta PDF</span>
                        <span class="btn-spinner" hidden>⌛</span>
                    </button>
                </div>
            </aside>

            <!-- Contenitore Canvas 3D -->
            <main id="canvas-container" class="flex-1">
                <!-- Il canvas verrà aggiunto qui dal JavaScript -->
            </main>
        </main>

        <!-- Sezione Output Codice -->
        <section class="p-4 sm:p-6 lg:p-8 glass-panel">
            <h2 class="text-2xl font-bold text-white mb-4">Codice Three.js Generato</h2>
            <div class="code-output-wrapper relative">
                <button id="copyCodeBtn" class="copy-button">Copia Codice</button>
                <pre id="generatedCode" class="code-output">
// Il codice Three.js della tua scena apparirà qui.
// Puoi copiarlo e usarlo in un progetto Three.js!
                </pre>
            </div>
        </section>
    </div>

    <!-- Footer - Rimosso testo -->
    <footer></footer>

    <!-- Messaggio di stato fluttuante -->
    <div id="export-status"></div>

    <script>
        // Global error listener for unhandled errors
        window.addEventListener('error', (e) => {
            console.error("Unhandled global error:", e);
            UIManager.showModalMessage("Unexpected Error", `An unexpected error occurred: ${e.message || 'Details in console.'}`);
        });

        // Helper function to dispose of Three.js object resources
        function disposeObject(obj) {
            if (obj.geometry) {
                obj.geometry.dispose();
            }
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(material => material.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            if (obj.children) {
                obj.children.forEach(child => disposeObject(child)); // Recursively dispose children
            }
        }

        // Helper function to read a file as text
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (error) => {
                    console.error(`Error reading file: ${file.name}`, error);
                    reject(error);
                };
                reader.readAsText(file);
            });
        }

        // Helper function to load a single texture from a File
        function loadTexture(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        resolve({ name: file.name, texture: texture });
                    };
                    img.onerror = (error) => {
                        console.error(`Error loading texture image ${file.name}:`, error);
                        reject(new Error(`Failed to load texture image: ${file.name}.`));
                    };
                    img.src = e.target.result;
                };
                reader.onerror = (error) => {
                    console.error(`Error reading texture file ${file.name}:`, error);
                    reject(new Error(`Failed to read texture file: ${file.name}.`));
                };
                reader.readAsDataURL(file);
            });
        }

        // === SceneManager Class ===
        class SceneManager {
            constructor(container) {
                this.container = container;
                this.scene = new THREE.Scene();
                this.perspectiveCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                // Initialize orthographic camera with a default frustum size
                this.orthographicCamera = new THREE.OrthographicCamera(
                    container.clientWidth / - 2, container.clientWidth / 2,
                    container.clientHeight / 2, container.clientHeight / - 2,
                    0.1, 1000
                );
                this.activeCamera = this.perspectiveCamera; // Start with perspective camera

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.controls = new THREE.OrbitControls(this.activeCamera, this.renderer.domElement);
                this.gridHelper = new THREE.GridHelper(100, 100); // 100 units by 100 divisions
                this.axesHelper = new THREE.AxesHelper(5); // Axes helper, 5 units long
                this.isWireframe = false;
                this.isGridVisible = true;
                this.cameraType = 'perspective'; // 'perspective' or 'orthographic'

                this.init();
            }

            init() {
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setClearColor(0x222222); // Dark background for the scene
                this.container.appendChild(this.renderer.domElement);

                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(1, 1, 1).normalize();
                this.scene.add(directionalLight);

                this.perspectiveCamera.position.set(5, 5, 5); // Initial perspective camera position
                this.orthographicCamera.position.set(5, 5, 5); // Initial orthographic camera position
                this.orthographicCamera.zoom = 100; // Adjust zoom for orthographic view
                this.orthographicCamera.updateProjectionMatrix();


                this.scene.add(this.axesHelper); // Add axes helper to the scene

                this.controls.update();

                // Add grid helper
                this.gridHelper.material.opacity = 0.5;
                this.gridHelper.material.transparent = true;
                this.scene.add(this.gridHelper);

                window.addEventListener('resize', this.onWindowResize.bind(this), false);
            }

            onWindowResize() {
                const aspect = this.container.clientWidth / this.container.clientHeight;

                // Update perspective camera
                this.perspectiveCamera.aspect = aspect;
                this.perspectiveCamera.updateProjectionMatrix();

                // Update orthographic camera frustum
                const frustumSize = 10; // This value might need adjustment based on desired scale
                this.orthographicCamera.left = - frustumSize * aspect / 2;
                this.orthographicCamera.right = frustumSize * aspect / 2;
                this.orthographicCamera.top = frustumSize / 2;
                this.orthographicCamera.bottom = - frustumSize / 2;
                this.orthographicCamera.updateProjectionMatrix();

                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.controls.update();
                this.renderer.render(this.scene, this.activeCamera); // Render with active camera
            }

            resetScene() {
                // Remove all objects except lights, cameras, grid, and axes helper
                const objectsToRemove = [];
                this.scene.children.forEach(obj => {
                    if (obj !== this.perspectiveCamera && obj !== this.orthographicCamera &&
                        obj !== this.gridHelper && obj !== this.axesHelper && !(obj instanceof THREE.Light)) {
                        objectsToRemove.push(obj);
                    }
                });
                objectsToRemove.forEach(obj => {
                    disposeObject(obj);
                    this.scene.remove(obj);
                });
                
                // Reset camera positions and controls target
                this.perspectiveCamera.position.set(5, 5, 5);
                this.orthographicCamera.position.set(5, 5, 5);
                this.controls.target.set(0, 0, 0); // Reset controls target to origin
                this.controls.update();

                // Clear any selected object and drawing
                if (objectManager) objectManager.clearObjects();
                if (drawingManager) drawingManager.clearDrawing(false); // Do not save state on full reset
                if (uiManager) uiManager.updateUI();
                UIManager.showModalMessage("Scene Reset", "All objects and drawings have been cleared.");
            }


            setPresetView(view) {
                const distance = this.activeCamera.position.length(); // Keep current distance from origin
                switch (view) {
                    case 'top':
                        this.activeCamera.position.set(0, distance, 0);
                        break;
                    case 'front':
                        this.activeCamera.position.set(0, 0, distance);
                        break;
                    case 'right':
                        this.activeCamera.position.set(distance, 0, 0);
                        break;
                    case 'iso':
                        this.activeCamera.position.set(distance, distance, distance);
                        break;
                }
                this.activeCamera.lookAt(this.scene.position);
                this.controls.update();
            }

            setWireframeMode(isWireframe) {
                this.isWireframe = isWireframe;
                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => {
                                material.wireframe = isWireframe;
                                material.needsUpdate = true;
                            });
                        } else {
                            object.material.wireframe = isWireframe;
                            object.material.needsUpdate = true;
                        }
                    }
                });
            }

            setGridVisibility(visible) {
                this.isGridVisible = visible;
                this.gridHelper.visible = visible;
            }

            setCameraType(type) {
                if (this.cameraType === type) return; // No change needed

                this.cameraType = type;
                const currentPosition = this.activeCamera.position.clone();
                const currentTarget = this.controls.target.clone();

                if (type === 'perspective') {
                    this.activeCamera = this.perspectiveCamera;
                } else if (type === 'orthographic') {
                    this.activeCamera = this.orthographicCamera;
                }

                // Restore position and target
                this.activeCamera.position.copy(currentPosition);
                this.controls.target.copy(currentTarget);

                // Update controls to use the new active camera
                this.controls.object = this.activeCamera;
                this.onWindowResize(); // Update projection matrix for new camera
                this.controls.update();
                UIManager.showStatus(`Camera set to ${type}.`);
            }
        }

        // === ObjectManager Class ===
        class ObjectManager {
            constructor(sceneManager, uiManager, drawingManager) {
                this.sceneManager = sceneManager;
                this.uiManager = uiManager; // Will be set after UIManager is initialized
                this.drawingManager = drawingManager; // Will be set after DrawingManager is initialized
                this.objects = []; // Array to store all managed Three.js objects
                this.selectedObject = null;
                this.paintBucketMode = false;
                this.currentBasic3DShapeTool = 'none'; // Added to track selected basic 3D shape tool

                this.setupMaterials();

                // Event listener for object selection via raycasting
                this.sceneManager.renderer.domElement.addEventListener('click', this.onCanvasClick.bind(this), false);
            }

            setupMaterials() {
                // Basic materials for templates
                this.woodMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // SaddleBrown
                this.marbleMaterial = new THREE.MeshPhongMaterial({ color: 0xF5F5DC }); // Beige
                this.metalMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, specular: 0x808080, shininess: 30 }); // Grayish metal
            }

            addObject(object, name = 'Object') {
                this.sceneManager.scene.add(object);
                this.objects.push(object);
                this.selectObject(object); // Select the newly added object
                // The uiManager.updateSelectedObjectOptions will be called by selectObject
            }

            removeObject(object) {
                if (!object) return;
                this.sceneManager.scene.remove(object);
                disposeObject(object);
                this.objects = this.objects.filter(obj => obj.uuid !== object.uuid);
                if (this.selectedObject && this.selectedObject.uuid === object.uuid) {
                    this.selectedObject = null;
                }
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updateUI(); // Update UI to hide properties panel if no object selected
            }

            removeSelectedObject() {
                if (this.selectedObject) {
                    this.removeObject(this.selectedObject);
                    UIManager.showModalMessage("Object Removed", "Selected object has been removed.");
                } else {
                    UIManager.showModalMessage("No Object Selected", "Please select an object to remove.");
                }
            }

            selectObject(object) {
                // Remove highlight from previously selected object
                if (this.selectedObject) {
                    if (Array.isArray(this.selectedObject.material)) {
                        this.selectedObject.material.forEach(m => {
                            if (m.emissive && m._previousEmissive) { // Check if emissive exists
                                m.emissive.set(m._previousEmissive);
                                delete m._previousEmissive;
                            } else if (m.color && m._previousColor) { // Revert color if it was used for highlight
                                m.color.set(m._previousColor);
                                delete m._previousColor;
                            }
                        });
                    } else {
                        if (this.selectedObject.material && this.selectedObject.material.emissive && this.selectedObject.material._previousEmissive) { // Check if emissive exists
                            this.selectedObject.material.emissive.set(this.selectedObject.material._previousEmissive);
                            delete this.selectedObject.material._previousEmissive;
                        } else if (this.selectedObject.material && this.selectedObject.material.color && this.selectedObject.material._previousColor) { // Revert color if it was used for highlight
                            this.selectedObject.material.color.set(this.selectedObject.material._previousColor);
                            delete this.selectedObject.material._previousColor;
                        }
                    }
                }

                this.selectedObject = object;

                // Add highlight to new selected object
                if (this.selectedObject) {
                    if (Array.isArray(this.selectedObject.material)) {
                        this.selectedObject.material.forEach(m => {
                            if (m.emissive) { // Check if emissive exists before trying to clone
                                m._previousEmissive = m.emissive.clone();
                                m.emissive.setHex(0x00ff00); // Green highlight
                            } else if (m.color) { // Fallback for materials without emissive (e.g., LineBasicMaterial)
                                m._previousColor = m.color.clone();
                                m.color.setHex(0x00ff00); // Change color for highlight
                            }
                        });
                    } else {
                        if (this.selectedObject.material && this.selectedObject.material.emissive) { // Check if emissive exists before trying to clone
                            this.selectedObject.material._previousEmissive = this.selectedObject.material.emissive.clone();
                            this.selectedObject.material.emissive.setHex(0x00ff00); // Green highlight
                        } else if (this.selectedObject.material && this.selectedObject.material.color) { // Fallback for materials without emissive
                            this.selectedObject.material._previousColor = this.selectedObject.material.color.clone();
                            this.selectedObject.material.color.setHex(0x00ff00); // Change color for highlight
                        }
                    }
                    this.uiManager.updateObjectProperties(this.selectedObject);
                } else {
                    this.uiManager.updateObjectProperties(null); // Clear properties panel
                }
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updateUI(); // Update UI to show/hide properties panel
            }

            updateSelectedObjectColor(hexColor) {
                if (this.selectedObject && this.selectedObject.material) {
                    const newColor = new THREE.Color(hexColor);
                    if (Array.isArray(this.selectedObject.material)) {
                        this.selectedObject.material.forEach(m => m.color.set(newColor));
                    } else {
                        this.selectedObject.material.color.set(newColor);
                    }
                }
            }

            updateSelectedObjectPosition(axis, value) {
                if (this.selectedObject) {
                    this.selectedObject.position[axis] = value;
                }
            }

            updateSelectedObjectRotation(axis, value) {
                if (this.selectedObject) {
                    this.selectedObject.rotation[axis] = THREE.MathUtils.degToRad(value);
                }
            }

            onCanvasClick(event) {
                if (this.drawingManager.drawingMode) return; // Do not select objects in drawing mode

                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / this.sceneManager.renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / this.sceneManager.renderer.domElement.clientHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.sceneManager.activeCamera); // Use active camera for raycasting

                const intersects = raycaster.intersectObjects(this.objects, true);

                if (this.paintBucketMode) {
                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        const currentColor = this.uiManager.elements.objectColorInput.value;
                        this.applyMaterial(new THREE.MeshPhongMaterial({ color: new THREE.Color(currentColor) }), 'Custom Color', intersectedObject);
                        UIManager.showStatus(`Applied color ${currentColor} to object.`);
                    } else {
                        UIManager.showStatus("No object found to apply color.", true);
                    }
                    this.togglePaintBucketMode(); // Deactivate paint bucket after one use
                } else {
                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        this.selectObject(intersectedObject);
                    } else {
                        this.selectObject(null); // Deselect if clicked on empty space
                    }
                }
            }

            togglePaintBucketMode() {
                this.paintBucketMode = !this.paintBucketMode;
                this.uiManager.updateUI(); // Update button active state
            }

            // Method to set the currently active basic 3D shape tool
            setCurrentBasic3DShapeTool(tool) {
                this.currentBasic3DShapeTool = tool;
                this.uiManager.updateUI(); // Update UI to show/hide relevant options
                UIManager.showStatus(`Basic 3D shape tool set to: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
            }

            applyMaterial(material, name, targetObject = null) {
                const objectToApply = targetObject || this.selectedObject;
                if (objectToApply && objectToApply.isMesh) {
                    // Dispose old material if it's not shared
                    if (objectToApply.material && objectToApply.material.dispose) {
                        objectToApply.material.dispose();
                    }
                    objectToApply.material = material;
                    objectToApply.material.needsUpdate = true;
                    UIManager.showStatus(`Applied ${name} material.`);
                } else {
                    UIManager.showStatus("Please select an object to apply material.", true);
                }
            }

            addBasic3DShape(shapeType) {
                let geometry;
                let material = new THREE.MeshPhongMaterial({ color: 0x3b82f6 }); // Default blue

                if (this.uiManager.elements.objectColorInput) {
                    material.color.set(this.uiManager.elements.objectColorInput.value);
                }

                switch (shapeType) {
                    case 'cube':
                        // Ensure input element exists before trying to access its value
                        const cubeSideInput = this.uiManager.elements.cubeSideInput;
                        const cubeSide = cubeSideInput ? parseFloat(cubeSideInput.value) / 100 : 1; // Default to 1m if not found
                        geometry = new THREE.BoxGeometry(cubeSide, cubeSide, cubeSide);
                        break;
                    case 'sphere':
                        const sphereRadiusInput = this.uiManager.elements.sphereRadiusInput;
                        const sphereRadius = sphereRadiusInput ? parseFloat(sphereRadiusInput.value) / 100 : 0.5; // Default to 0.5m
                        geometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
                        break;
                    case 'cylinder':
                        const cylinderRadiusInput = this.uiManager.elements.cylinderRadiusInput;
                        const cylinderHeightInput = this.uiManager.elements.cylinderHeightInput;
                        const cylinderRadius = cylinderRadiusInput ? parseFloat(cylinderRadiusInput.value) / 100 : 0.5;
                        const cylinderHeight = cylinderHeightInput ? parseFloat(cylinderHeightInput.value) / 100 : 1;
                        geometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32);
                        break;
                    default:
                        console.warn("Unknown shape type:", shapeType);
                        return;
                }
                const mesh = new THREE.Mesh(geometry, material);
                this.addObject(mesh, shapeType.charAt(0).toUpperCase() + shapeType.slice(1));
                UIManager.showModalMessage("Shape Added", `${shapeType.charAt(0).toUpperCase() + shapeType.slice(1)} added to scene.`);
            }

            // Method to add a chair (example complex object)
            addChair() {
                // This is a placeholder. A real chair would involve multiple geometries
                // or loading a model. For simplicity, let's create a basic chair shape.
                const chairGroup = new THREE.Group();

                // Seat
                const seatGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.5);
                const seatMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Wood color
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(0, 0.25, 0);
                chairGroup.add(seat);

                // Legs
                const legGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
                const legMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const leg1 = new THREE.Mesh(legGeometry, legMaterial);
                leg1.position.set(0.2, 0, 0.2);
                chairGroup.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, legMaterial);
                leg2.position.set(-0.2, 0, 0.2);
                chairGroup.add(leg2);
                const leg3 = new THREE.Mesh(legGeometry, legMaterial);
                leg3.position.set(0.2, 0, -0.2);
                chairGroup.add(leg3);
                const leg4 = new THREE.Mesh(legGeometry, legMaterial);
                leg4.position.set(-0.2, 0, -0.2);
                chairGroup.add(leg4);

                // Backrest
                const backrestGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.05);
                const backrest = new THREE.Mesh(backrestGeometry, legMaterial);
                backrest.position.set(0, 0.5, -0.225);
                chairGroup.add(backrest);

                this.addObject(chairGroup, 'Chair');
                UIManager.showModalMessage("Object Added", "Chair added to scene.");
            }

            // Method to add a table (example complex object)
            addTable() {
                const tableGroup = new THREE.Group();

                // Tabletop
                const tabletopGeometry = new THREE.BoxGeometry(1.2, 0.05, 0.8);
                const tabletopMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Wood color
                const tabletop = new THREE.Mesh(tabletopGeometry, tabletopMaterial);
                tabletop.position.set(0, 0.75, 0);
                tableGroup.add(tabletop);

                // Legs
                const legGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
                const legMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const leg1 = new THREE.Mesh(legGeometry, legMaterial);
                leg1.position.set(0.5, 0.35, 0.3);
                tableGroup.add(leg1);
                const leg2 = new THREE.Mesh(legGeometry, legMaterial);
                leg2.position.set(-0.5, 0.35, 0.3);
                tableGroup.add(leg2);
                const leg3 = new THREE.Mesh(legGeometry, legMaterial);
                leg3.position.set(0.5, 0.35, -0.3);
                tableGroup.add(leg3);
                const leg4 = new THREE.Mesh(legGeometry, legMaterial);
                leg4.position.set(-0.5, 0.35, -0.3);
                tableGroup.add(leg4);

                this.addObject(tableGroup, 'Table');
                UIManager.showModalMessage("Object Added", "Table added to scene.");
            }

            addEmptyRoom() {
                const roomGroup = new THREE.Group();
                const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xAAAAAA, side: THREE.BackSide }); // Grey walls, visible from inside
                const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 }); // Darker grey floor

                const roomSize = 10; // 10x10x10 meters

                // Floor
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -roomSize / 2; // Place floor at the bottom
                roomGroup.add(floor);

                // Walls (using BoxGeometry for simplicity, could be planes)
                const wallThickness = 0.1;

                // Back Wall
                const backWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, roomSize, wallThickness), wallMaterial);
                backWall.position.set(0, 0, -roomSize / 2);
                roomGroup.add(backWall);

                // Front Wall (with opening for camera, or just omitted)
                // For simplicity, let's omit the front wall to allow viewing inside
                // const frontWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, roomSize, wallThickness), wallMaterial);
                // frontWall.position.set(0, 0, roomSize / 2);
                // roomGroup.add(frontWall);

                // Left Wall
                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomSize, roomSize), wallMaterial);
                leftWall.position.set(-roomSize / 2, 0, 0);
                roomGroup.add(leftWall);

                // Right Wall
                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomSize, roomSize), wallMaterial);
                rightWall.position.set(roomSize / 2, 0, 0);
                roomGroup.add(rightWall);

                // Ceiling
                const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize, roomSize), wallMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.y = roomSize / 2;
                roomGroup.add(ceiling);

                this.addObject(roomGroup, 'Empty Room');
                UIManager.showModalMessage("Object Added", "Empty room added to scene.");

                // Adjust camera to be inside the room
                this.sceneManager.activeCamera.position.set(0, 0, roomSize / 2 - 1); // Just inside the front opening
                this.sceneManager.controls.target.set(0, 0, 0);
                this.sceneManager.controls.update();
            }

            startImportSequence() {
                // Trigger OBJ file input
                this.uiManager.elements.objInputHidden.click();
            }

            async handleObjFileSelection(objFile) {
                if (!objFile) return;

                UIManager.showStatus(`Loading OBJ file: ${objFile.name}...`);
                const objText = await readFileAsText(objFile);

                // Ask for MTL file
                const mtlFile = await new Promise(resolve => {
                    UIManager.showModalMessage("Import OBJ", "Do you have an MTL file for this OBJ model? If yes, select it. Otherwise, click Close.",
                        `<button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove(); document.getElementById('mtlInputHidden').click();">Select MTL</button>
                         <button class="modal-button bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md ml-2" onclick="document.getElementById('customModal').remove();">Close</button>`
                    );
                    document.getElementById('mtlInputHidden').onchange = (e) => {
                        resolve(e.target.files[0]);
                    };
                });

                let mtlText = null;
                if (mtlFile) {
                    UIManager.showStatus(`Loading MTL file: ${mtlFile.name}...`);
                    mtlText = await readFileAsText(mtlFile);
                }

                // Ask for textures
                const textureFiles = await new Promise(resolve => {
                    UIManager.showModalMessage("Import OBJ", "Do you have texture images for this model? Select all relevant images. Otherwise, click Close.",
                        `<button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove(); document.getElementById('textureInputHidden').click();">Select Textures</button>
                         <button class="modal-button bg-gray-400 hover:bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md ml-2" onclick="document.getElementById('customModal').remove();">Close</button>`
                    );
                    document.getElementById('textureInputHidden').onchange = (e) => {
                        resolve(Array.from(e.target.files));
                    };
                });

                const loadedTextures = {};
                if (textureFiles && textureFiles.length > 0) {
                    UIManager.showStatus(`Loading ${textureFiles.length} textures...`);
                    const texturePromises = textureFiles.map(file => loadTexture(file));
                    const results = await Promise.allSettled(texturePromises);
                    results.forEach(result => {
                        if (result.status === 'fulfilled') {
                            loadedTextures[result.value.name] = result.value.texture;
                        } else {
                            console.error("Failed to load a texture:", result.reason);
                            UIManager.showStatus(`Failed to load a texture: ${result.reason.message}`, true);
                        }
                    });
                }

                this.loadObjModel(objText, mtlText, loadedTextures, objFile.name);
            }

            loadObjModel(objText, mtlText = null, textures = {}, modelName = 'Imported Model') {
                const objLoader = new THREE.OBJLoader();
                const mtlLoader = new THREE.MTLLoader();

                if (mtlText) {
                    const materials = mtlLoader.parse(mtlText);
                    materials.preload();

                    // Assign loaded textures to materials
                    for (const materialName in materials.materials) {
                        const material = materials.materials[materialName];
                        // Assuming texture names in MTL match file names (e.g., map_Kd diffuse.jpg)
                        for (const textureKey in textures) {
                            // Check if the texture name is part of the material's texture map (e.g., map_Kd)
                            // This is a simplified check. A robust solution would parse MTL more deeply.
                            if (material.map && material.map.name === textureKey) {
                                material.map = textures[textureKey];
                            }
                            // Add more checks for other map types (normalMap, specularMap, etc.) if needed
                        }
                    }
                    objLoader.setMaterials(materials);
                }

                try {
                    const object = objLoader.parse(objText);
                    this.addObject(object, modelName);
                    UIManager.showStatus(`Model "${modelName}" loaded successfully.`);
                } catch (error) {
                    console.error("Error loading OBJ model:", error);
                    UIManager.showModalMessage("Error Loading Model", `Failed to load OBJ model: ${error.message}. Check console for details.`);
                }
            }

            clearObjects() {
                // Remove all objects except camera, lights, and grid helper
                const objectsToRemove = this.objects.filter(obj =>
                    obj !== this.sceneManager.activeCamera && // Check against active camera
                    obj !== this.sceneManager.gridHelper &&
                    obj !== this.sceneManager.axesHelper && // Also check against axes helper
                    !(obj instanceof THREE.Light)
                );

                objectsToRemove.forEach(obj => this.removeObject(obj));
                this.objects = []; // Ensure the array is empty
                this.selectedObject = null;
                this.uiManager.updateSelectedObjectOptions(this.objects, this.selectedObject);
                this.uiManager.updateUI();
            }
        }

        // === DrawingManager Class ===
        class DrawingManager {
            constructor(sceneManager, uiManager, objectManager) {
                this.sceneManager = sceneManager;
                this.uiManager = uiManager; // Will be set after UIManager is initialized
                this.objectManager = objectManager; // Already set via circular dependency
                this.drawingMode = false;
                this.currentDrawingTool = 'none'; // 'line', 'polyline', 'circle', 'arc', 'triangle', 'rectangle'
                this.drawnPoints = []; // Stores THREE.Vector3 points for current drawing
                this.drawingLine = null; // THREE.Line object for current drawing feedback
                this.drawingPreviewMesh = null; // For shapes like circle, rect, triangle
                
                // Drawing plane for raycasting
                this.drawingPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Y=0 plane initially
                // Visual representation of the drawing plane
                const planeGeometry = new THREE.PlaneGeometry(100, 100); // Large plane
                const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x8888ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                this.drawingPlaneMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                this.drawingPlaneMesh.rotation.x = -Math.PI / 2; // Orient flat on XZ plane
                this.drawingPlaneMesh.position.y = 0; // Initial position
                this.drawingPlaneMesh.visible = false; // Hidden by default
                this.sceneManager.scene.add(this.drawingPlaneMesh);

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.intersectionPoint = new THREE.Vector3();

                this.undoStack = []; // Stores states for undo
                this.redoStack = []; // Stores states for redo

                // New: Intersection indicator (red sphere)
                const indicatorGeometry = new THREE.SphereGeometry(0.05, 16, 16); // 5cm radius
                const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color
                this.currentIntersectionIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                this.currentIntersectionIndicator.visible = false; // Hidden by default
                this.sceneManager.scene.add(this.currentIntersectionIndicator);

                this.snapToGrid = true; // Default to true
                this.gridSnapResolution = 0.1; // Default snap to 10cm (0.1 meters)

                this.sceneManager.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this), false);
                this.sceneManager.renderer.domElement.addEventListener('click', this.onCanvasClick.bind(this), false);

                // Event listeners for drawing tool buttons (assuming they are in UIManager)
                // These will be wired up in UIManager's addEventListeners
            }

            setDrawingMode(mode) {
                this.drawingMode = mode;
                if (mode) {
                    this.sceneManager.controls.enabled = false; // Disable orbit controls in drawing mode
                    this.sceneManager.setGridVisibility(true); // Ensure grid is visible for drawing
                    this.drawingPlaneMesh.visible = true; // Show drawing plane
                    this.currentIntersectionIndicator.visible = true; // Show intersection indicator
                    this.clearDrawing(true); // Clear any previous drawing and save state
                } else {
                    this.sceneManager.controls.enabled = true; // Re-enable orbit controls
                    this.drawingPlaneMesh.visible = false; // Hide drawing plane
                    this.currentIntersectionIndicator.visible = false; // Hide intersection indicator
                    this.clearDrawing(false); // Clear current drawing without saving to undo
                }
                this.uiManager.updateUI();
            }

            setDrawingPlaneY(yPositionCm) {
                const yMeters = yPositionCm / 100; // Convert cm to meters
                this.drawingPlane.constant = -yMeters; // Plane constant is distance from origin along normal
                this.drawingPlaneMesh.position.y = yMeters;
                UIManager.showStatus(`Drawing plane set to Y: ${yPositionCm} cm`);
            }

            setSnapToGrid(enabled) {
                this.snapToGrid = enabled;
                UIManager.showStatus(`Snap alla Griglia: ${enabled ? 'Attivo' : 'Disattivo'}`);
            }

            setGridSnapResolution(resolutionCm) {
                this.gridSnapResolution = resolutionCm / 100; // Convert cm to meters
                UIManager.showStatus(`Risoluzione Snap Griglia: ${resolutionCm} cm`);
            }

            setCurrentDrawingTool(tool) {
                this.currentDrawingTool = tool;
                this.clearDrawing(true); // Clear previous drawing and save state for undo
                this.uiManager.updateUI(); // Update UI to show/hide relevant options
                UIManager.showStatus(`Drawing tool set to: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
            }

            onMouseMove(event) {
                if (!this.drawingMode) return;

                this.mouse.x = (event.clientX / this.sceneManager.renderer.domElement.clientWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / this.sceneManager.renderer.domElement.clientHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.sceneManager.activeCamera); // Use active camera for raycasting
                const intersects = this.raycaster.ray.intersectPlane(this.drawingPlane, this.intersectionPoint);

                if (intersects) {
                    // Apply snapping if enabled
                    if (this.snapToGrid) {
                        this.intersectionPoint.x = Math.round(this.intersectionPoint.x / this.gridSnapResolution) * this.gridSnapResolution;
                        // For XZ plane, Y is fixed by drawingPlane, no need to snap Y
                        this.intersectionPoint.z = Math.round(this.intersectionPoint.z / this.gridSnapResolution) * this.gridSnapResolution;
                    }
                    this.currentIntersectionIndicator.position.copy(this.intersectionPoint);
                    this.currentIntersectionIndicator.visible = true; // Ensure indicator is visible when over plane

                    // Update drawing feedback based on tool
                    if (this.currentDrawingTool === 'line' || this.currentDrawingTool === 'polyline') {
                        if (this.drawnPoints.length > 0) {
                            this.updateDrawingLine(this.intersectionPoint);
                        }
                    } else if (this.currentDrawingTool === 'circle') {
                        if (this.drawnPoints.length === 1) { // Center point is set
                            this.updateCirclePreview(this.intersectionPoint);
                        }
                    } else if (this.currentDrawingTool === 'rectangle') {
                        if (this.drawnPoints.length === 1) { // First corner is set
                            this.updateRectanglePreview(this.intersectionPoint);
                        }
                    } else if (this.currentDrawingTool === 'triangle') {
                        if (this.drawnPoints.length === 1) { // First point (base start)
                            this.updateTrianglePreview(this.intersectionPoint);
                        }
                    }
                } else {
                    this.currentIntersectionIndicator.visible = false; // Hide indicator if not over plane
                }
            }

            onCanvasClick(event) {
                if (!this.drawingMode) return;

                this.raycaster.setFromCamera(this.mouse, this.sceneManager.activeCamera); // Use active camera for raycasting
                const intersects = this.raycaster.ray.intersectPlane(this.drawingPlane, this.intersectionPoint);

                if (intersects) {
                    // Use the snapped intersection point for adding the point
                    const clickPoint = this.intersectionPoint.clone();
                    this.addPoint(clickPoint);
                }
            }

            addPoint(point) {
                this.saveDrawingState(); // Save state before modifying

                this.drawnPoints.push(point);
                this.uiManager.updateUI(); // Update drawn points count

                if (this.currentDrawingTool === 'line') {
                    if (this.drawnPoints.length === 2) {
                        this.createLineSegment(this.drawnPoints[0], this.drawnPoints[1]);
                        this.finalizeShape();
                    } else {
                        // Reset for next line segment if needed, or clear for new line
                        this.clearDrawing(false); // Clear current line preview
                        this.drawnPoints.push(point); // Add the first point back
                    }
                } else if (this.currentDrawingTool === 'polyline') {
                    if (this.drawnPoints.length >= 2) {
                        this.updateDrawingLine(); // Update continuous polyline
                    }
                } else if (this.currentDrawingTool === 'circle') {
                    if (this.drawnPoints.length === 1) { // Center point is clicked
                        UIManager.showStatus("Click again to define circle radius.");
                    } else if (this.drawnPoints.length === 2) { // Radius point is clicked
                        const center = this.drawnPoints[0];
                        const radius = center.distanceTo(this.drawnPoints[1]);
                        this.createCircle(center, radius);
                        this.finalizeShape();
                    }
                } else if (this.currentDrawingTool === 'arc') {
                    if (this.drawnPoints.length === 1) {
                        UIManager.showStatus("Click again for second point of arc.");
                    } else if (this.drawnPoints.length === 2) {
                        UIManager.showStatus("Click again for third point of arc.");
                    } else if (this.drawnPoints.length === 3) {
                        this.createArc(this.drawnPoints[0], this.drawnPoints[1], this.drawnPoints[2]);
                        this.finalizeShape();
                    }
                } else if (this.currentDrawingTool === 'rectangle') {
                    if (this.drawnPoints.length === 1) {
                        UIManager.showStatus("Click again to define opposite corner of rectangle.");
                    } else if (this.drawnPoints.length === 2) {
                        this.createRectangle(this.drawnPoints[0], this.drawnPoints[1]);
                        this.finalizeShape();
                    }
                } else if (this.currentDrawingTool === 'triangle') {
                    if (this.drawnPoints.length === 1) {
                        UIManager.showStatus("Click again for second point of triangle.");
                    } else if (this.drawnPoints.length === 2) {
                        UIManager.showStatus("Click again for third point of triangle.");
                    } else if (this.drawnPoints.length === 3) {
                        this.createTriangle(this.drawnPoints[0], this.drawnPoints[1], this.drawnPoints[2]);
                        this.finalizeShape();
                    }
                }
            }

            updateDrawingLine(currentPoint) {
                if (this.drawingLine) {
                    this.sceneManager.scene.remove(this.drawingLine);
                    disposeObject(this.drawingLine);
                }

                if (this.drawnPoints.length > 0) {
                    const points = [...this.drawnPoints.map(p => p.clone())];
                    if (currentPoint) {
                        points.push(currentPoint);
                    }

                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    this.drawingLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xffff00 })); // Yellow preview line
                    this.sceneManager.scene.add(this.drawingLine);
                }
            }

            updateCirclePreview(currentPoint) {
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                }
                const center = this.drawnPoints[0];
                const radius = center.distanceTo(currentPoint);
                const geometry = new THREE.CircleGeometry(radius, 32);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.drawingPreviewMesh = new THREE.Mesh(geometry, material);
                this.drawingPreviewMesh.position.copy(center);
                this.drawingPreviewMesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.sceneManager.scene.add(this.drawingPreviewMesh);
            }

            updateRectanglePreview(currentPoint) {
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                }
                const p1 = this.drawnPoints[0];
                const p2 = currentPoint;
                const width = Math.abs(p2.x - p1.x);
                const height = Math.abs(p2.z - p1.z); // Assuming drawing on XZ plane
                const centerX = (p1.x + p2.x) / 2;
                const centerZ = (p1.z + p2.z) / 2;
                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.drawingPreviewMesh = new THREE.Mesh(geometry, material);
                this.drawingPreviewMesh.position.set(centerX, p1.y, centerZ);
                this.drawingPreviewMesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.sceneManager.scene.add(this.drawingPreviewMesh);
            }

            updateTrianglePreview(currentPoint) {
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                }

                const p1 = this.drawnPoints[0];
                const p2 = currentPoint; // This will be the second point for the base

                // Create a temporary geometry for preview
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array([
                    p1.x, p1.y, p1.z,
                    p2.x, p2.y, p2.z,
                    p1.x, p1.y, p1.z // Just a line for now, until 3rd point
                ]);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.drawingPreviewMesh = new THREE.Line(geometry, material);
                this.sceneManager.scene.add(this.drawingPreviewMesh);
            }

            createLineSegment(p1, p2) {
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue line
                const points = [p1, p2];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                this.objectManager.addObject(line, 'Line');
            }

            createPolyline(points) {
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Blue polyline
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const polyline = new THREE.Line(geometry, material);
                this.objectManager.addObject(polyline, 'Polyline');
            }

            createCircle(center, radius) {
                const curve = new THREE.EllipseCurve(
                    center.x, center.z, // Center x, y (using Z for 2D plane)
                    radius, radius,     // xRadius, yRadius
                    0, 2 * Math.PI,     // startAngle, endAngle
                    false,              // clockwise
                    0                   // rotation
                );
                const points = curve.getPoints(50); // 50 segments
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const circle = new THREE.Line(geometry, material);
                circle.rotation.x = Math.PI / 2; // Orient correctly on XZ plane
                this.objectManager.addObject(circle, 'Circle');
            }

            createArc(p1, p2, p3) {
                // This is a simplified arc creation. For a true arc from 3 points,
                // more complex geometry calculations are needed.
                // For now, let's just draw lines between the three points.
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
                const points = [p1, p2, p3];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const arc = new THREE.Line(geometry, material);
                this.objectManager.addObject(arc, 'Arc (3 points)');
                UIManager.showStatus("Arc created from 3 points (simplified to lines).");
            }

            createRectangle(p1, p2) {
                // p1 and p2 are opposite corners
                const p3 = new THREE.Vector3(p1.x, p1.y, p2.z);
                const p4 = new THREE.Vector3(p2.x, p1.y, p1.z);

                const shape = new THREE.Shape();
                shape.moveTo(p1.x, p1.z);
                shape.lineTo(p4.x, p4.z);
                shape.lineTo(p2.x, p2.z);
                shape.lineTo(p3.x, p3.z);
                shape.lineTo(p1.x, p1.z); // Close the shape

                const geometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshPhongMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = p1.y; // Keep it on the drawing plane
                mesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.objectManager.addObject(mesh, 'Rectangle');
            }

            createTriangle(p1, p2, p3) {
                const shape = new THREE.Shape();
                shape.moveTo(p1.x, p1.z);
                shape.lineTo(p2.x, p2.z);
                shape.lineTo(p3.x, p3.z);
                shape.lineTo(p1.x, p1.z); // Close the shape

                const geometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshPhongMaterial({ color: 0x0000ff, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = p1.y; // Keep it on the drawing plane
                mesh.rotation.x = -Math.PI / 2; // Lay flat on XZ plane
                this.objectManager.addObject(mesh, 'Triangle');
            }

            closePath() {
                if (this.currentDrawingTool === 'polyline' && this.drawnPoints.length >= 3) {
                    this.saveDrawingState(); // Save state before modifying
                    // Add the first point to close the loop
                    const closedPoints = [...this.drawnPoints, this.drawnPoints[0]];
                    this.createPolyline(closedPoints);
                    this.finalizeShape();
                    UIManager.showStatus("Polyline closed.");
                } else {
                    UIManager.showStatus("Cannot close path. Not a polyline or not enough points.", true);
                }
            }

            finalizeShape() {
                this.clearDrawing(false); // Clear preview, but don't save to undo as shape is finalized
                this.drawnPoints = []; // Reset points for next drawing
                this.uiManager.updateUI(); // Update UI to reflect reset
                // Show extrusion controls if a shape was just created that can be extruded
                if (this.objectManager.selectedObject && (this.objectManager.selectedObject.geometry instanceof THREE.ShapeGeometry)) {
                    this.uiManager.elements.extrusionControls.classList.remove('hidden');
                }
            }

            clearDrawing(saveState = true) {
                if (saveState) {
                    this.saveDrawingState();
                }
                if (this.drawingLine) {
                    this.sceneManager.scene.remove(this.drawingLine);
                    disposeObject(this.drawingLine);
                    this.drawingLine = null;
                }
                if (this.drawingPreviewMesh) {
                    this.sceneManager.scene.remove(this.drawingPreviewMesh);
                    disposeObject(this.drawingPreviewMesh);
                    this.drawingPreviewMesh = null;
                }
                this.drawnPoints = [];
                this.uiManager.updateUI(); // Update drawn points count
                this.uiManager.elements.extrusionControls.classList.add('hidden'); // Hide extrusion controls
            }

            extrudeShape(depth) {
                if (!this.objectManager.selectedObject || !(this.objectManager.selectedObject.geometry instanceof THREE.ShapeGeometry)) {
                    UIManager.showModalMessage("Extrusion Error", "Please select a 2D shape (like a rectangle or triangle) to extrude.");
                    return;
                }

                this.saveDrawingState(); // Save state before modifying

                const shapeGeometry = this.objectManager.selectedObject.geometry;
                const shape = shapeGeometry.parameters.shapes[0]; // Get the original shape

                const extrudeSettings = {
                    steps: 1,
                    depth: depth / 100, // Convert cm to meters
                    bevelEnabled: false
                };

                const extrudedGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const material = this.objectManager.selectedObject.material.clone(); // Keep original material
                const extrudedMesh = new THREE.Mesh(extrudedGeometry, material);

                // Position the extruded mesh correctly
                extrudedMesh.position.copy(this.objectManager.selectedObject.position);
                extrudedMesh.rotation.copy(this.objectManager.selectedObject.rotation);

                // Remove the old 2D shape
                this.objectManager.removeObject(this.objectManager.selectedObject);

                // Add the new extruded 3D object
                this.objectManager.addObject(extrudedMesh, 'Extruded Shape');
                UIManager.showModalMessage("Extrusion Complete", `Shape extruded by ${depth} cm.`);

                this.uiManager.elements.extrusionControls.classList.add('hidden'); // Hide extrusion controls after use
            }

            saveDrawingState() {
                // Store a snapshot of the current drawing state (points, tool)
                const state = {
                    points: this.drawnPoints.map(p => p.toArray()), // Store as array for serialization
                    tool: this.currentDrawingTool,
                    drawingPlaneY: this.drawingPlaneMesh.position.y * 100, // Save in cm
                    objects: this.objectManager.objects.map(obj => ({
                        uuid: obj.uuid,
                        position: obj.position.toArray(),
                        rotation: obj.rotation.toArray(),
                        scale: obj.scale.toArray(),
                        // Add more properties if needed for full state restoration
                    }))
                };
                this.undoStack.push(state);
                this.redoStack = []; // Clear redo stack on new action
                console.log("Drawing state saved. Undo stack size:", this.undoStack.length);
            }

            undoDrawing() {
                if (this.undoStack.length > 1) { // Keep at least the initial empty state
                    const lastState = this.undoStack.pop();
                    this.redoStack.push(lastState); // Move to redo stack

                    const previousState = this.undoStack[this.undoStack.length - 1];
                    this.restoreDrawingState(previousState);
                    UIManager.showStatus("Undo successful.");
                } else {
                    UIManager.showStatus("Nothing to undo.", true);
                }
            }

            redoDrawing() {
                if (this.redoStack.length > 0) {
                    const nextState = this.redoStack.pop();
                    this.undoStack.push(nextState); // Move back to undo stack
                    this.restoreDrawingState(nextState);
                    UIManager.showStatus("Redo successful.");
                } else {
                    UIManager.showStatus("Nothing to redo.", true);
                }
            }

            restoreDrawingState(state) {
                // First, clear all current objects in the scene (except lights, camera, grid)
                // This is a simplified approach. A more robust undo would track object additions/removals.
                this.objectManager.clearObjects();

                // Recreate objects from the saved state
                state.objects.forEach(objData => {
                    // This part needs to be more sophisticated to recreate actual geometries/materials.
                    // For now, it's a placeholder. A real implementation would need to store
                    // geometry type, dimensions, material properties, etc.
                    // For simplicity, we'll just add a placeholder cube for each saved object.
                    const tempGeometry = new THREE.BoxGeometry(1, 1, 1);
                    const tempMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                    const tempMesh = new THREE.Mesh(tempGeometry, tempMaterial);
                    tempMesh.uuid = objData.uuid; // Restore UUID to match selection
                    tempMesh.position.fromArray(objData.position);
                    tempMesh.rotation.fromArray(objData.rotation);
                    tempMesh.scale.fromArray(objData.scale);
                    this.objectManager.addObject(tempMesh, 'Restored Object');
                });

                // Restore drawing points and tool
                this.drawnPoints = state.points.map(p => new THREE.Vector3().fromArray(p));
                this.currentDrawingTool = state.tool;
                this.setDrawingPlaneY(state.drawingPlaneY || 0); // Restore drawing plane Y position

                // Re-render drawing line/preview if applicable
                this.updateDrawingLine();
                if (this.currentDrawingTool === 'circle' && this.drawnPoints.length === 2) {
                    this.updateCirclePreview(this.drawnPoints[1]);
                } else if (this.currentDrawingTool === 'rectangle' && this.drawnPoints.length === 2) {
                    this.updateRectanglePreview(this.drawnPoints[1]);
                } else if (this.currentDrawingTool === 'triangle' && this.drawnPoints.length === 3) {
                    this.createTriangle(this.drawnPoints[0], this.drawnPoints[1], this.drawnPoints[2]);
                }

                this.uiManager.updateUI();
                this.objectManager.selectObject(null); // Deselect after undo/redo
                console.log("Drawing state restored. Undo stack size:", this.undoStack.length);
            }
        }

        // === ExportManager Class ===
        class ExportManager {
            constructor(sceneManager, objectManager, uiManager) {
                this.sceneManager = sceneManager;
                this.objectManager = objectManager;
                this.uiManager = uiManager; // Will be set after UIManager is initialized
            }

            generateThreeJsCode() {
                let code = `// Three.js Scene Export\n\n`;
                code += `const scene = new THREE.Scene();\n`;
                code += `const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n`;
                code += `const renderer = new THREE.WebGLRenderer({ antialias: true });\n`;
                code += `renderer.setSize(window.innerWidth, window.innerHeight);\n`;
                code += `document.body.appendChild(renderer.domElement);\n\n`;

                code += `// Lights\n`;
                code += `scene.add(new THREE.AmbientLight(0x404040));\n`;
                code += `const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n`;
                code += `directionalLight.position.set(1, 1, 1).normalize();\n`;
                code += `scene.add(directionalLight);\n\n`;

                code += `// Objects\n`;
                this.objectManager.objects.forEach(obj => {
                    const materialColor = obj.material.color ? `#${obj.material.color.getHexString()}` : '#cccccc';
                    const objName = obj.name || 'unnamedObject';

                    if (obj instanceof THREE.Mesh) {
                        // Handle different geometries
                        if (obj.geometry instanceof THREE.BoxGeometry) {
                            const { width, height, depth } = obj.geometry.parameters;
                            code += `const ${objName}Geometry = new THREE.BoxGeometry(${width}, ${height}, ${depth});\n`;
                        } else if (obj.geometry instanceof THREE.SphereGeometry) {
                            const { radius } = obj.geometry.parameters;
                            code += `const ${objName}Geometry = new THREE.SphereGeometry(${radius}, 32, 32);\n`;
                        } else if (obj.geometry instanceof THREE.CylinderGeometry) {
                            const { radiusTop, radiusBottom, height } = obj.geometry.parameters;
                            code += `const ${objName}Geometry = new THREE.CylinderGeometry(${radiusTop}, ${radiusBottom}, ${height}, 32);\n`;
                        } else if (obj.geometry instanceof THREE.ShapeGeometry) {
                            // For extruded shapes, we need to reconstruct the shape
                            // This is complex, so for now, we'll just note it or simplify
                            code += `// Note: Complex shape geometry for ${objName} is simplified in export.\n`;
                            code += `const ${objName}Geometry = new THREE.BoxGeometry(1, 1, 1); // Placeholder\n`;
                        } else {
                            code += `// Note: Unknown geometry type for ${objName} is simplified in export.\n`;
                            code += `const ${objName}Geometry = new THREE.BoxGeometry(1, 1, 1); // Placeholder\n`;
                        }

                        code += `const ${objName}Material = new THREE.MeshPhongMaterial({ color: 0x${materialColor.substring(1)} });\n`;
                        code += `const ${objName} = new THREE.Mesh(${objName}Geometry, ${objName}Material);\n`;
                        code += `${objName}.position.set(${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)});\n`;
                        code += `${objName}.rotation.set(${obj.rotation.x.toFixed(2)}, ${obj.rotation.y.toFixed(2)}, ${obj.rotation.z.toFixed(2)});\n`;
                        code += `scene.add(${objName});\n\n`;
                    } else if (obj instanceof THREE.Line) {
                        // Export line geometry (points)
                        const positions = obj.geometry.attributes.position.array;
                        const pointsArray = [];
                        for (let i = 0; i < positions.length; i += 3) {
                            pointsArray.push(`new THREE.Vector3(${positions[i].toFixed(2)}, ${positions[i+1].toFixed(2)}, ${positions[i+2].toFixed(2)})`);
                        }
                        code += `const ${objName}Points = [${pointsArray.join(', ')}];\n`;
                        code += `const ${objName}Geometry = new THREE.BufferGeometry().setFromPoints(${objName}Points);\n`;
                        code += `const ${objName}Material = new THREE.LineBasicMaterial({ color: 0x${materialColor.substring(1)} });\n`;
                        code += `const ${objName} = new THREE.Line(${objName}Geometry, ${objName}Material);\n`;
                        code += `scene.add(${objName});\n\n`;
                    }
                    // Add other object types if needed (e.g., Groups, Sprites)
                });

                code += `// Camera position\n`;
                code += `camera.position.set(${this.sceneManager.activeCamera.position.x.toFixed(2)}, ${this.sceneManager.activeCamera.position.y.toFixed(2)}, ${this.sceneManager.activeCamera.position.z.toFixed(2)});\n`;
                code += `camera.lookAt(scene.position);\n\n`;

                code += `// Animation loop\n`;
                code += `function animate() {\n`;
                code += `    requestAnimationFrame(animate);\n`;
                code += `    renderer.render(scene, camera);\n`;
                code += `}\n`;
                code += `animate();\n`;

                this.uiManager.elements.generatedCodePre.textContent = code;
                UIManager.showStatus("Three.js code generated!");
            }

            copyGeneratedCode() {
                const code = this.uiManager.elements.generatedCodePre.textContent;
                if (code) {
                    // Use execCommand for broader compatibility in iframes
                    const textArea = document.createElement('textarea');
                    textArea.value = code;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        UIManager.showStatus("Code copied to clipboard!");
                    } catch (err) {
                        console.error('Failed to copy code:', err);
                        UIManager.showStatus("Failed to copy code.", true);
                    }
                    document.body.removeChild(textArea);
                } else {
                    UIManager.showStatus("No code to copy.", true);
                }
            }

            exportDXF() {
                const objects = this.objectManager.objects;
                if (objects.length === 0) {
                    UIManager.showModalMessage("Export DXF", "No objects in the scene to export to DXF.");
                    return;
                }

                let dxfContent = `0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n`;
                dxfContent += `0\nSECTION\n2\nTABLES\n0\nTABLE\n2\nLAYER\n70\n1\n`;
                dxfContent += `0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n`; // Default layer 0
                dxfContent += `0\nENDTAB\n0\nENDSEC\n`;
                dxfContent += `0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n`;
                dxfContent += `0\nSECTION\n2\nENTITIES\n`;

                // Conversion factor from Three.js units (meters) to DXF units (mm)
                const scaleFactor = 1000; // 1 Three.js unit = 1000 mm = 1 meter

                objects.forEach(obj => {
                    // Start of an entity
                    dxfContent += `0\nLWPOLYLINE\n`; // Use LWPOLYLINE for 2D polylines
                    dxfContent += `5\n${obj.uuid.substring(0, 8).toUpperCase()}\n`; // Handle
                    dxfContent += `100\nAcDbEntity\n`;
                    dxfContent += `8\n0\n`; // Layer name (0 for default)
                    dxfContent += `100\nAcDbPolyline\n`;
                    dxfContent += `90\n${obj.geometry.attributes.position.count}\n`; // Number of vertices
                    dxfContent += `70\n0\n`; // Polyline flag (0 = default)

                    const positions = obj.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i] * scaleFactor + obj.position.x * scaleFactor;
                        const y = positions[i+1] * scaleFactor + obj.position.y * scaleFactor;
                        const z = positions[i+2] * scaleFactor + obj.position.z * scaleFactor; // DXF is 2D, but Z can be stored

                        dxfContent += `10\n${x.toFixed(3)}\n`; // X coordinate
                        dxfContent += `20\n${y.toFixed(3)}\n`; // Y coordinate
                        dxfContent += `30\n${z.toFixed(3)}\n`; // Z coordinate
                    }
                });

                dxfContent += `0\nENDSEC\n0\nEOF\n`;

                const blob = new Blob([dxfContent], { type: 'application/dxf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'scene_export.dxf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                UIManager.showStatus("DXF file exported!");
            }

            async handleExport() {
                // Dynamically import jsPDF
                UIManager.showStatus("Loading PDF library...");
                this.uiManager.elements.exportPDFBtn.querySelector('.btn-spinner').hidden = false;

                try {
                    // Check if jsPDF is already loaded
                    if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                        await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
                        console.log('jsPDF loaded dynamically.');
                    } else {
                        console.log('jsPDF already loaded.');
                    }

                    // Check if html2canvas is already loaded
                    if (typeof window.html2canvas === 'undefined') {
                        await this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
                        console.log('html2canvas loaded dynamically.');
                    } else {
                        console.log('html2canvas already loaded.');
                    }

                    // Ensure the jsPDF object is correctly referenced
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();

                    UIManager.showStatus("Generating PDF...");

                    // Temporarily hide controls to get a clean canvas screenshot
                    const controlPanel = document.querySelector('.control-panel');
                    const toolbar = document.querySelector('.toolbar');
                    const codeSection = document.querySelector('section.glass-panel');
                    if (controlPanel) controlPanel.style.display = 'none';
                    if (toolbar) toolbar.style.display = 'none';
                    if (codeSection) codeSection.style.display = 'none';


                    // Get the canvas element
                    const canvas = this.sceneManager.renderer.domElement;

                    // Use html2canvas to capture the canvas content
                    const canvasImage = await html2canvas(canvas, {
                        backgroundColor: null, // Transparent background
                        useCORS: true, // Important for images loaded from other origins
                    });

                    // Re-show controls
                    if (controlPanel) controlPanel.style.display = 'block';
                    if (toolbar) toolbar.style.display = 'flex';
                    if (codeSection) codeSection.style.display = 'block';

                    const imgData = canvasImage.toDataURL('image/png');
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = (canvasImage.height * imgWidth) / canvasImage.width;
                    let heightLeft = imgHeight;
                    let position = 0;

                    doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        doc.addPage();
                        doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    doc.save('3d_model_snapshot.pdf');
                    UIManager.showStatus("PDF exported successfully!");

                } catch (error) {
                    console.error("Error exporting PDF:", error);
                    UIManager.showModalMessage("PDF Export Error", `Failed to export PDF: ${error.message}. Please check console for details.`);
                    UIManager.showStatus("PDF export failed.", true);
                } finally {
                    this.uiManager.elements.exportPDFBtn.querySelector('.btn-spinner').hidden = true;
                }
            }

            loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }
        }

        // === UIManager Class ===
        class UIManager {
            constructor(sceneManager, objectManager, drawingManager, exportManager) {
                this.sceneManager = sceneManager;
                this.objectManager = objectManager;
                this.drawingManager = drawingManager;
                this.exportManager = exportManager;

                this.elements = {}; // Store references to DOM elements
                this.initDOMElements();
                this.addEventListeners();
                this.updateUI(); // Initial UI update
            }

            initDOMElements() {
                this.elements.canvasContainer = document.getElementById('canvas-container');
                console.log('Element canvas-container:', this.elements.canvasContainer ? 'found' : 'NOT found');
                this.elements.viewModeBtn = document.getElementById('viewModeBtn');
                console.log('Element viewModeBtn:', this.elements.viewModeBtn ? 'found' : 'NOT found');
                this.elements.drawModeBtn = document.getElementById('drawModeBtn');
                console.log('Element drawModeBtn:', this.elements.drawModeBtn ? 'found' : 'NOT found');
                this.elements.viewControlsPanel = document.getElementById('viewControlsPanel');
                console.log('Element viewControlsPanel:', this.elements.viewControlsPanel ? 'found' : 'NOT found');
                this.elements.drawingControls = document.getElementById('drawingControls');
                console.log('Element drawingControls:', this.elements.drawingControls ? 'found' : 'NOT found');
                this.elements.basic3DShapeControls = document.getElementById('basic3DShapeControls');
                console.log('Element basic3DShapeControls:', this.elements.basic3DShapeControls ? 'found' : 'NOT found');
                this.elements.drawnPointsCount = document.getElementById('drawnPointsCount');
                console.log('Element drawnPointsCount:', this.elements.drawnPointsCount ? 'found' : 'NOT found');
                this.elements.closePathBtn = document.getElementById('closePathBtn');
                console.log('Element closePathBtn:', this.elements.closePathBtn ? 'found' : 'NOT found');
                this.elements.undoDrawingBtn = document.getElementById('undoDrawingBtn');
                console.log('Element undoDrawingBtn:', this.elements.undoDrawingBtn ? 'found' : 'NOT found');
                this.elements.extrusionControls = document.getElementById('extrusionControls');
                console.log('Element extrusionControls:', this.elements.extrusionControls ? 'found' : 'NOT found');
                this.elements.extrusionDepthInput = document.getElementById('extrusionDepth');
                console.log('Element extrusionDepthInput:', this.elements.extrusionDepthInput ? 'found' : 'NOT found');
                this.elements.extrudeBtn = document.getElementById('extrudeBtn');
                console.log('Element extrudeBtn:', this.elements.extrudeBtn ? 'found' : 'NOT found');
                this.elements.selectedObjectSelect = document.getElementById('selectedObject');
                console.log('Element selectedObjectSelect:', this.elements.selectedObjectSelect ? 'found' : 'NOT found');
                this.elements.removeObjectBtn = document.getElementById('removeObjectBtn');
                console.log('Element removeObjectBtn:', this.elements.removeObjectBtn ? 'found' : 'NOT found');
                this.elements.objectPropertiesPanel = document.getElementById('objectProperties');
                console.log('Element objectPropertiesPanel:', this.elements.objectPropertiesPanel ? 'found' : 'NOT found');
                this.elements.objectColorInput = document.getElementById('objectColor');
                console.log('Element objectColorInput:', this.elements.objectColorInput ? 'found' : 'NOT found');
                this.elements.posXInput = document.getElementById('posX');
                console.log('Element posXInput:', this.elements.posXInput ? 'found' : 'NOT found');
                this.elements.posYInput = document.getElementById('posY');
                console.log('Element posYInput:', this.elements.posYInput ? 'found' : 'NOT found');
                this.elements.posZInput = document.getElementById('posZ');
                console.log('Element posZInput:', this.elements.posZInput ? 'found' : 'NOT found');
                this.elements.rotXInput = document.getElementById('rotX');
                console.log('Element rotXInput:', this.elements.rotXInput ? 'found' : 'NOT found');
                this.elements.rotYInput = document.getElementById('rotY');
                console.log('Element rotYInput:', this.elements.rotYInput ? 'found' : 'NOT found');
                this.elements.rotZInput = document.getElementById('rotZ');
                console.log('Element rotZInput:', this.elements.rotZInput ? 'found' : 'NOT found');
                this.elements.resetSceneBtnSide = document.getElementById('resetSceneBtnSide');
                console.log('Element resetSceneBtnSide:', this.elements.resetSceneBtnSide ? 'found' : 'NOT found');
                this.elements.generateCodeBtn = document.getElementById('generateCodeBtn');
                console.log('Element generateCodeBtn:', this.elements.generateCodeBtn ? 'found' : 'NOT found');
                this.elements.printBtn = document.getElementById('printBtn');
                console.log('Element printBtn:', this.elements.printBtn ? 'found' : 'NOT found');
                this.elements.copyCodeBtn = document.getElementById('copyCodeBtn');
                console.log('Element copyCodeBtn:', this.elements.copyCodeBtn ? 'found' : 'NOT found');
                this.elements.exportDXFBtn = document.getElementById('exportDXFBtn');
                console.log('Element exportDXFBtn:', this.elements.exportDXFBtn ? 'found' : 'NOT found');
                this.elements.exportPDFBtn = document.getElementById('exportPDFBtn');
                console.log('Element exportPDFBtn:', this.elements.exportPDFBtn ? 'found' : 'NOT found');
                this.elements.generatedCodePre = document.getElementById('generatedCode');
                console.log('Element generatedCodePre:', this.elements.generatedCodePre ? 'found' : 'NOT found');
                this.elements.exportStatusDiv = document.getElementById('export-status');
                console.log('Element exportStatusDiv:', this.elements.exportStatusDiv ? 'found' : 'NOT found');

                // Toolbar buttons
                this.elements.setupBaseBtn = document.getElementById('setupBaseBtn');
                console.log('Element setupBaseBtn:', this.elements.setupBaseBtn ? 'found' : 'NOT found');
                this.elements.materialsBtn = document.getElementById('materialsBtn');
                console.log('Element materialsBtn:', this.elements.materialsBtn ? 'found' : 'NOT found');
                this.elements.paintBucketBtn = document.getElementById('paintBucketBtn');
                console.log('Element paintBucketBtn:', this.elements.paintBucketBtn ? 'found' : 'NOT found');
                this.elements.lightsBtn = document.getElementById('lightsBtn');
                console.log('Element lightsBtn:', this.elements.lightsBtn ? 'found' : 'NOT found');
                this.elements.importBtn = document.getElementById('importBtn');
                console.log('Element importBtn:', this.elements.importBtn ? 'found' : 'NOT found');
                this.elements.objInputHidden = document.getElementById('objInputHidden');
                console.log('Element objInputHidden:', this.elements.objInputHidden ? 'found' : 'NOT found');
                this.elements.mtlInputHidden = document.getElementById('mtlInputHidden');
                console.log('Element mtlInputHidden:', this.elements.mtlInputHidden ? 'found' : 'NOT found');
                this.elements.textureInputHidden = document.getElementById('textureInputHidden');
                console.log('Element textureInputHidden:', this.elements.textureInputHidden ? 'found' : 'NOT found');
                this.elements.controlsBtn = document.getElementById('controlsBtn');
                console.log('Element controlsBtn:', this.elements.controlsBtn ? 'found' : 'NOT found');
                this.elements.performanceBtn = document.getElementById('performanceBtn');
                console.log('Element performanceBtn:', this.elements.performanceBtn ? 'found' : 'NOT found');
                this.elements.infoBtn = document.getElementById('infoBtn');
                console.log('Element infoBtn:', this.elements.infoBtn ? 'found' : 'NOT found');
                this.elements.geometriesDropdownBtn = document.getElementById('geometriesDropdownBtn');
                console.log('Element geometriesDropdownBtn:', this.elements.geometriesDropdownBtn ? 'found' : 'NOT found');
                this.elements.templatesDropdownBtn = document.getElementById('templatesDropdownBtn');
                console.log('Element templatesDropdownBtn:', this.elements.templatesDropdownBtn ? 'found' : 'NOT found');

                // Toolbar Geometries Dropdown
                this.elements.lineToolBtnToolbar = document.getElementById('lineToolBtnToolbar');
                console.log('Element lineToolBtnToolbar:', this.elements.lineToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.polylineToolBtnToolbar = document.getElementById('polylineToolBtnToolbar');
                console.log('Element polylineToolBtnToolbar:', this.elements.polylineToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.circleToolBtnToolbar = document.getElementById('circleToolBtnToolbar');
                console.log('Element circleToolBtnToolbar:', this.elements.circleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.arcToolBtnToolbar = document.getElementById('arcToolBtnToolbar');
                console.log('Element arcToolBtnToolbar:', this.elements.arcToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.triangleToolBtnToolbar = document.getElementById('triangleToolBtnToolbar');
                console.log('Element triangleToolBtnToolbar:', this.elements.triangleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.rectangleToolBtnToolbar = document.getElementById('rectangleToolBtnToolbar');
                console.log('Element rectangleToolBtnToolbar:', this.elements.rectangleToolBtnToolbar ? 'found' : 'NOT found');
                this.elements.addCubeBtnToolbar = document.getElementById('addCubeBtnToolbar');
                console.log('Element addCubeBtnToolbar:', this.elements.addCubeBtnToolbar ? 'found' : 'NOT found');
                this.elements.addSphereBtnToolbar = document.getElementById('addSphereBtnToolbar');
                console.log('Element addSphereBtnToolbar:', this.elements.addSphereBtnToolbar ? 'found' : 'NOT found');
                this.elements.addCylinderBtnToolbar = document.getElementById('addCylinderBtnToolbar');
                console.log('Element addCylinderBtnToolbar:', this.elements.addCylinderBtnToolbar ? 'found' : 'NOT found');

                // Toolbar Templates Dropdown
                this.elements.applyWoodMaterialBtn = document.getElementById('applyWoodMaterialBtn');
                console.log('Element applyWoodMaterialBtn:', this.elements.applyWoodMaterialBtn ? 'found' : 'NOT found');
                this.elements.applyMarbleMaterialBtn = document.getElementById('applyMarbleMaterialBtn');
                console.log('Element applyMarbleMaterialBtn:', this.elements.applyMarbleMaterialBtn ? 'found' : 'NOT found');
                this.elements.applyMetalMaterialBtn = document.getElementById('applyMetalMaterialBtn');
                console.log('Element applyMetalMaterialBtn:', this.elements.applyMetalMaterialBtn ? 'found' : 'NOT found');
                this.elements.addChairBtnToolbar = document.getElementById('addChairBtnToolbar');
                console.log('Element addChairBtnToolbar:', this.elements.addChairBtnToolbar ? 'found' : 'NOT found');
                this.elements.addTableBtnToolbar = document.getElementById('addTableBtnToolbar');
                console.log('Element addTableBtnToolbar:', this.elements.addTableBtnToolbar ? 'found' : 'NOT found');
                this.elements.addEmptyRoomBtnToolbar = document.getElementById('addEmptyRoomBtnToolbar');
                console.log('Element addEmptyRoomBtnToolbar:', this.elements.addEmptyRoomBtnToolbar ? 'found' : 'NOT found');

                this.elements.showGridBtn = document.getElementById('showGridBtn');
                console.log('Element showGridBtn:', this.elements.showGridBtn ? 'found' : 'NOT found');
                this.elements.hideGridBtn = document.getElementById('hideGridBtn');
                console.log('Element hideGridBtn:', this.elements.hideGridBtn ? 'found' : 'NOT found');

                this.elements.lineDrawingOptions = document.getElementById('lineDrawingOptions');
                console.log('Element lineDrawingOptions:', this.elements.lineDrawingOptions ? 'found' : 'NOT found');
                this.elements.circleDrawingOptions = document.getElementById('circleDrawingOptions');
                console.log('Element circleDrawingOptions:', this.elements.circleDrawingOptions ? 'found' : 'NOT found');
                this.elements.arcDrawingOptions = document.getElementById('arcDrawingOptions');
                console.log('Element arcDrawingOptions:', this.elements.arcDrawingOptions ? 'found' : 'NOT found');
                this.elements.rectangleDrawingOptions = document.getElementById('rectangleDrawingOptions');
                console.log('Element rectangleDrawingOptions:', this.elements.rectangleDrawingOptions ? 'found' : 'NOT found');
                this.elements.triangleDrawingOptions = document.getElementById('triangleDrawingOptions');
                console.log('Element triangleDrawingOptions:', this.elements.triangleDrawingOptions ? 'found' : 'NOT found');

                this.elements.lineLengthInput = document.getElementById('lineLengthInput');
                console.log('Element lineLengthInput:', this.elements.lineLengthInput ? 'found' : 'NOT found');
                this.elements.circleRadiusInput = document.getElementById('circleRadiusInput');
                console.log('Element circleRadiusInput:', this.elements.circleRadiusInput ? 'found' : 'NOT found');
                this.elements.arcRadiusInput = document.getElementById('arcRadiusInput');
                console.log('Element arcRadiusInput:', this.elements.arcRadiusInput ? 'found' : 'NOT found');
                this.elements.arcStartAngleInput = document.getElementById('arcStartAngleInput');
                console.log('Element arcStartAngleInput:', this.elements.arcStartAngleInput ? 'found' : 'NOT found');
                this.elements.arcEndAngleInput = document.getElementById('arcEndAngleInput');
                console.log('Element arcEndAngleInput:', this.elements.arcEndAngleInput ? 'found' : 'NOT found');
                this.elements.arcClockwiseInput = document.getElementById('arcClockwiseInput');
                console.log('Element arcClockwiseInput:', this.elements.arcClockwiseInput ? 'found' : 'NOT found');
                this.elements.rectWidthInput = document.getElementById('rectWidthInput');
                console.log('Element rectWidthInput:', this.elements.rectWidthInput ? 'found' : 'NOT found');
                this.elements.rectHeightInput = document.getElementById('rectHeightInput');
                console.log('Element rectHeightInput:', this.elements.rectHeightInput ? 'found' : 'NOT found');
                this.elements.triBaseInput = document.getElementById('triBaseInput');
                console.log('Element triBaseInput:', this.elements.triBaseInput ? 'found' : 'NOT found');
                this.elements.triHeightInput = document.getElementById('triHeightInput');
                console.log('Element triHeightInput:', this.elements.triHeightInput ? 'found' : 'NOT found');

                this.elements.cubeOptions = document.getElementById('cubeOptions');
                console.log('Element cubeOptions:', this.elements.cubeOptions ? 'found' : 'NOT found');
                this.elements.sphereOptions = document.getElementById('sphereOptions');
                console.log('Element sphereOptions:', this.elements.sphereOptions ? 'found' : 'NOT found');
                this.elements.cylinderOptions = document.getElementById('cylinderOptions');
                console.log('Element cylinderOptions:', this.elements.cylinderOptions ? 'found' : 'NOT found');
                this.elements.addBasicShapeBtn = document.getElementById('addBasicShapeBtn');
                console.log('Element addBasicShapeBtn:', this.elements.addBasicShapeBtn ? 'found' : 'NOT found');

                // New camera type buttons
                this.elements.perspectiveViewBtn = document.getElementById('perspectiveViewBtn');
                console.log('Element perspectiveViewBtn:', this.elements.perspectiveViewBtn ? 'found' : 'NOT found');
                this.elements.orthographicViewBtn = document.getElementById('orthographicViewBtn');
                console.log('Element orthographicViewBtn:', this.elements.orthographicViewBtn ? 'found' : 'NOT found');

                // New drawing plane Y input
                this.elements.drawingPlaneYInput = document.getElementById('drawingPlaneYInput');
                console.log('Element drawingPlaneYInput:', this.elements.drawingPlaneYInput ? 'found' : 'NOT found');

                // New snap to grid elements
                this.elements.snapGridOnBtn = document.getElementById('snapGridOnBtn');
                console.log('Element snapGridOnBtn:', this.elements.snapGridOnBtn ? 'found' : 'NOT found');
                this.elements.snapGridOffBtn = document.getElementById('snapGridOffBtn');
                console.log('Element snapGridOffBtn:', this.elements.snapGridOffBtn ? 'found' : 'NOT found');
                this.elements.gridSnapResolutionInput = document.getElementById('gridSnapResolutionInput');
                console.log('Element gridSnapResolutionInput:', this.elements.gridSnapResolutionInput ? 'found' : 'NOT found');
            }

            addEventListeners() {
                // Mode buttons
                if (this.elements.viewModeBtn) {
                    this.elements.viewModeBtn.addEventListener('click', () => {
                        console.log('View Mode button clicked.');
                        this.drawingManager.setDrawingMode(false);
                        this.objectManager.paintBucketMode = false; // Directly set property
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                    });
                } else {
                    console.error("UIManager: viewModeBtn not found, cannot attach event listener.");
                }
                if (this.elements.drawModeBtn) {
                    this.elements.drawModeBtn.addEventListener('click', () => {
                        console.log('Draw Mode button clicked.');
                        this.drawingManager.setDrawingMode(true);
                        this.objectManager.paintBucketMode = false; // Directly set property
                        this.objectManager.selectObject(null); // Deselect any object in drawing mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                        this.drawingManager.clearDrawing(true); // Clear and save initial state for undo
                    });
                } else {
                    console.error("UIManager: drawModeBtn not found, cannot attach event listener.");
                }

                // Drawing Plane Y-position input
                if (this.elements.drawingPlaneYInput) {
                    this.elements.drawingPlaneYInput.addEventListener('input', () => {
                        const yValue = parseFloat(this.elements.drawingPlaneYInput.value);
                        if (!isNaN(yValue)) {
                            this.drawingManager.setDrawingPlaneY(yValue);
                        }
                    });
                }

                // Snap to Grid buttons
                if (this.elements.snapGridOnBtn) {
                    this.elements.snapGridOnBtn.addEventListener('click', () => {
                        this.drawingManager.setSnapToGrid(true);
                        this.updateUI();
                    });
                }
                if (this.elements.snapGridOffBtn) {
                    this.elements.snapGridOffBtn.addEventListener('click', () => {
                        this.drawingManager.setSnapToGrid(false);
                        this.updateUI();
                    });
                }

                // Grid Snap Resolution input
                if (this.elements.gridSnapResolutionInput) {
                    this.elements.gridSnapResolutionInput.addEventListener('input', () => {
                        const resolution = parseFloat(this.elements.gridSnapResolutionInput.value);
                        if (!isNaN(resolution) && resolution > 0) {
                            this.drawingManager.setGridSnapResolution(resolution);
                        }
                    });
                }

                // View preset buttons
                if (this.elements.viewTopBtn) this.elements.viewTopBtn.addEventListener('click', () => this.sceneManager.setPresetView('top'));
                if (this.elements.viewFrontBtn) this.elements.viewFrontBtn.addEventListener('click', () => this.sceneManager.setPresetView('front'));
                if (this.elements.viewRightBtn) this.elements.viewRightBtn.addEventListener('click', () => this.sceneManager.setPresetView('right'));
                if (this.elements.viewIsoBtn) this.elements.viewIsoBtn.addEventListener('click', () => this.sceneManager.setPresetView('iso'));

                // Camera type buttons
                if (this.elements.perspectiveViewBtn) {
                    this.elements.perspectiveViewBtn.addEventListener('click', () => {
                        this.sceneManager.setCameraType('perspective');
                        this.updateUI();
                    });
                }
                if (this.elements.orthographicViewBtn) {
                    this.elements.orthographicViewBtn.addEventListener('click', () => {
                        this.sceneManager.setCameraType('orthographic');
                        this.updateUI();
                    });
                }

                // Solid/Wireframe view buttons
                if (this.elements.solidViewBtn) {
                    this.elements.solidViewBtn.addEventListener('click', () => {
                        this.sceneManager.setWireframeMode(false);
                        this.updateUI();
                    });
                }
                if (this.elements.wireframeViewBtn) {
                    this.elements.wireframeViewBtn.addEventListener('click', () => {
                        this.sceneManager.setWireframeMode(true);
                        this.updateUI();
                    });
                }

                // Grid visibility buttons
                if (this.elements.showGridBtn) {
                    this.elements.showGridBtn.addEventListener('click', () => {
                        this.sceneManager.setGridVisibility(true);
                        this.updateUI();
                    });
                }
                if (this.elements.hideGridBtn) {
                    this.elements.hideGridBtn.addEventListener('click', () => {
                        this.sceneManager.setGridVisibility(false);
                        this.updateUI();
                    });
                }

                // Toolbar buttons
                if (this.elements.setupBaseBtn) this.elements.setupBaseBtn.addEventListener('click', () => this.sceneManager.resetScene());
                if (this.elements.materialsBtn) {
                    this.elements.materialsBtn.addEventListener('click', () => {
                        this.objectManager.paintBucketMode = false; // Directly set property
                        this.drawingManager.setDrawingMode(false); // Exit drawing mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                        if (this.objectManager.selectedObject) {
                            this.objectManager.selectObject(this.objectManager.selectedObject); // Re-select to update panel
                            this.elements.objectPropertiesPanel.classList.remove('hidden');
                        } else {
                            UIManager.showModalMessage("Materials", "Select an object to modify its material.");
                        }
                    });
                }
                if (this.elements.paintBucketBtn) {
                    this.elements.paintBucketBtn.addEventListener('click', () => {
                        this.objectManager.togglePaintBucketMode();
                        this.drawingManager.setDrawingMode(false);
                        this.objectManager.selectObject(null);
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.updateUI();
                        UIManager.showModalMessage("Paint Bucket Mode", this.objectManager.paintBucketMode ? "Modalità 'Secchiello di vernice' attivata. Clicca su un oggetto per colorarlo." : "Modalità 'Secchiello di vernice' disattivata.");
                    });
                }
                if (this.elements.lightsBtn) this.elements.lightsBtn.addEventListener('click', () => UIManager.showModalMessage("Funzionalità Non Disponibile", "La gestione delle luci non è ancora implementata."));
                if (this.elements.importBtn) this.elements.importBtn.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                    this.updateUI();
                    this.objectManager.startImportSequence();
                });
                if (this.elements.objInputHidden) this.elements.objInputHidden.addEventListener('change', (e) => this.objectManager.handleObjFileSelection(e.target.files[0]));
                if (this.elements.mtlInputHidden) this.elements.mtlInputHidden.addEventListener('change', (e) => this.objectManager.handleMtlFileSelection(e.target.files[0]));
                if (this.elements.textureInputHidden) this.elements.textureInputHidden.addEventListener('change', (e) => this.objectManager.handleTextureFileSelection(Array.from(e.target.files)));
                if (this.elements.controlsBtn) this.elements.controlsBtn.addEventListener('click', () => UIManager.showModalMessage("Funzionalità Non Disponibile", "Controlli avanzati non ancora implementati. Usa il mouse per orbitare."));
                if (this.elements.performanceBtn) this.elements.performanceBtn.addEventListener('click', () => UIManager.showModalMessage("Funzionalità Non Disponibile", "Opzioni di ottimizzazione delle prestazioni non ancora implementate."));
                if (this.elements.infoBtn) this.elements.infoBtn.addEventListener('click', () => this.showInfoModal());

                // Geometries Dropdown
                if (this.elements.lineToolBtnToolbar) {
                    this.elements.lineToolBtnToolbar.addEventListener('click', () => {
                        console.log('Line Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('line');
                    });
                }
                if (this.elements.polylineToolBtnToolbar) {
                    this.elements.polylineToolBtnToolbar.addEventListener('click', () => {
                        console.log('Polyline Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('polyline');
                    });
                }
                if (this.elements.circleToolBtnToolbar) {
                    this.elements.circleToolBtnToolbar.addEventListener('click', () => {
                        console.log('Circle Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('circle');
                    });
                }
                if (this.elements.arcToolBtnToolbar) {
                    this.elements.arcToolBtnToolbar.addEventListener('click', () => {
                        console.log('Arc Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('arc');
                    });
                }
                if (this.elements.triangleToolBtnToolbar) {
                    this.elements.triangleToolBtnToolbar.addEventListener('click', () => {
                        console.log('Triangle Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('triangle');
                    });
                }
                if (this.elements.rectangleToolBtnToolbar) {
                    this.elements.rectangleToolBtnToolbar.addEventListener('click', () => {
                        console.log('Rectangle Tool button clicked.');
                        this.drawingManager.setDrawingMode(true); // Ensure drawing mode is active
                        this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                        this.objectManager.setCurrentBasic3DShapeTool('none'); // Clear basic 3D shape tool
                        this.drawingManager.setCurrentDrawingTool('rectangle');
                    });
                }
                if (this.elements.addCubeBtnToolbar) this.elements.addCubeBtnToolbar.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('cube'); // Set basic 3D shape tool
                    this.objectManager.addBasic3DShape('cube');
                });
                if (this.elements.addSphereBtnToolbar) this.elements.addSphereBtnToolbar.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('sphere'); // Set basic 3D shape tool
                    this.objectManager.addBasic3DShape('sphere');
                });
                if (this.elements.addCylinderBtnToolbar) this.elements.addCylinderBtnToolbar.addEventListener('click', () => {
                    this.drawingManager.setDrawingMode(false); // Exit drawing mode
                    this.objectManager.paintBucketMode = false; // Exit paint bucket mode
                    this.objectManager.setCurrentBasic3DShapeTool('cylinder'); // Set basic 3D shape tool
                    this.objectManager.addBasic3DShape('cylinder');
                });

                // Templates Dropdown
                if (this.elements.applyWoodMaterialBtn) this.elements.applyWoodMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.woodMaterial, 'Legno'));
                if (this.elements.applyMarbleMaterialBtn) this.elements.applyMarbleMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.marbleMaterial, 'Marmo'));
                if (this.elements.applyMetalMaterialBtn) this.elements.applyMetalMaterialBtn.addEventListener('click', () => this.objectManager.applyMaterial(this.objectManager.metalMaterial, 'Metallo'));
                if (this.elements.addChairBtnToolbar) this.elements.addChairBtnToolbar.addEventListener('click', () => this.objectManager.addChair());
                if (this.elements.addTableBtnToolbar) this.elements.addTableBtnToolbar.addEventListener('click', () => this.objectManager.addTable());
                if (this.elements.addEmptyRoomBtnToolbar) this.elements.addEmptyRoomBtnToolbar.addEventListener('click', () => this.objectManager.addEmptyRoom());

                // Drawing and Extrusion controls
                if (this.elements.closePathBtn) this.elements.closePathBtn.addEventListener('click', () => this.drawingManager.closePath());
                if (this.elements.undoDrawingBtn) this.elements.undoDrawingBtn.addEventListener('click', () => this.drawingManager.undoDrawing());
                if (this.elements.extrudeBtn) this.elements.extrudeBtn.addEventListener('click', () => this.drawingManager.extrudeShape(parseFloat(this.elements.extrusionDepthInput.value)));

                // Object management controls
                if (this.elements.removeObjectBtn) this.elements.removeObjectBtn.addEventListener('click', () => this.objectManager.removeSelectedObject());
                if (this.elements.resetSceneBtnSide) this.elements.resetSceneBtnSide.addEventListener('click', () => this.sceneManager.resetScene());
                if (this.elements.generateCodeBtn) this.elements.generateCodeBtn.addEventListener('click', () => this.exportManager.generateThreeJsCode());
                if (this.elements.copyCodeBtn) this.elements.copyCodeBtn.addEventListener('click', () => this.exportManager.copyGeneratedCode());
                if (this.elements.printBtn) this.elements.printBtn.addEventListener('click', () => window.print());
                if (this.elements.exportDXFBtn) this.elements.exportDXFBtn.addEventListener('click', () => this.exportManager.exportDXF());
                if (this.elements.exportPDFBtn) this.elements.exportPDFBtn.addEventListener('click', () => this.exportManager.handleExport());

                // Object properties controls
                if (this.elements.objectColorInput) this.elements.objectColorInput.addEventListener('input', () => this.objectManager.updateSelectedObjectColor(this.elements.objectColorInput.value));
                if (this.elements.posXInput) this.elements.posXInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('x', parseFloat(this.elements.posXInput.value)));
                if (this.elements.posYInput) this.elements.posYInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('y', parseFloat(this.elements.posYInput.value)));
                if (this.elements.posZInput) this.elements.posZInput.addEventListener('input', () => this.objectManager.updateSelectedObjectPosition('z', parseFloat(this.elements.posZInput.value)));
                if (this.elements.rotXInput) this.elements.rotXInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('x', parseFloat(this.elements.rotXInput.value)));
                if (this.elements.rotYInput) this.elements.rotYInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('y', parseFloat(this.elements.rotYInput.value)));
                if (this.elements.rotZInput) this.elements.rotZInput.addEventListener('input', () => this.objectManager.updateSelectedObjectRotation('z', parseFloat(this.elements.rotZInput.value)));

                // Object selection dropdown
                if (this.elements.selectedObjectSelect) {
                    this.elements.selectedObjectSelect.addEventListener('change', () => {
                        const uuid = this.elements.selectedObjectSelect.value;
                        const obj = this.objectManager.objects.find(o => o.uuid === uuid);
                        this.objectManager.selectObject(obj);
                    });
                }

                // Keyboard shortcuts
                document.addEventListener('keydown', (event) => {
                    if (event.ctrlKey && event.key === 'z') {
                        event.preventDefault(); // Prevent browser undo
                        this.drawingManager.undoDrawing();
                    }
                });
            }

            updateUI() {
                // Update mode buttons
                if (this.elements.viewModeBtn) {
                    this.elements.viewModeBtn.classList.toggle('bg-blue-600', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('text-white', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('shadow-md', !this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('text-gray-700', this.drawingManager.drawingMode);
                    this.elements.viewModeBtn.classList.toggle('hover:bg-gray-200', this.drawingManager.drawingMode);
                }

                if (this.elements.drawModeBtn) {
                    this.elements.drawModeBtn.classList.toggle('bg-blue-600', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('text-white', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('shadow-md', this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('text-gray-700', !this.drawingManager.drawingMode);
                    this.elements.drawModeBtn.classList.toggle('hover:bg-gray-200', !this.drawingManager.drawingMode);
                }

                // Show/hide control panels based on mode
                if (this.elements.viewControlsPanel) this.elements.viewControlsPanel.classList.toggle('hidden', this.drawingManager.drawingMode);
                if (this.elements.drawingControls) this.elements.drawingControls.classList.toggle('hidden', !this.drawingManager.drawingMode);
                
                // Show basic 3D shape controls only in view mode
                if (this.elements.basic3DShapeControls) this.elements.basic3DShapeControls.classList.toggle('hidden', this.drawingManager.drawingMode);
                
                if (this.elements.extrusionControls) this.elements.extrusionControls.classList.add('hidden'); // Always hide initially, shown by drawing manager

                // Object properties panel visibility
                if (this.elements.objectPropertiesPanel) this.elements.objectPropertiesPanel.classList.toggle('hidden', !this.objectManager.selectedObject || this.drawingManager.drawingMode);

                // Update drawing tool options visibility
                [this.elements.lineDrawingOptions, this.elements.circleDrawingOptions, this.elements.arcDrawingOptions, this.elements.rectangleDrawingOptions, this.elements.triangleDrawingOptions].forEach(opt => {
                    if (opt) opt.classList.add('hidden');
                });

                if (this.drawingManager.drawingMode) {
                    if (this.elements.drawingPlaneYInput) {
                        this.elements.drawingPlaneYInput.value = (this.drawingManager.drawingPlaneMesh.position.y * 100).toFixed(1);
                    }

                    // Update Snap to Grid buttons
                    if (this.elements.snapGridOnBtn) {
                        this.elements.snapGridOnBtn.classList.toggle('bg-blue-600', this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('text-white', this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('shadow-md', this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('text-gray-700', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOnBtn.classList.toggle('hover:bg-gray-200', !this.drawingManager.snapToGrid);
                    }
                    if (this.elements.snapGridOffBtn) {
                        this.elements.snapGridOffBtn.classList.toggle('bg-blue-600', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('text-white', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('shadow-md', !this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('text-gray-700', this.drawingManager.snapToGrid);
                        this.elements.snapGridOffBtn.classList.toggle('hover:bg-gray-200', this.drawingManager.snapToGrid);
                    }

                    // Update Grid Snap Resolution input
                    if (this.elements.gridSnapResolutionInput) {
                        this.elements.gridSnapResolutionInput.value = (this.drawingManager.gridSnapResolution * 100).toFixed(0);
                    }


                    if (this.drawingManager.currentDrawingTool === 'line' || this.drawingManager.currentDrawingTool === 'polyline') {
                        if (this.elements.lineDrawingOptions) this.elements.lineDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.toggle('hidden', !(this.drawingManager.currentDrawingTool === 'polyline' && this.drawingManager.drawnPoints.length >= 3));
                    } else if (this.drawingManager.currentDrawingTool === 'circle') {
                        if (this.elements.circleDrawingOptions) this.elements.circleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'arc') {
                        if (this.elements.arcDrawingOptions) this.elements.arcDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'rectangle') { // Corrected from this.currentDrawingTool
                        if (this.elements.rectangleDrawingOptions) this.elements.rectangleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    } else if (this.drawingManager.currentDrawingTool === 'triangle') { // Corrected from this.currentDrawingTool
                        if (this.elements.triangleDrawingOptions) this.elements.triangleDrawingOptions.classList.remove('hidden');
                        if (this.elements.closePathBtn) this.elements.closePathBtn.classList.add('hidden');
                    }
                }

                // Update basic 3D shape tool options visibility
                [this.elements.cubeOptions, this.elements.sphereOptions, this.elements.cylinderOptions].forEach(opt => {
                    if (opt) opt.classList.add('hidden');
                });
                if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.add('hidden');

                if (!this.drawingManager.drawingMode && this.objectManager.currentBasic3DShapeTool) {
                    if (this.objectManager.currentBasic3DShapeTool === 'cube') {
                        if (this.elements.cubeOptions) this.elements.cubeOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    } else if (this.objectManager.currentBasic3DShapeTool === 'sphere') {
                        if (this.elements.sphereOptions) this.elements.sphereOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    } else if (this.objectManager.currentBasic3DShapeTool === 'cylinder') {
                        if (this.elements.cylinderOptions) this.elements.cylinderOptions.classList.remove('hidden');
                        if (this.elements.addBasicShapeBtn) this.elements.addBasicShapeBtn.classList.remove('hidden');
                    }
                }

                // Update solid/wireframe buttons
                if (this.elements.solidViewBtn) {
                    this.elements.solidViewBtn.classList.toggle('bg-blue-600', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('text-white', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('shadow-md', !this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('text-gray-700', this.sceneManager.isWireframe);
                    this.elements.solidViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.isWireframe);
                }

                if (this.elements.wireframeViewBtn) {
                    this.elements.wireframeViewBtn.classList.toggle('bg-blue-600', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('text-white', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('shadow-md', this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('text-gray-700', !this.sceneManager.isWireframe);
                    this.elements.wireframeViewBtn.classList.toggle('hover:bg-gray-200', !this.sceneManager.isWireframe);
                }

                // Update camera type buttons
                if (this.elements.perspectiveViewBtn) {
                    this.elements.perspectiveViewBtn.classList.toggle('bg-blue-600', this.sceneManager.cameraType === 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('text-white', this.sceneManager.cameraType === 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('shadow-md', this.sceneManager.cameraType === 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('text-gray-700', this.sceneManager.cameraType !== 'perspective');
                    this.elements.perspectiveViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.cameraType !== 'perspective');
                }
                if (this.elements.orthographicViewBtn) {
                    this.elements.orthographicViewBtn.classList.toggle('bg-blue-600', this.sceneManager.cameraType === 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('text-white', this.sceneManager.cameraType === 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('shadow-md', this.sceneManager.cameraType === 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('text-gray-700', this.sceneManager.cameraType !== 'orthographic');
                    this.elements.orthographicViewBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.cameraType !== 'orthographic');
                }

                // Update grid visibility buttons
                if (this.elements.showGridBtn) {
                    this.elements.showGridBtn.classList.toggle('bg-blue-600', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('text-white', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('shadow-md', this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('text-gray-700', !this.sceneManager.isGridVisible);
                    this.elements.showGridBtn.classList.toggle('hover:bg-gray-200', !this.sceneManager.isGridVisible);
                }

                if (this.elements.hideGridBtn) {
                    this.elements.hideGridBtn.classList.toggle('bg-blue-600', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('text-white', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('shadow-md', !this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('text-gray-700', this.sceneManager.isGridVisible);
                    this.elements.hideGridBtn.classList.toggle('hover:bg-gray-200', this.sceneManager.isGridVisible);
                }

                // Update toolbar active states (only paint bucket for now)
                [this.elements.setupBaseBtn, this.elements.materialsBtn, this.elements.paintBucketBtn, this.elements.lightsBtn, this.elements.importBtn, this.elements.controlsBtn, this.elements.performanceBtn, this.elements.infoBtn, this.elements.geometriesDropdownBtn, this.elements.templatesDropdownBtn].forEach(btn => {
                    if (btn) btn.classList.remove('active');
                });
                if (this.elements.paintBucketBtn && this.objectManager.paintBucketMode) {
                    this.elements.paintBucketBtn.classList.add('active');
                }

                // Update drawn points count
                if (this.elements.drawnPointsCount) {
                    this.elements.drawnPointsCount.textContent = this.drawingManager.drawnPoints.length;
                }
            }

            // Method to update the dropdown list of selected objects
            updateSelectedObjectOptions(objects, selectedObject) {
                if (!this.elements.selectedObjectSelect) {
                    console.error("UIManager: selectedObjectSelect element not found.");
                    return;
                }
                this.elements.selectedObjectSelect.innerHTML = ''; // Clear existing options
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Nessun oggetto selezionato';
                this.elements.selectedObjectSelect.appendChild(defaultOption);

                objects.forEach(obj => {
                    const option = document.createElement('option');
                    option.value = obj.uuid;
                    option.textContent = obj.name || `Oggetto ${obj.uuid.substring(0, 4)}`;
                    this.elements.selectedObjectSelect.appendChild(option);
                });

                if (selectedObject) {
                    this.elements.selectedObjectSelect.value = selectedObject.uuid;
                } else {
                    this.elements.selectedObjectSelect.value = '';
                }
            }

            // Method to update the properties panel for the selected object
            updateObjectProperties(object) {
                if (!this.elements.objectPropertiesPanel) {
                    console.error("UIManager: objectPropertiesPanel element not found.");
                    return;
                }

                if (object) {
                    this.elements.objectPropertiesPanel.classList.remove('hidden');
                    // Set color
                    if (object.material && object.material.color) {
                        this.elements.objectColorInput.value = `#${object.material.color.getHexString()}`;
                    } else {
                        this.elements.objectColorInput.value = '#cccccc'; // Default if no color
                    }

                    // Set position
                    this.elements.posXInput.value = object.position.x.toFixed(2);
                    this.elements.posYInput.value = object.position.y.toFixed(2);
                    this.elements.posZInput.value = object.position.z.toFixed(2);

                    // Set rotation (convert radians to degrees)
                    this.elements.rotXInput.value = THREE.MathUtils.radToDeg(object.rotation.x).toFixed(0);
                    this.elements.rotYInput.value = THREE.MathUtils.radToDeg(object.rotation.y).toFixed(0);
                    this.elements.rotZInput.value = THREE.MathUtils.radToDeg(object.rotation.z).toFixed(0);
                } else {
                    this.elements.objectPropertiesPanel.classList.add('hidden');
                }
            }


            // Static method for modal messages
            static showModalMessage(title, message, customButtons = '') {
                const modalBackdrop = document.createElement('div');
                modalBackdrop.className = 'modal-backdrop';
                modalBackdrop.id = 'customModal';

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';
                modalContent.innerHTML = `
                    <h3 class="font-bold">${title}</h3>
                    <p class="text-gray-700">${message}</p>
                    <div class="mt-4">
                        ${customButtons || `<button class="modal-button bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors duration-300 shadow-md" onclick="document.getElementById('customModal').remove()">Chiudi</button>`}
                    </div>
                `;

                modalBackdrop.appendChild(modalContent);
                document.body.appendChild(modalBackdrop);
            }

            // Static method for floating status messages
            static showStatus(text, isError = false) {
                const el = document.getElementById('export-status');
                if (el) {
                    el.textContent = text;
                    el.style.display = 'block';
                    el.style.backgroundColor = isError ? '#c0392b' : '#2c3e50';
                    setTimeout(() => el.style.display = 'none', 3000);
                }
            }

            showInfoModal() {
                const infoContent = `
                    <p class="text-left text-gray-700 mb-4">Benvenuto! Ecco una guida rapida all'uso dei vari strumenti:</p>
                    <div class="text-left text-gray-700 text-sm">
                        <p class="mb-2"><strong>🛠️ Setup Base:</strong> Resetta l'intera scena, rimuovendo tutti gli oggetti e il disegno 2D.</p>
                        <p class="mb-2"><strong>🧊 Geometrie:</strong> Questo menu ti permette di selezionare strumenti per il disegno 2D o per aggiungere forme 3D di base:</p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Linea, Polilinea, Cerchio, Arco, Triangolo, Rettangolo:</strong> Strumenti per disegnare forme 2D sul piano. Una volta disegnate, puoi estruderle.</li>
                            <li><strong>Cubo, Sfera, Cilindro:</strong> Aggiunge direttamente queste forme 3D predefinite alla scena.</li>
                        </ul>
                        <p class="mb-2"><strong>🎨 Materiali:</strong> Seleziona un oggetto nella scena e usa il pannello laterale "Proprietà Oggetto" per cambiare il suo colore. Puoi anche applicare materiali predefiniti dal menu "Template".</p>
                        <p class="mb-2"><strong>🖌️ Applica Materiale:</strong> Attiva la modalità "secchiello di vernice". Clicca su qualsiasi oggetto nella scena per applicare il colore corrente selezionato nel pannello delle proprietà.</p>
                        <p class="mb-2"><strong>💡 Luci:</strong> Funzionalità per la gestione dell'illuminazione (non ancora implementata).</p>
                        <p class="mb-2"><strong>📦 Importa:</strong> Ti permette di caricare modelli 3D esterni nei formati ".gltf", ".glb" o ".obj" nella scena.</p>
                        <p class="mb-2"><strong>🪑 Template:</strong> Questo menu offre materiali predefiniti (Legno, Marmo, Metallo) da applicare agli oggetti selezionati e oggetti di interior design pre-assemblati (Sedia, Tavolo, Stanza Vuota).</p>
                        <p class="mb-2"><strong>✋ Controlli:</strong> Informazioni sui controlli di navigazione (non ancora implementata).</p>
                        <p class="mb-2"><strong>⚡ Performance:</strong> Opzioni di ottimizzazione del rendering (non ancora implementata).</p>
                        <p class="mb-2"><strong>ℹ️ Info:</strong> Mostra questa finestra di aiuto.</p>
                        <p class="mt-4"><strong>Modalità Vista/Disegno (Pannello Laterale):</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Vista:</strong> Ti permette di orbitare, zoomare e spostare la telecamera per visualizzare la scena 3D.</li>
                            <li><strong>Disegno:</strong> Attiva il piano di disegno 2D per creare forme che possono poi essere estruse.</li>
                            <li><strong>Sfera Rossa (Indicatore):</strong> In modalità Disegno, una piccola sfera rossa ti mostra esattamente dove verrà posizionato il prossimo punto sul piano di disegno.</li>
                            <li><strong>Snap alla Griglia:</strong> Attiva/disattiva l'aggancio dei punti alla griglia. Puoi impostare la "Risoluzione Snap Griglia (cm)" per controllare la precisione dello snap.</li>
                        </ul>
                        <p class="mt-4"><strong>Controlli Generali:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Mouse:</strong> Clicca e trascina per orbitare (modalità Vista) o per disegnare (modalità Disegno).</li>
                            <li><strong>Rotellina del mouse:</strong> Zoom.</li>
                            <li><strong>Ctrl + Z:</strong> Annulla l'ultima operazione di disegno 2D.</li>
                        </ul>
                        <p class="mt-4"><strong>Funzionamento della modalità Ortogonale (Orto):</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li><strong>Blocco del cursore:</strong> Quando la modalità Orto è attiva, il cursore si muove solo lungo assi orizzontali o verticali rispetto al sistema di coordinate corrente (UCS).</li>
                            <li><strong>Disegno preciso:</strong> Permette di disegnare linee con angoli di 90 gradi, creando segmenti perfettamente orizzontali o verticali.</li>
                            <li><strong>Spostamento e copia:</strong> La modalità Orto è utile anche per spostare o copiare elementi in direzione orizzontale o verticale.</li>
                            <li><strong>Attivazione/disattivazione:</strong> Si attiva/disattiva cliccando sul pulsante "Ortogonale" nel pannello di controllo. Il supporto per il tasto F8 e la disattivazione temporanea con Maiusc <strong>non sono implementati</strong> in questa versione.</li>
                            <li><strong>Priorità:</strong> La modalità Orto ha la precedenza sugli snap ad oggetto e sull'immissione diretta della distanza (questo comportamento <strong>non è implementato</strong> in questa versione).</li>
                            <li><strong>Esempio pratico:</strong> Se si sta disegnando una linea e si vuole assicurare che sia perfettamente orizzontale, si può attivare la modalità Orto prima di specificare il secondo punto della linea. In questo modo, il cursore si muoverà solo orizzontalmente, garantendo che la linea sia parallela all'asse X del sistema di coordinate.</li>
                        </ul>
                        <p class="mt-4"><strong>Differenza con il puntamento polare:</strong> La modalità Orto e il puntamento polare non possono essere attivati contemporaneamente. L'attivazione di Orto disattiva il puntamento polare e viceversa (il puntamento polare <strong>non è implementato</strong> in questa versione).</p>
                        <p class="mt-4"><strong>Limitazioni Importazione OBJ+Texture:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>I file `.mtl` devono usare nomi semplici per le texture (es. "diffuse.jpg" invece di "./textures/diffuse.jpg").</li>
                            <li>Le dimensioni massime dei file sono limitate dalla memoria del browser.</li>
                            <li>Per modelli molto complessi (>50MB) potrebbero esserci problemi di prestazioni o di caricamento.</li>
                            <li>Se non vedi il tuo modello, prova a scalare la scena o il modello stesso.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Esportazione DXF:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>Supporta principalmente solo entità geometriche di base (punti, linee, polilinee). Spline, curve NURBS, testo, dimensioni e altre entità CAD complesse <strong>non sono supportate</strong> direttamente e vengono convertite in linee o saltate.</li>
                            <li>Le texture e i materiali <strong>non vengono esportati</strong> (il DXF è principalmente un formato geometrico). I colori vengono mappati a indici colore DXF standard.</li>
                            <li>Per oggetti complessi o modelli importati, la geometria viene convertita in bordi (linee) per l'esportazione. Questo può risultare in file DXF molto grandi o con dettagli eccessivi. Considera di semplificare la geometria prima dell'esportazione per ottenere un file DXF più gestibile.</li>
                            <li>I gruppi di oggetti Three.js vengono esportati come "blocchi" DXF, migliorando l'organizzazione del file.</li>
                            <li>La scala di esportazione è configurabile (default: 1 unità Three.js = 1 millimetro DXF).</li>
                            <li>La precisione decimale delle coordinate è configurabile per bilanciare fedeltà e dimensione del file.</li>
                            <li>Questa è un'implementazione lato client e potrebbe non essere compatibile con tutte le versioni di software CAD o supportare tutte le specifiche DXF.</li>
                        </ul>
                        <p class="mt-4"><strong>Limitazioni Esportazione PDF:</strong></p>
                        <ul class="list-disc list-inside ml-4 mb-2">
                            <li>L'esportazione PDF genera un'immagine raster (non vettoriale) della vista corrente del canvas.</li>
                            <li>La qualità dell'immagine dipenderà dalla risoluzione del canvas e dalle impostazioni del renderer.</li>
                            <li>Non è un'esportazione CAD vettoriale, ma una "istantanea" visiva.</li>
                            <li>Il caricamento della libreria jsPDF avviene solo al momento del click per ottimizzare le prestazioni iniziali.</li>
                        </ul>
                    </div>
                `;
                UIManager.showModalMessage("Guida all'Uso del Modellatore 3D", infoContent);
            }
        }

        // --- Main Application Initialization ---
        let sceneManager, objectManager, drawingManager, uiManager, exportManager;

        function initApp() {
            // Check WebGL support
            if (!window.WebGLRenderingContext) {
                UIManager.showModalMessage("Warning", "Your browser may not support WebGL, 3D features might be limited.");
            }

            const canvasContainer = document.getElementById('canvas-container');

            // 1. Initialize SceneManager (no external dependencies yet)
            sceneManager = new SceneManager(canvasContainer);

            // 2. Initialize ObjectManager and DrawingManager with null UIManager references initially
            objectManager = new ObjectManager(sceneManager, null, null);
            drawingManager = new DrawingManager(sceneManager, null, objectManager);

            // Now, set the drawingManager reference on objectManager (circular dependency)
            objectManager.drawingManager = drawingManager;

            // 3. Initialize ExportManager with null UIManager reference initially
            exportManager = new ExportManager(sceneManager, objectManager, null);

            // 4. Initialize UIManager, passing all other managers
            uiManager = new UIManager(sceneManager, objectManager, drawingManager, exportManager);

            // 5. Assign the fully initialized uiManager to other managers
            objectManager.uiManager = uiManager;
            drawingManager.uiManager = uiManager;
            exportManager.uiManager = uiManager;

            // Start animation loop
            sceneManager.animate();

            // Initial UI updates and state saving, now that all managers are fully linked
            uiManager.updateUI();
            objectManager.uiManager.updateSelectedObjectOptions(objectManager.objects, objectManager.selectedObject);
            drawingManager.saveDrawingState(); // Save initial empty state for undo

            console.log("App initialized and animate loop started.");
        }

        // Load polyfills if needed
        function loadPolyfills() {
            const needed = [];
            if (!window.Promise) needed.push('promise');
            // Note: HTMLCanvasElement.prototype.toDataURL is generally supported
            // If specific older browser support is needed, consider adding more checks
            
            if (needed.length > 0) {
                const polyfillUrl = `https://cdn.polyfill.io/v3/polyfill.min.js?features=${needed.join(',')}`;
                const script = document.createElement('script');
                script.src = polyfillUrl;
                script.onload = () => console.log('Polyfills loaded.');
                script.onerror = () => console.error('Failed to load polyfills.');
                document.head.appendChild(script);
            }
        }

        window.onload = function () {
            loadPolyfills();
            initApp();
        }
    </script>
</body>
</html>
